"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mobx";
exports.ids = ["vendor-chunks/mobx"];
exports.modules = {

/***/ "(ssr)/./node_modules/mobx/dist/mobx.esm.js":
/*!********************************************!*\
  !*** ./node_modules/mobx/dist/mobx.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $mobx: () => (/* binding */ $mobx),\n/* harmony export */   FlowCancellationError: () => (/* binding */ FlowCancellationError),\n/* harmony export */   ObservableMap: () => (/* binding */ ObservableMap),\n/* harmony export */   ObservableSet: () => (/* binding */ ObservableSet),\n/* harmony export */   Reaction: () => (/* binding */ Reaction),\n/* harmony export */   _allowStateChanges: () => (/* binding */ allowStateChanges),\n/* harmony export */   _allowStateChangesInsideComputed: () => (/* binding */ runInAction),\n/* harmony export */   _allowStateReadsEnd: () => (/* binding */ allowStateReadsEnd),\n/* harmony export */   _allowStateReadsStart: () => (/* binding */ allowStateReadsStart),\n/* harmony export */   _autoAction: () => (/* binding */ autoAction),\n/* harmony export */   _endAction: () => (/* binding */ _endAction),\n/* harmony export */   _getAdministration: () => (/* binding */ getAdministration),\n/* harmony export */   _getGlobalState: () => (/* binding */ getGlobalState),\n/* harmony export */   _interceptReads: () => (/* binding */ interceptReads),\n/* harmony export */   _isComputingDerivation: () => (/* binding */ isComputingDerivation),\n/* harmony export */   _resetGlobalState: () => (/* binding */ resetGlobalState),\n/* harmony export */   _startAction: () => (/* binding */ _startAction),\n/* harmony export */   action: () => (/* binding */ action),\n/* harmony export */   autorun: () => (/* binding */ autorun),\n/* harmony export */   comparer: () => (/* binding */ comparer),\n/* harmony export */   computed: () => (/* binding */ computed),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   createAtom: () => (/* binding */ createAtom),\n/* harmony export */   defineProperty: () => (/* binding */ apiDefineProperty),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   extendObservable: () => (/* binding */ extendObservable),\n/* harmony export */   flow: () => (/* binding */ flow),\n/* harmony export */   flowResult: () => (/* binding */ flowResult),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAtom: () => (/* binding */ getAtom),\n/* harmony export */   getDebugName: () => (/* binding */ getDebugName),\n/* harmony export */   getDependencyTree: () => (/* binding */ getDependencyTree),\n/* harmony export */   getObserverTree: () => (/* binding */ getObserverTree),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   intercept: () => (/* binding */ intercept),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isBoxedObservable: () => (/* binding */ isObservableValue),\n/* harmony export */   isComputed: () => (/* binding */ isComputed),\n/* harmony export */   isComputedProp: () => (/* binding */ isComputedProp),\n/* harmony export */   isFlow: () => (/* binding */ isFlow),\n/* harmony export */   isFlowCancellationError: () => (/* binding */ isFlowCancellationError),\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   isObservableArray: () => (/* binding */ isObservableArray),\n/* harmony export */   isObservableMap: () => (/* binding */ isObservableMap),\n/* harmony export */   isObservableObject: () => (/* binding */ isObservableObject),\n/* harmony export */   isObservableProp: () => (/* binding */ isObservableProp),\n/* harmony export */   isObservableSet: () => (/* binding */ isObservableSet),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   makeAutoObservable: () => (/* binding */ makeAutoObservable),\n/* harmony export */   makeObservable: () => (/* binding */ makeObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   onBecomeObserved: () => (/* binding */ onBecomeObserved),\n/* harmony export */   onBecomeUnobserved: () => (/* binding */ onBecomeUnobserved),\n/* harmony export */   onReactionError: () => (/* binding */ onReactionError),\n/* harmony export */   override: () => (/* binding */ override),\n/* harmony export */   ownKeys: () => (/* binding */ apiOwnKeys),\n/* harmony export */   reaction: () => (/* binding */ reaction),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   runInAction: () => (/* binding */ runInAction),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   spy: () => (/* binding */ spy),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   transaction: () => (/* binding */ transaction),\n/* harmony export */   untracked: () => (/* binding */ untracked),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   when: () => (/* binding */ when)\n/* harmony export */ });\nvar niceErrors = {\n    0: \"Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'\",\n    1: function _(annotationType, key) {\n        return \"Cannot apply '\" + annotationType + \"' to '\" + key.toString() + \"': Field not found.\";\n    },\n    /*\n  2(prop) {\n      return `invalid decorator for '${prop.toString()}'`\n  },\n  3(prop) {\n      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`\n  },\n  4(prop) {\n      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`\n  },\n  */ 5: \"'keys()' can only be used on observable objects, arrays, sets and maps\",\n    6: \"'values()' can only be used on observable objects, arrays, sets and maps\",\n    7: \"'entries()' can only be used on observable objects, arrays and maps\",\n    8: \"'set()' can only be used on observable objects, arrays and maps\",\n    9: \"'remove()' can only be used on observable objects, arrays and maps\",\n    10: \"'has()' can only be used on observable objects, arrays and maps\",\n    11: \"'get()' can only be used on observable objects, arrays and maps\",\n    12: \"Invalid annotation\",\n    13: \"Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    14: \"Intercept handlers should return nothing or a change object\",\n    15: \"Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    16: \"Modification exception: the internal structure of an observable array was changed.\",\n    17: function _(index, length) {\n        return \"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + length;\n    },\n    18: \"mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js\",\n    19: function _(other) {\n        return \"Cannot initialize from classes that inherit from Map: \" + other.constructor.name;\n    },\n    20: function _(other) {\n        return \"Cannot initialize map from \" + other;\n    },\n    21: function _(dataStructure) {\n        return \"Cannot convert to map from '\" + dataStructure + \"'\";\n    },\n    22: \"mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js\",\n    23: \"It is not possible to get index atoms from arrays\",\n    24: function _(thing) {\n        return \"Cannot obtain administration from \" + thing;\n    },\n    25: function _(property, name) {\n        return \"the entry '\" + property + \"' does not exist in the observable map '\" + name + \"'\";\n    },\n    26: \"please specify a property\",\n    27: function _(property, name) {\n        return \"no observable property '\" + property.toString() + \"' found on the observable object '\" + name + \"'\";\n    },\n    28: function _(thing) {\n        return \"Cannot obtain atom from \" + thing;\n    },\n    29: \"Expecting some object\",\n    30: \"invalid action stack. did you forget to finish an action?\",\n    31: \"missing option for computed: get\",\n    32: function _(name, derivation) {\n        return \"Cycle detected in computation \" + name + \": \" + derivation;\n    },\n    33: function _(name) {\n        return \"The setter of computed value '\" + name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\";\n    },\n    34: function _(name) {\n        return \"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\";\n    },\n    35: \"There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`\",\n    36: \"isolateGlobalState should be called before MobX is running any reactions\",\n    37: function _(method) {\n        return \"[mobx] `observableArray.\" + method + \"()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice().\" + method + \"()` instead\";\n    },\n    38: \"'ownKeys()' can only be used on observable objects\",\n    39: \"'defineProperty()' can only be used on observable objects\"\n};\nvar errors =  true ? niceErrors : 0;\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (true) {\n        var e = typeof error === \"string\" ? error : errors[error];\n        if (typeof e === \"function\") e = e.apply(null, args);\n        throw new Error(\"[MobX] \" + e);\n    }\n    throw new Error(typeof error === \"number\" ? \"[MobX] minified error nr: \" + error + (args.length ? \" \" + args.map(String).join(\",\") : \"\") + \". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts\" : \"[MobX] \" + error);\n}\nvar mockGlobal = {};\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return mockGlobal;\n}\n// We shorten anything used > 5 times\nvar assign = Object.assign;\nvar getDescriptor = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar objectPrototype = Object.prototype;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nvar EMPTY_OBJECT = {};\nObject.freeze(EMPTY_OBJECT);\nvar hasProxy = typeof Proxy !== \"undefined\";\nvar plainObjectString = /*#__PURE__*/ Object.toString();\nfunction assertProxies() {\n    if (!hasProxy) {\n        die( true ? \"`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`\" : 0);\n    }\n}\nfunction warnAboutProxyRequirement(msg) {\n    if ( true && globalState.verifyProxies) {\n        die(\"MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to \" + msg);\n    }\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\n/**\n * Makes sure that the provided function is invoked at most once.\n */ function once(func) {\n    var invoked = false;\n    return function() {\n        if (invoked) {\n            return;\n        }\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\nfunction isStringish(value) {\n    var t = typeof value;\n    switch(t){\n        case \"string\":\n        case \"symbol\":\n        case \"number\":\n            return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nfunction isPlainObject(value) {\n    if (!isObject(value)) {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    var protoConstructor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    return typeof protoConstructor === \"function\" && protoConstructor.toString() === plainObjectString;\n}\n// https://stackoverflow.com/a/37865170\nfunction isGenerator(obj) {\n    var constructor = obj == null ? void 0 : obj.constructor;\n    if (!constructor) {\n        return false;\n    }\n    if (\"GeneratorFunction\" === constructor.name || \"GeneratorFunction\" === constructor.displayName) {\n        return true;\n    }\n    return false;\n}\nfunction addHiddenProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction createInstanceofPredicate(name, theClass) {\n    var propName = \"isMobX\" + name;\n    theClass.prototype[propName] = true;\n    return function(x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\n/**\n * Yields true for both native and observable Map, even across different windows.\n */ function isES6Map(thing) {\n    return thing != null && Object.prototype.toString.call(thing) === \"[object Map]\";\n}\n/**\n * Makes sure a Map is an instance of non-inherited native or observable Map.\n */ function isPlainES6Map(thing) {\n    var mapProto = Object.getPrototypeOf(thing);\n    var objectProto = Object.getPrototypeOf(mapProto);\n    var nullProto = Object.getPrototypeOf(objectProto);\n    return nullProto === null;\n}\n/**\n * Yields true for both native and observable Set, even across different windows.\n */ function isES6Set(thing) {\n    return thing != null && Object.prototype.toString.call(thing) === \"[object Set]\";\n}\nvar hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== \"undefined\";\n/**\n * Returns the following: own enumerable keys and symbols.\n */ function getPlainObjectKeys(object) {\n    var keys = Object.keys(object);\n    // Not supported in IE, so there are not going to be symbol props anyway...\n    if (!hasGetOwnPropertySymbols) {\n        return keys;\n    }\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (!symbols.length) {\n        return keys;\n    }\n    return [].concat(keys, symbols.filter(function(s) {\n        return objectPrototype.propertyIsEnumerable.call(object, s);\n    }));\n}\n// From Immer utils\n// Returns all own keys, including non-enumerable and symbolic\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nfunction stringifyKey(key) {\n    if (typeof key === \"string\") {\n        return key;\n    }\n    if (typeof key === \"symbol\") {\n        return key.toString();\n    }\n    return new String(key).toString();\n}\nfunction toPrimitive(value) {\n    return value === null ? null : typeof value === \"object\" ? \"\" + value : value;\n}\nfunction hasProp(target, prop) {\n    return objectPrototype.hasOwnProperty.call(target, prop);\n}\n// From Immer utils\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    // Note: without polyfill for ownKeys, symbols won't be picked up\n    ownKeys(target).forEach(function(key) {\n        res[key] = getDescriptor(target, key);\n    });\n    return res;\n};\nfunction getFlag(flags, mask) {\n    return !!(flags & mask);\n}\nfunction setFlag(flags, mask, newValue) {\n    if (newValue) {\n        flags |= mask;\n    } else {\n        flags &= ~mask;\n    }\n    return flags;\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _createForOfIteratorHelperLoose(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (t) return (t = t.call(r)).next.bind(t);\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n        t && (r = t);\n        var o = 0;\n        return function() {\n            return o >= r.length ? {\n                done: !0\n            } : {\n                done: !1,\n                value: r[o++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, _extends.apply(null, arguments);\n}\nfunction _inheritsLoose(t, o) {\n    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);\n}\nfunction _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n        return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nvar storedAnnotationsSymbol = /*#__PURE__*/ Symbol(\"mobx-stored-annotations\");\n/**\n * Creates a function that acts as\n * - decorator\n * - annotation object\n */ function createDecoratorAnnotation(annotation) {\n    function decorator(target, property) {\n        if (is20223Decorator(property)) {\n            return annotation.decorate_20223_(target, property);\n        } else {\n            storeAnnotation(target, property, annotation);\n        }\n    }\n    return Object.assign(decorator, annotation);\n}\n/**\n * Stores annotation to prototype,\n * so it can be inspected later by `makeObservable` called from constructor\n */ function storeAnnotation(prototype, key, annotation) {\n    if (!hasProp(prototype, storedAnnotationsSymbol)) {\n        addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));\n    }\n    // @override must override something\n    if ( true && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        die(\"'\" + fieldName + \"' is decorated with 'override', \" + \"but no such decorated member was found on prototype.\");\n    }\n    // Cannot re-decorate\n    assertNotDecorated(prototype, annotation, key);\n    // Ignore override\n    if (!isOverride(annotation)) {\n        prototype[storedAnnotationsSymbol][key] = annotation;\n    }\n}\nfunction assertNotDecorated(prototype, annotation, key) {\n    if ( true && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '@\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already decorated with '@\" + currentAnnotationType + \"'.\") + \"\\nRe-decorating fields is not allowed.\" + \"\\nUse '@override' decorator for methods overridden by subclass.\");\n    }\n}\n/**\n * Collects annotations from prototypes and stores them on target (instance)\n */ function collectStoredAnnotations(target) {\n    if (!hasProp(target, storedAnnotationsSymbol)) {\n        // if (__DEV__ && !target[storedAnnotationsSymbol]) {\n        //     die(\n        //         `No annotations were passed to makeObservable, but no decorated members have been found either`\n        //     )\n        // }\n        // We need a copy as we will remove annotation from the list once it's applied.\n        addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));\n    }\n    return target[storedAnnotationsSymbol];\n}\nfunction is20223Decorator(context) {\n    return typeof context == \"object\" && typeof context[\"kind\"] == \"string\";\n}\nfunction assert20223DecoratorType(context, types) {\n    if ( true && !types.includes(context.kind)) {\n        die(\"The decorator applied to '\" + String(context.name) + \"' cannot be used on a \" + context.kind + \" element\");\n    }\n}\nvar $mobx = /*#__PURE__*/ Symbol(\"mobx administration\");\nvar Atom = /*#__PURE__*/ function() {\n    /**\n   * Create a new atom. For debugging purposes it is recommended to give it a name.\n   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\n   */ function Atom(name_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Atom@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this.flags_ = 0;\n        this.observers_ = new Set();\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\n        // onBecomeObservedListeners\n        this.onBOL = void 0;\n        // onBecomeUnobservedListeners\n        this.onBUOL = void 0;\n        this.name_ = name_;\n    }\n    // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed\n    var _proto = Atom.prototype;\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    } /**\n   * Invoke this method to notify mobx that your atom has been used somehow.\n   * Returns true if there is currently a reactive context.\n   */ ;\n    _proto.reportObserved = function reportObserved$1() {\n        return reportObserved(this);\n    } /**\n   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\n   */ ;\n    _proto.reportChanged = function reportChanged() {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    _proto.toString = function toString() {\n        return this.name_;\n    };\n    return _createClass(Atom, [\n        {\n            key: \"isBeingObserved\",\n            get: function get() {\n                return getFlag(this.flags_, Atom.isBeingObservedMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Atom.isBeingObservedMask_, newValue);\n            }\n        },\n        {\n            key: \"isPendingUnobservation\",\n            get: function get() {\n                return getFlag(this.flags_, Atom.isPendingUnobservationMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Atom.isPendingUnobservationMask_, newValue);\n            }\n        },\n        {\n            key: \"diffValue\",\n            get: function get() {\n                return getFlag(this.flags_, Atom.diffValueMask_) ? 1 : 0;\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Atom.diffValueMask_, newValue === 1 ? true : false);\n            }\n        }\n    ]);\n}();\nAtom.isBeingObservedMask_ = 1;\nAtom.isPendingUnobservationMask_ = 2;\nAtom.diffValueMask_ = 4;\nvar isAtom = /*#__PURE__*/ createInstanceofPredicate(\"Atom\", Atom);\nfunction createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n    if (onBecomeObservedHandler === void 0) {\n        onBecomeObservedHandler = noop;\n    }\n    if (onBecomeUnobservedHandler === void 0) {\n        onBecomeUnobservedHandler = noop;\n    }\n    var atom = new Atom(name);\n    // default `noop` listener will not initialize the hook Set\n    if (onBecomeObservedHandler !== noop) {\n        onBecomeObserved(atom, onBecomeObservedHandler);\n    }\n    if (onBecomeUnobservedHandler !== noop) {\n        onBecomeUnobserved(atom, onBecomeUnobservedHandler);\n    }\n    return atom;\n}\nfunction identityComparer(a, b) {\n    return a === b;\n}\nfunction structuralComparer(a, b) {\n    return deepEqual(a, b);\n}\nfunction shallowComparer(a, b) {\n    return deepEqual(a, b, 1);\n}\nfunction defaultComparer(a, b) {\n    if (Object.is) {\n        return Object.is(a, b);\n    }\n    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;\n}\nvar comparer = {\n    identity: identityComparer,\n    structural: structuralComparer,\n    \"default\": defaultComparer,\n    shallow: shallowComparer\n};\nfunction deepEnhancer(v, _, name) {\n    // it is an observable already, done\n    if (isObservable(v)) {\n        return v;\n    }\n    // something that can be converted and mutated?\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name\n        });\n    }\n    if (typeof v === \"function\" && !isAction(v) && !isFlow(v)) {\n        if (isGenerator(v)) {\n            return flow(v);\n        } else {\n            return autoAction(name, v);\n        }\n    }\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (v === undefined || v === null) {\n        return v;\n    }\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {\n        return v;\n    }\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (true) {\n        die(\"The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets\");\n    }\n}\nfunction referenceEnhancer(newValue) {\n    // never turn into an observable\n    return newValue;\n}\nfunction refStructEnhancer(v, oldValue) {\n    if ( true && isObservable(v)) {\n        die(\"observable.struct should not be used with observable values\");\n    }\n    if (deepEqual(v, oldValue)) {\n        return oldValue;\n    }\n    return v;\n}\nvar OVERRIDE = \"override\";\nvar override = /*#__PURE__*/ createDecoratorAnnotation({\n    annotationType_: OVERRIDE,\n    make_: make_,\n    extend_: extend_,\n    decorate_20223_: decorate_20223_\n});\nfunction isOverride(annotation) {\n    return annotation.annotationType_ === OVERRIDE;\n}\nfunction make_(adm, key) {\n    // Must not be plain object\n    if ( true && adm.isPlainObject_) {\n        die(\"Cannot apply '\" + this.annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + this.annotationType_ + \"' cannot be used on plain objects.\"));\n    }\n    // Must override something\n    if ( true && !hasProp(adm.appliedAnnotations_, key)) {\n        die(\"'\" + adm.name_ + \".\" + key.toString() + \"' is annotated with '\" + this.annotationType_ + \"', \" + \"but no such annotated member was found on prototype.\");\n    }\n    return 0 /* MakeResult.Cancel */ ;\n}\nfunction extend_(adm, key, descriptor, proxyTrap) {\n    die(\"'\" + this.annotationType_ + \"' can only be used with 'makeObservable'\");\n}\nfunction decorate_20223_(desc, context) {\n    console.warn(\"'\" + this.annotationType_ + \"' cannot be used with decorators - this is a no-op\");\n}\nfunction createActionAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$1,\n        extend_: extend_$1,\n        decorate_20223_: decorate_20223_$1\n    };\n}\nfunction make_$1(adm, key, descriptor, source) {\n    var _this$options_;\n    // bound\n    if ((_this$options_ = this.options_) != null && _this$options_.bound) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */  : 1 /* MakeResult.Break */ ;\n    }\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */  : 2 /* MakeResult.Continue */ ;\n    }\n    // prototype\n    if (isAction(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* MakeResult.Break */ ;\n    }\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);\n    defineProperty(source, key, actionDescriptor);\n    return 2 /* MakeResult.Continue */ ;\n}\nfunction extend_$1(adm, key, descriptor, proxyTrap) {\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);\n    return adm.defineProperty_(key, actionDescriptor, proxyTrap);\n}\nfunction decorate_20223_$1(mthd, context) {\n    if (true) {\n        assert20223DecoratorType(context, [\n            \"method\",\n            \"field\"\n        ]);\n    }\n    var kind = context.kind, name = context.name, addInitializer = context.addInitializer;\n    var ann = this;\n    var _createAction = function _createAction(m) {\n        var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;\n        return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);\n    };\n    if (kind == \"field\") {\n        return function(initMthd) {\n            var _ann$options_3;\n            var mthd = initMthd;\n            if (!isAction(mthd)) {\n                mthd = _createAction(mthd);\n            }\n            if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {\n                mthd = mthd.bind(this);\n                mthd.isMobxAction = true;\n            }\n            return mthd;\n        };\n    }\n    if (kind == \"method\") {\n        var _this$options_2;\n        if (!isAction(mthd)) {\n            mthd = _createAction(mthd);\n        }\n        if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {\n            addInitializer(function() {\n                var self1 = this;\n                var bound = self1[name].bind(self1);\n                bound.isMobxAction = true;\n                self1[name] = bound;\n            });\n        }\n        return mthd;\n    }\n    die(\"Cannot apply '\" + ann.annotationType_ + \"' to '\" + String(name) + \"' (kind: \" + kind + \"):\" + (\"\\n'\" + ann.annotationType_ + \"' can only be used on properties with a function value.\"));\n}\nfunction assertActionDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a function value.\"));\n    }\n}\nfunction createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertActionDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {\n        var _adm$proxy_;\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return {\n        value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, // https://github.com/mobxjs/mobx/discussions/3140\n        (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createFlowAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$2,\n        extend_: extend_$2,\n        decorate_20223_: decorate_20223_$2\n    };\n}\nfunction make_$2(adm, key, descriptor, source) {\n    var _this$options_;\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */  : 2 /* MakeResult.Continue */ ;\n    }\n    // prototype\n    // bound - must annotate protos to support super.flow()\n    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {\n        if (this.extend_(adm, key, descriptor, false) === null) {\n            return 0 /* MakeResult.Cancel */ ;\n        }\n    }\n    if (isFlow(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* MakeResult.Break */ ;\n    }\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);\n    defineProperty(source, key, flowDescriptor);\n    return 2 /* MakeResult.Continue */ ;\n}\nfunction extend_$2(adm, key, descriptor, proxyTrap) {\n    var _this$options_2;\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);\n    return adm.defineProperty_(key, flowDescriptor, proxyTrap);\n}\nfunction decorate_20223_$2(mthd, context) {\n    var _this$options_3;\n    if (true) {\n        assert20223DecoratorType(context, [\n            \"method\"\n        ]);\n    }\n    var name = context.name, addInitializer = context.addInitializer;\n    if (!isFlow(mthd)) {\n        mthd = flow(mthd);\n    }\n    if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {\n        addInitializer(function() {\n            var self1 = this;\n            var bound = self1[name].bind(self1);\n            bound.isMobXFlow = true;\n            self1[name] = bound;\n        });\n    }\n    return mthd;\n}\nfunction assertFlowDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a generator function value.\"));\n    }\n}\nfunction createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertFlowDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    // In case of flow.bound, the descriptor can be from already annotated prototype\n    if (!isFlow(value)) {\n        value = flow(value);\n    }\n    if (bound) {\n        var _adm$proxy_;\n        // We do not keep original function around, so we bind the existing flow\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n        // This is normally set by `flow`, but `bind` returns new function...\n        value.isMobXFlow = true;\n    }\n    return {\n        value: value,\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createComputedAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$3,\n        extend_: extend_$3,\n        decorate_20223_: decorate_20223_$3\n    };\n}\nfunction make_$3(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */  : 1 /* MakeResult.Break */ ;\n}\nfunction extend_$3(adm, key, descriptor, proxyTrap) {\n    assertComputedDescriptor(adm, this, key, descriptor);\n    return adm.defineComputedProperty_(key, _extends({}, this.options_, {\n        get: descriptor.get,\n        set: descriptor.set\n    }), proxyTrap);\n}\nfunction decorate_20223_$3(get, context) {\n    if (true) {\n        assert20223DecoratorType(context, [\n            \"getter\"\n        ]);\n    }\n    var ann = this;\n    var key = context.name, addInitializer = context.addInitializer;\n    addInitializer(function() {\n        var adm = asObservableObject(this)[$mobx];\n        var options = _extends({}, ann.options_, {\n            get: get,\n            context: this\n        });\n        options.name || (options.name =  true ? adm.name_ + \".\" + key.toString() : 0);\n        adm.values_.set(key, new ComputedValue(options));\n    });\n    return function() {\n        return this[$mobx].getObservablePropValue_(key);\n    };\n}\nfunction assertComputedDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var get = _ref2.get;\n    if ( true && !get) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on getter(+setter) properties.\"));\n    }\n}\nfunction createObservableAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$4,\n        extend_: extend_$4,\n        decorate_20223_: decorate_20223_$4\n    };\n}\nfunction make_$4(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */  : 1 /* MakeResult.Break */ ;\n}\nfunction extend_$4(adm, key, descriptor, proxyTrap) {\n    var _this$options_$enhanc, _this$options_;\n    assertObservableDescriptor(adm, this, key, descriptor);\n    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);\n}\nfunction decorate_20223_$4(desc, context) {\n    if (true) {\n        if (context.kind === \"field\") {\n            throw die(\"Please use `@observable accessor \" + String(context.name) + \"` instead of `@observable \" + String(context.name) + \"`\");\n        }\n        assert20223DecoratorType(context, [\n            \"accessor\"\n        ]);\n    }\n    var ann = this;\n    var kind = context.kind, name = context.name;\n    // The laziness here is not ideal... It's a workaround to how 2022.3 Decorators are implemented:\n    //   `addInitializer` callbacks are executed _before_ any accessors are defined (instead of the ideal-for-us right after each).\n    //   This means that, if we were to do our stuff in an `addInitializer`, we'd attempt to read a private slot\n    //   before it has been initialized. The runtime doesn't like that and throws a `Cannot read private member\n    //   from an object whose class did not declare it` error.\n    // TODO: it seems that this will not be required anymore in the final version of the spec\n    // See TODO: link\n    var initializedObjects = new WeakSet();\n    function initializeObservable(target, value) {\n        var _ann$options_$enhance, _ann$options_;\n        var adm = asObservableObject(target)[$mobx];\n        var observable = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer,  true ? adm.name_ + \".\" + name.toString() : 0, false);\n        adm.values_.set(name, observable);\n        initializedObjects.add(target);\n    }\n    if (kind == \"accessor\") {\n        return {\n            get: function get() {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, desc.get.call(this));\n                }\n                return this[$mobx].getObservablePropValue_(name);\n            },\n            set: function set(value) {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, value);\n                }\n                return this[$mobx].setObservablePropValue_(name, value);\n            },\n            init: function init(value) {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, value);\n                }\n                return value;\n            }\n        };\n    }\n    return;\n}\nfunction assertObservableDescriptor(adm, _ref, key, descriptor) {\n    var annotationType_ = _ref.annotationType_;\n    if ( true && !(\"value\" in descriptor)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' cannot be used on getter/setter properties\"));\n    }\n}\nvar AUTO = \"true\";\nvar autoAnnotation = /*#__PURE__*/ createAutoAnnotation();\nfunction createAutoAnnotation(options) {\n    return {\n        annotationType_: AUTO,\n        options_: options,\n        make_: make_$5,\n        extend_: extend_$5,\n        decorate_20223_: decorate_20223_$5\n    };\n}\nfunction make_$5(adm, key, descriptor, source) {\n    var _this$options_3, _this$options_4;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.make_(adm, key, descriptor, source);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.make_\n        var set = createAction(key.toString(), descriptor.set);\n        // own\n        if (source === adm.target_) {\n            return adm.defineProperty_(key, {\n                configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n                set: set\n            }) === null ? 0 /* MakeResult.Cancel */  : 2 /* MakeResult.Continue */ ;\n        }\n        // proto\n        defineProperty(source, key, {\n            configurable: true,\n            set: set\n        });\n        return 2 /* MakeResult.Continue */ ;\n    }\n    // function on proto -> autoAction/flow\n    if (source !== adm.target_ && typeof descriptor.value === \"function\") {\n        var _this$options_2;\n        if (isGenerator(descriptor.value)) {\n            var _this$options_;\n            var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;\n            return flowAnnotation.make_(adm, key, descriptor, source);\n        }\n        var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;\n        return actionAnnotation.make_(adm, key, descriptor, source);\n    }\n    // other -> observable\n    // Copy props from proto as well, see test:\n    // \"decorate should work with Object.create\"\n    var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {\n        var _adm$proxy_;\n        descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return observableAnnotation.make_(adm, key, descriptor, source);\n}\nfunction extend_$5(adm, key, descriptor, proxyTrap) {\n    var _this$options_5, _this$options_6;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.extend_(adm, key, descriptor, proxyTrap);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.extend_\n        return adm.defineProperty_(key, {\n            configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n            set: createAction(key.toString(), descriptor.set)\n        }, proxyTrap);\n    }\n    // other -> observable\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {\n        var _adm$proxy_2;\n        descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);\n    }\n    var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;\n    return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);\n}\nfunction decorate_20223_$5(desc, context) {\n    die(\"'\" + this.annotationType_ + \"' cannot be used as a decorator\");\n}\nvar OBSERVABLE = \"observable\";\nvar OBSERVABLE_REF = \"observable.ref\";\nvar OBSERVABLE_SHALLOW = \"observable.shallow\";\nvar OBSERVABLE_STRUCT = \"observable.struct\";\n// Predefined bags of create observable options, to avoid allocating temporarily option objects\n// in the majority of cases\nvar defaultCreateObservableOptions = {\n    deep: true,\n    name: undefined,\n    defaultDecorator: undefined,\n    proxy: true\n};\nObject.freeze(defaultCreateObservableOptions);\nfunction asCreateObservableOptions(thing) {\n    return thing || defaultCreateObservableOptions;\n}\nvar observableAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE);\nvar observableRefAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_REF, {\n    enhancer: referenceEnhancer\n});\nvar observableShallowAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_SHALLOW, {\n    enhancer: shallowEnhancer\n});\nvar observableStructAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_STRUCT, {\n    enhancer: refStructEnhancer\n});\nvar observableDecoratorAnnotation = /*#__PURE__*/ createDecoratorAnnotation(observableAnnotation);\nfunction getEnhancerFromOptions(options) {\n    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);\n}\nfunction getAnnotationFromOptions(options) {\n    var _options$defaultDecor;\n    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;\n}\nfunction getEnhancerFromAnnotation(annotation) {\n    var _annotation$options_$, _annotation$options_;\n    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;\n}\n/**\n * Turns an object, array or function into a reactive structure.\n * @param v the value which should become observable.\n */ function createObservable(v, arg2, arg3) {\n    // @observable someProp; (2022.3 Decorators)\n    if (is20223Decorator(arg2)) {\n        return observableAnnotation.decorate_20223_(v, arg2);\n    }\n    // @observable someProp;\n    if (isStringish(arg2)) {\n        storeAnnotation(v, arg2, observableAnnotation);\n        return;\n    }\n    // already observable - ignore\n    if (isObservable(v)) {\n        return v;\n    }\n    // plain object\n    if (isPlainObject(v)) {\n        return observable.object(v, arg2, arg3);\n    }\n    // Array\n    if (Array.isArray(v)) {\n        return observable.array(v, arg2);\n    }\n    // Map\n    if (isES6Map(v)) {\n        return observable.map(v, arg2);\n    }\n    // Set\n    if (isES6Set(v)) {\n        return observable.set(v, arg2);\n    }\n    // other object - ignore\n    if (typeof v === \"object\" && v !== null) {\n        return v;\n    }\n    // anything else\n    return observable.box(v, arg2);\n}\nassign(createObservable, observableDecoratorAnnotation);\nvar observableFactories = {\n    box: function box(value, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);\n    },\n    array: function array(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    map: function map(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    set: function set(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    object: function object(props, decorators, options) {\n        return initObservable(function() {\n            return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);\n        });\n    },\n    ref: /*#__PURE__*/ createDecoratorAnnotation(observableRefAnnotation),\n    shallow: /*#__PURE__*/ createDecoratorAnnotation(observableShallowAnnotation),\n    deep: observableDecoratorAnnotation,\n    struct: /*#__PURE__*/ createDecoratorAnnotation(observableStructAnnotation)\n};\n// eslint-disable-next-line\nvar observable = /*#__PURE__*/ assign(createObservable, observableFactories);\nvar COMPUTED = \"computed\";\nvar COMPUTED_STRUCT = \"computed.struct\";\nvar computedAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED);\nvar computedStructAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED_STRUCT, {\n    equals: comparer.structural\n});\n/**\n * Decorator for class properties: @computed get value() { return expr; }.\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\n */ var computed = function computed(arg1, arg2) {\n    if (is20223Decorator(arg2)) {\n        // @computed (2022.3 Decorators)\n        return computedAnnotation.decorate_20223_(arg1, arg2);\n    }\n    if (isStringish(arg2)) {\n        // @computed\n        return storeAnnotation(arg1, arg2, computedAnnotation);\n    }\n    if (isPlainObject(arg1)) {\n        // @computed({ options })\n        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\n    }\n    // computed(expr, options?)\n    if (true) {\n        if (!isFunction(arg1)) {\n            die(\"First argument to `computed` should be an expression.\");\n        }\n        if (isFunction(arg2)) {\n            die(\"A setter as second argument is no longer supported, use `{ set: fn }` option instead\");\n        }\n    }\n    var opts = isPlainObject(arg2) ? arg2 : {};\n    opts.get = arg1;\n    opts.name || (opts.name = arg1.name || \"\"); /* for generated name */ \n    return new ComputedValue(opts);\n};\nObject.assign(computed, computedAnnotation);\ncomputed.struct = /*#__PURE__*/ createDecoratorAnnotation(computedStructAnnotation);\nvar _getDescriptor$config, _getDescriptor;\n// we don't use globalState for these in order to avoid possible issues with multiple\n// mobx versions\nvar currentActionId = 0;\nvar nextActionId = 1;\nvar isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/ getDescriptor(function() {}, \"name\")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;\n// we can safely recycle this object\nvar tmpNameDescriptor = {\n    value: \"action\",\n    configurable: true,\n    writable: false,\n    enumerable: false\n};\nfunction createAction(actionName, fn, autoAction, ref) {\n    if (autoAction === void 0) {\n        autoAction = false;\n    }\n    if (true) {\n        if (!isFunction(fn)) {\n            die(\"`action` can only be invoked on functions\");\n        }\n        if (typeof actionName !== \"string\" || !actionName) {\n            die(\"actions should have valid names, got: '\" + actionName + \"'\");\n        }\n    }\n    function res() {\n        return executeAction(actionName, autoAction, fn, ref || this, arguments);\n    }\n    res.isMobxAction = true;\n    res.toString = function() {\n        return fn.toString();\n    };\n    if (isFunctionNameConfigurable) {\n        tmpNameDescriptor.value = actionName;\n        defineProperty(res, \"name\", tmpNameDescriptor);\n    }\n    return res;\n}\nfunction executeAction(actionName, canRunAsDerivation, fn, scope, args) {\n    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } catch (err) {\n        runInfo.error_ = err;\n        throw err;\n    } finally{\n        _endAction(runInfo);\n    }\n}\nfunction _startAction(actionName, canRunAsDerivation, // true for autoAction\nscope, args) {\n    var notifySpy_ =  true && isSpyEnabled() && !!actionName;\n    var startTime_ = 0;\n    if ( true && notifySpy_) {\n        startTime_ = Date.now();\n        var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;\n        spyReportStart({\n            type: ACTION,\n            name: actionName,\n            object: scope,\n            arguments: flattenedArgs\n        });\n    }\n    var prevDerivation_ = globalState.trackingDerivation;\n    var runAsAction = !canRunAsDerivation || !prevDerivation_;\n    startBatch();\n    var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow\n    if (runAsAction) {\n        untrackedStart();\n        prevAllowStateChanges_ = allowStateChangesStart(true);\n    }\n    var prevAllowStateReads_ = allowStateReadsStart(true);\n    var runInfo = {\n        runAsAction_: runAsAction,\n        prevDerivation_: prevDerivation_,\n        prevAllowStateChanges_: prevAllowStateChanges_,\n        prevAllowStateReads_: prevAllowStateReads_,\n        notifySpy_: notifySpy_,\n        startTime_: startTime_,\n        actionId_: nextActionId++,\n        parentActionId_: currentActionId\n    };\n    currentActionId = runInfo.actionId_;\n    return runInfo;\n}\nfunction _endAction(runInfo) {\n    if (currentActionId !== runInfo.actionId_) {\n        die(30);\n    }\n    currentActionId = runInfo.parentActionId_;\n    if (runInfo.error_ !== undefined) {\n        globalState.suppressReactionErrors = true;\n    }\n    allowStateChangesEnd(runInfo.prevAllowStateChanges_);\n    allowStateReadsEnd(runInfo.prevAllowStateReads_);\n    endBatch();\n    if (runInfo.runAsAction_) {\n        untrackedEnd(runInfo.prevDerivation_);\n    }\n    if ( true && runInfo.notifySpy_) {\n        spyReportEnd({\n            time: Date.now() - runInfo.startTime_\n        });\n    }\n    globalState.suppressReactionErrors = false;\n}\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    try {\n        return func();\n    } finally{\n        allowStateChangesEnd(prev);\n    }\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar CREATE = \"create\";\nvar ObservableValue = /*#__PURE__*/ function(_Atom) {\n    function ObservableValue(value, enhancer, name_, notifySpy, equals) {\n        var _this;\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableValue@\" + getNextId() : 0;\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        if (equals === void 0) {\n            equals = comparer[\"default\"];\n        }\n        _this = _Atom.call(this, name_) || this;\n        _this.enhancer = void 0;\n        _this.name_ = void 0;\n        _this.equals = void 0;\n        _this.hasUnreportedChange_ = false;\n        _this.interceptors_ = void 0;\n        _this.changeListeners_ = void 0;\n        _this.value_ = void 0;\n        _this.dehancer = void 0;\n        _this.enhancer = enhancer;\n        _this.name_ = name_;\n        _this.equals = equals;\n        _this.value_ = enhancer(value, undefined, name_);\n        if ( true && notifySpy && isSpyEnabled()) {\n            // only notify spy if this is a stand-alone observable\n            spyReport({\n                type: CREATE,\n                object: _this,\n                observableKind: \"value\",\n                debugObjectName: _this.name_,\n                newValue: \"\" + _this.value_\n            });\n        }\n        return _this;\n    }\n    _inheritsLoose(ObservableValue, _Atom);\n    var _proto = ObservableValue.prototype;\n    _proto.dehanceValue = function dehanceValue(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.set = function set(newValue) {\n        var oldValue = this.value_;\n        newValue = this.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if ( true && notifySpy) {\n                spyReportStart({\n                    type: UPDATE,\n                    object: this,\n                    observableKind: \"value\",\n                    debugObjectName: this.name_,\n                    newValue: newValue,\n                    oldValue: oldValue\n                });\n            }\n            this.setNewValue_(newValue);\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this,\n                type: UPDATE,\n                newValue: newValue\n            });\n            if (!change) {\n                return globalState.UNCHANGED;\n            }\n            newValue = change.newValue;\n        }\n        // apply modifier\n        newValue = this.enhancer(newValue, this.value_, this.name_);\n        return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;\n    };\n    _proto.setNewValue_ = function setNewValue_(newValue) {\n        var oldValue = this.value_;\n        this.value_ = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: UPDATE,\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    _proto.get = function get() {\n        this.reportObserved();\n        return this.dehanceValue(this.value_);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately) {\n            listener({\n                observableKind: \"value\",\n                debugObjectName: this.name_,\n                object: this,\n                type: UPDATE,\n                newValue: this.value_,\n                oldValue: undefined\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.raw = function raw() {\n        // used by MST ot get undehanced value\n        return this.value_;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.get();\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.value_ + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[Symbol.toPrimitive] = function() {\n        return this.valueOf();\n    };\n    return ObservableValue;\n}(Atom);\nvar isObservableValue = /*#__PURE__*/ createInstanceofPredicate(\"ObservableValue\", ObservableValue);\n/**\n * A node in the state dependency root that observes other nodes, and can be observed itself.\n *\n * ComputedValue will remember the result of the computation for the duration of the batch, or\n * while being observed.\n *\n * During this time it will recompute only when one of its direct dependencies changed,\n * but only when it is being accessed with `ComputedValue.get()`.\n *\n * Implementation description:\n * 1. First time it's being accessed it will compute and remember result\n *    give back remembered result until 2. happens\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\n * 3. When it's being accessed, recompute if any shallow dependency changed.\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\n *    go to step 2. either way\n *\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\n */ var ComputedValue = /*#__PURE__*/ function() {\n    /**\n   * Create a new computed value based on a function expression.\n   *\n   * The `name` property is for debug purposes only.\n   *\n   * The `equals` property specifies the comparer function to use to determine if a newly produced\n   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\n   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\n   * Structural comparison can be convenient if you always produce a new aggregated object and\n   * don't want to notify observers if it is structurally the same.\n   * This is useful for working with vectors, mouse coordinates etc.\n   */ function ComputedValue(options) {\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.observing_ = [];\n        // nodes we are looking at. Our value depends on these nodes\n        this.newObserving_ = null;\n        // during tracking it's an array with new observed observers\n        this.observers_ = new Set();\n        this.runId_ = 0;\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        this.unboundDepsCount_ = 0;\n        this.value_ = new CaughtException(null);\n        this.name_ = void 0;\n        this.triggeredBy_ = void 0;\n        this.flags_ = 0;\n        this.derivation = void 0;\n        // N.B: unminified as it is used by MST\n        this.setter_ = void 0;\n        this.isTracing_ = TraceMode.NONE;\n        this.scope_ = void 0;\n        this.equals_ = void 0;\n        this.requiresReaction_ = void 0;\n        this.keepAlive_ = void 0;\n        this.onBOL = void 0;\n        this.onBUOL = void 0;\n        if (!options.get) {\n            die(31);\n        }\n        this.derivation = options.get;\n        this.name_ = options.name || ( true ? \"ComputedValue@\" + getNextId() : 0);\n        if (options.set) {\n            this.setter_ = createAction( true ? this.name_ + \"-setter\" : 0, options.set);\n        }\n        this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer[\"default\"]);\n        this.scope_ = options.context;\n        this.requiresReaction_ = options.requiresReaction;\n        this.keepAlive_ = !!options.keepAlive;\n    }\n    var _proto = ComputedValue.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        propagateMaybeChanged(this);\n    };\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    };\n    /**\n   * Returns the current value of this computed value.\n   * Will evaluate its computation first if needed.\n   */ _proto.get = function get() {\n        if (this.isComputing) {\n            die(32, this.name_, this.derivation);\n        }\n        if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&\n        this.observers_.size === 0 && !this.keepAlive_) {\n            if (shouldCompute(this)) {\n                this.warnAboutUntrackedRead_();\n                startBatch(); // See perf test 'computed memoization'\n                this.value_ = this.computeValue_(false);\n                endBatch();\n            }\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) {\n                var prevTrackingContext = globalState.trackingContext;\n                if (this.keepAlive_ && !prevTrackingContext) {\n                    globalState.trackingContext = this;\n                }\n                if (this.trackAndCompute()) {\n                    propagateChangeConfirmed(this);\n                }\n                globalState.trackingContext = prevTrackingContext;\n            }\n        }\n        var result = this.value_;\n        if (isCaughtException(result)) {\n            throw result.cause;\n        }\n        return result;\n    };\n    _proto.set = function set(value) {\n        if (this.setter_) {\n            if (this.isRunningSetter) {\n                die(33, this.name_);\n            }\n            this.isRunningSetter = true;\n            try {\n                this.setter_.call(this.scope_, value);\n            } finally{\n                this.isRunningSetter = false;\n            }\n        } else {\n            die(34, this.name_);\n        }\n    };\n    _proto.trackAndCompute = function trackAndCompute() {\n        // N.B: unminified as it is used by MST\n        var oldValue = this.value_;\n        var wasSuspended = /* see #1208 */ this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\n        var newValue = this.computeValue_(true);\n        var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);\n        if (changed) {\n            this.value_ = newValue;\n            if ( true && isSpyEnabled()) {\n                spyReport({\n                    observableKind: \"computed\",\n                    debugObjectName: this.name_,\n                    object: this.scope_,\n                    type: \"update\",\n                    oldValue: oldValue,\n                    newValue: newValue\n                });\n            }\n        }\n        return changed;\n    };\n    _proto.computeValue_ = function computeValue_(track) {\n        this.isComputing = true;\n        // don't allow state changes during computation\n        var prev = allowStateChangesStart(false);\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope_);\n        } else {\n            if (globalState.disableErrorBoundaries === true) {\n                res = this.derivation.call(this.scope_);\n            } else {\n                try {\n                    res = this.derivation.call(this.scope_);\n                } catch (e) {\n                    res = new CaughtException(e);\n                }\n            }\n        }\n        allowStateChangesEnd(prev);\n        this.isComputing = false;\n        return res;\n    };\n    _proto.suspend_ = function suspend_() {\n        if (!this.keepAlive_) {\n            clearObserving(this);\n            this.value_ = undefined; // don't hold on to computed value!\n            if ( true && this.isTracing_ !== TraceMode.NONE) {\n                console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' was suspended and it will recompute on the next access.\");\n            }\n        }\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function() {\n            // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    observableKind: \"computed\",\n                    debugObjectName: _this.name_,\n                    type: UPDATE,\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {\n        if (false) {}\n        if (this.isTracing_ !== TraceMode.NONE) {\n            console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n        if (typeof this.requiresReaction_ === \"boolean\" ? this.requiresReaction_ : globalState.computedRequiresReaction) {\n            console.warn(\"[mobx] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.derivation.toString() + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[Symbol.toPrimitive] = function() {\n        return this.valueOf();\n    };\n    return _createClass(ComputedValue, [\n        {\n            key: \"isComputing\",\n            get: function get() {\n                return getFlag(this.flags_, ComputedValue.isComputingMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, ComputedValue.isComputingMask_, newValue);\n            }\n        },\n        {\n            key: \"isRunningSetter\",\n            get: function get() {\n                return getFlag(this.flags_, ComputedValue.isRunningSetterMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, ComputedValue.isRunningSetterMask_, newValue);\n            }\n        },\n        {\n            key: \"isBeingObserved\",\n            get: function get() {\n                return getFlag(this.flags_, ComputedValue.isBeingObservedMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, ComputedValue.isBeingObservedMask_, newValue);\n            }\n        },\n        {\n            key: \"isPendingUnobservation\",\n            get: function get() {\n                return getFlag(this.flags_, ComputedValue.isPendingUnobservationMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, ComputedValue.isPendingUnobservationMask_, newValue);\n            }\n        },\n        {\n            key: \"diffValue\",\n            get: function get() {\n                return getFlag(this.flags_, ComputedValue.diffValueMask_) ? 1 : 0;\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, ComputedValue.diffValueMask_, newValue === 1 ? true : false);\n            }\n        }\n    ]);\n}();\nComputedValue.isComputingMask_ = 1;\nComputedValue.isRunningSetterMask_ = 2;\nComputedValue.isBeingObservedMask_ = 4;\nComputedValue.isPendingUnobservationMask_ = 8;\nComputedValue.diffValueMask_ = 16;\nvar isComputedValue = /*#__PURE__*/ createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState_;\n(function(IDerivationState_) {\n    // before being run or (outside batch and not being observed)\n    // at this point derivation is not holding any data about dependency tree\n    IDerivationState_[IDerivationState_[\"NOT_TRACKING_\"] = -1] = \"NOT_TRACKING_\";\n    // no shallow dependency changed since last computation\n    // won't recalculate derivation\n    // this is what makes mobx fast\n    IDerivationState_[IDerivationState_[\"UP_TO_DATE_\"] = 0] = \"UP_TO_DATE_\";\n    // some deep dependency changed, but don't know if shallow dependency changed\n    // will require to check first if UP_TO_DATE or POSSIBLY_STALE\n    // currently only ComputedValue will propagate POSSIBLY_STALE\n    //\n    // having this state is second big optimization:\n    // don't have to recompute on every dependency change, but only when it's needed\n    IDerivationState_[IDerivationState_[\"POSSIBLY_STALE_\"] = 1] = \"POSSIBLY_STALE_\";\n    // A shallow dependency has changed since last computation and the derivation\n    // will need to recompute when it's needed next.\n    IDerivationState_[IDerivationState_[\"STALE_\"] = 2] = \"STALE_\";\n})(IDerivationState_ || (IDerivationState_ = {}));\nvar TraceMode;\n(function(TraceMode) {\n    TraceMode[TraceMode[\"NONE\"] = 0] = \"NONE\";\n    TraceMode[TraceMode[\"LOG\"] = 1] = \"LOG\";\n    TraceMode[TraceMode[\"BREAK\"] = 2] = \"BREAK\";\n})(TraceMode || (TraceMode = {}));\nvar CaughtException = function CaughtException(cause) {\n    this.cause = void 0;\n    this.cause = cause;\n// Empty\n};\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\n/**\n * Finds out whether any dependency of the derivation has actually changed.\n * If dependenciesState is 1 then it will recalculate dependencies,\n * if any dependency changed it will propagate it by changing dependenciesState to 2.\n *\n * By iterating over the dependencies in the same order that they were reported and\n * stopping on the first change, all the recalculations are only called for ComputedValues\n * that will be tracked by derivation. That is because we assume that if the first x\n * dependencies of the derivation doesn't change then the derivation should run the same way\n * up until accessing x-th dependency.\n */ function shouldCompute(derivation) {\n    switch(derivation.dependenciesState_){\n        case IDerivationState_.UP_TO_DATE_:\n            return false;\n        case IDerivationState_.NOT_TRACKING_:\n        case IDerivationState_.STALE_:\n            return true;\n        case IDerivationState_.POSSIBLY_STALE_:\n            {\n                // state propagation can occur outside of action/reactive context #2195\n                var prevAllowStateReads = allowStateReadsStart(true);\n                var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.\n                var obs = derivation.observing_, l = obs.length;\n                for(var i = 0; i < l; i++){\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        if (globalState.disableErrorBoundaries) {\n                            obj.get();\n                        } else {\n                            try {\n                                obj.get();\n                            } catch (e) {\n                                // we are not interested in the value *or* exception at this moment, but if there is one, notify all\n                                untrackedEnd(prevUntracked);\n                                allowStateReadsEnd(prevAllowStateReads);\n                                return true;\n                            }\n                        }\n                        // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.\n                        // and `derivation` is an observer of `obj`\n                        // invariantShouldCompute(derivation)\n                        if (derivation.dependenciesState_ === IDerivationState_.STALE_) {\n                            untrackedEnd(prevUntracked);\n                            allowStateReadsEnd(prevAllowStateReads);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                allowStateReadsEnd(prevAllowStateReads);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null; // filter out actions inside computations\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    if (false) {}\n    var hasObservers = atom.observers_.size > 0;\n    // Should not be possible to change observed state outside strict mode, except during initialization, see #563\n    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === \"always\")) {\n        console.warn(\"[MobX] \" + (globalState.enforceActions ? \"Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: \" : \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: \") + atom.name_);\n    }\n}\nfunction checkIfStateReadsAreAllowed(observable) {\n    if ( true && !globalState.allowStateReads && globalState.observableRequiresReaction) {\n        console.warn(\"[mobx] Observable '\" + observable.name_ + \"' being read outside a reactive context.\");\n    }\n}\n/**\n * Executes the provided function `f` and tracks which observables are being accessed.\n * The tracking information is stored on the `derivation` object and the derivation is registered\n * as observer of any of the accessed observables.\n */ function trackDerivedFunction(derivation, f, context) {\n    var prevAllowStateReads = allowStateReadsStart(true);\n    changeDependenciesStateTo0(derivation);\n    // Preallocate array; will be trimmed by bindDependencies.\n    derivation.newObserving_ = new Array(// Reserve constant space for initial dependencies, dynamic space otherwise.\n    // See https://github.com/mobxjs/mobx/pull/3833\n    derivation.runId_ === 0 ? 100 : derivation.observing_.length);\n    derivation.unboundDepsCount_ = 0;\n    derivation.runId_ = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    globalState.inBatch++;\n    var result;\n    if (globalState.disableErrorBoundaries === true) {\n        result = f.call(context);\n    } else {\n        try {\n            result = f.call(context);\n        } catch (e) {\n            result = new CaughtException(e);\n        }\n    }\n    globalState.inBatch--;\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    warnAboutDerivationWithoutDependencies(derivation);\n    allowStateReadsEnd(prevAllowStateReads);\n    return result;\n}\nfunction warnAboutDerivationWithoutDependencies(derivation) {\n    if (false) {}\n    if (derivation.observing_.length !== 0) {\n        return;\n    }\n    if (typeof derivation.requiresObservable_ === \"boolean\" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {\n        console.warn(\"[mobx] Derivation '\" + derivation.name_ + \"' is created/updated without reading any observable value.\");\n    }\n}\n/**\n * diffs newObserving with observing.\n * update observing to be newObserving with unique observables\n * notify observers that become observed/unobserved\n */ function bindDependencies(derivation) {\n    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\");\n    var prevObserving = derivation.observing_;\n    var observing = derivation.observing_ = derivation.newObserving_;\n    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;\n    // Go through all new observables and check diffValue: (this list can contain duplicates):\n    //   0: first occurrence, change to 1 and keep it\n    //   1: extra occurrence, drop it\n    var i0 = 0, l = derivation.unboundDepsCount_;\n    for(var i = 0; i < l; i++){\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) {\n                observing[i0] = dep;\n            }\n            i0++;\n        }\n        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,\n        // not hitting the condition\n        if (dep.dependenciesState_ > lowestNewObservingDerivationState) {\n            lowestNewObservingDerivationState = dep.dependenciesState_;\n        }\n    }\n    observing.length = i0;\n    derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)\n    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)\n    //   0: it's not in new observables, unobserve it\n    //   1: it keeps being observed, don't want to notify it. change to 0\n    l = prevObserving.length;\n    while(l--){\n        var _dep = prevObserving[l];\n        if (_dep.diffValue === 0) {\n            removeObserver(_dep, derivation);\n        }\n        _dep.diffValue = 0;\n    }\n    // Go through all new observables and check diffValue: (now it should be unique)\n    //   0: it was set to 0 in last loop. don't need to do anything.\n    //   1: it wasn't observed, let's observe it. set back to 0\n    while(i0--){\n        var _dep2 = observing[i0];\n        if (_dep2.diffValue === 1) {\n            _dep2.diffValue = 0;\n            addObserver(_dep2, derivation);\n        }\n    }\n    // Some new observed derivations may become stale during this derivation computation\n    // so they have had no chance to propagate staleness (#916)\n    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {\n        derivation.dependenciesState_ = lowestNewObservingDerivationState;\n        derivation.onBecomeStale_();\n    }\n}\nfunction clearObserving(derivation) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\");\n    var obs = derivation.observing_;\n    derivation.observing_ = [];\n    var i = obs.length;\n    while(i--){\n        removeObserver(obs[i], derivation);\n    }\n    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    try {\n        return action();\n    } finally{\n        untrackedEnd(prev);\n    }\n}\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction allowStateReadsStart(allowStateReads) {\n    var prev = globalState.allowStateReads;\n    globalState.allowStateReads = allowStateReads;\n    return prev;\n}\nfunction allowStateReadsEnd(prev) {\n    globalState.allowStateReads = prev;\n}\n/**\n * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0\n *\n */ function changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;\n    var obs = derivation.observing_;\n    var i = obs.length;\n    while(i--){\n        obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    }\n}\n/**\n * These values will persist if global state is reset\n */ var persistentKeys = [\n    \"mobxGuid\",\n    \"spyListeners\",\n    \"enforceActions\",\n    \"computedRequiresReaction\",\n    \"reactionRequiresObservable\",\n    \"observableRequiresReaction\",\n    \"allowStateReads\",\n    \"disableErrorBoundaries\",\n    \"runId\",\n    \"UNCHANGED\",\n    \"useProxies\"\n];\nvar MobXGlobals = function MobXGlobals() {\n    /**\n   * MobXGlobals version.\n   * MobX compatiblity with other versions loaded in memory as long as this version matches.\n   * It indicates that the global state still stores similar information\n   *\n   * N.B: this version is unrelated to the package version of MobX, and is only the version of the\n   * internal state storage of MobX, and can be the same across many different package versions\n   */ this.version = 6;\n    /**\n   * globally unique token to signal unchanged\n   */ this.UNCHANGED = {};\n    /**\n   * Currently running derivation\n   */ this.trackingDerivation = null;\n    /**\n   * Currently running reaction. This determines if we currently have a reactive context.\n   * (Tracking derivation is also set for temporal tracking of computed values inside actions,\n   * but trackingReaction can only be set by a form of Reaction)\n   */ this.trackingContext = null;\n    /**\n   * Each time a derivation is tracked, it is assigned a unique run-id\n   */ this.runId = 0;\n    /**\n   * 'guid' for general purpose. Will be persisted amongst resets.\n   */ this.mobxGuid = 0;\n    /**\n   * Are we in a batch block? (and how many of them)\n   */ this.inBatch = 0;\n    /**\n   * Observables that don't have observers anymore, and are about to be\n   * suspended, unless somebody else accesses it in the same batch\n   *\n   * @type {IObservable[]}\n   */ this.pendingUnobservations = [];\n    /**\n   * List of scheduled, not yet executed, reactions.\n   */ this.pendingReactions = [];\n    /**\n   * Are we currently processing reactions?\n   */ this.isRunningReactions = false;\n    /**\n   * Is it allowed to change observables at this point?\n   * In general, MobX doesn't allow that when running computations and React.render.\n   * To ensure that those functions stay pure.\n   */ this.allowStateChanges = false;\n    /**\n   * Is it allowed to read observables at this point?\n   * Used to hold the state needed for `observableRequiresReaction`\n   */ this.allowStateReads = true;\n    /**\n   * If strict mode is enabled, state changes are by default not allowed\n   */ this.enforceActions = true;\n    /**\n   * Spy callbacks\n   */ this.spyListeners = [];\n    /**\n   * Globally attached error handlers that react specifically to errors in reactions\n   */ this.globalReactionErrorHandlers = [];\n    /**\n   * Warn if computed values are accessed outside a reactive context\n   */ this.computedRequiresReaction = false;\n    /**\n   * (Experimental)\n   * Warn if you try to create to derivation / reactive context without accessing any observable.\n   */ this.reactionRequiresObservable = false;\n    /**\n   * (Experimental)\n   * Warn if observables are accessed outside a reactive context\n   */ this.observableRequiresReaction = false;\n    /*\n   * Don't catch and rethrow exceptions. This is useful for inspecting the state of\n   * the stack when an exception occurs while debugging.\n   */ this.disableErrorBoundaries = false;\n    /*\n   * If true, we are already handling an exception in an action. Any errors in reactions should be suppressed, as\n   * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836\n   */ this.suppressReactionErrors = false;\n    this.useProxies = true;\n    /*\n   * print warnings about code that would fail if proxies weren't available\n   */ this.verifyProxies = false;\n    /**\n   * False forces all object's descriptors to\n   * writable: true\n   * configurable: true\n   */ this.safeDescriptors = true;\n};\nvar canMergeGlobalState = true;\nvar isolateCalled = false;\nvar globalState = /*#__PURE__*/ function() {\n    var global1 = /*#__PURE__*/ getGlobal();\n    if (global1.__mobxInstanceCount > 0 && !global1.__mobxGlobals) {\n        canMergeGlobalState = false;\n    }\n    if (global1.__mobxGlobals && global1.__mobxGlobals.version !== new MobXGlobals().version) {\n        canMergeGlobalState = false;\n    }\n    if (!canMergeGlobalState) {\n        // Because this is a IIFE we need to let isolateCalled a chance to change\n        // so we run it after the event loop completed at least 1 iteration\n        setTimeout(function() {\n            if (!isolateCalled) {\n                die(35);\n            }\n        }, 1);\n        return new MobXGlobals();\n    } else if (global1.__mobxGlobals) {\n        global1.__mobxInstanceCount += 1;\n        if (!global1.__mobxGlobals.UNCHANGED) {\n            global1.__mobxGlobals.UNCHANGED = {};\n        } // make merge backward compatible\n        return global1.__mobxGlobals;\n    } else {\n        global1.__mobxInstanceCount = 1;\n        return global1.__mobxGlobals = /*#__PURE__*/ new MobXGlobals();\n    }\n}();\nfunction isolateGlobalState() {\n    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {\n        die(36);\n    }\n    isolateCalled = true;\n    if (canMergeGlobalState) {\n        var global1 = getGlobal();\n        if (--global1.__mobxInstanceCount === 0) {\n            global1.__mobxGlobals = undefined;\n        }\n        globalState = new MobXGlobals();\n    }\n}\nfunction getGlobalState() {\n    return globalState;\n}\n/**\n * For testing purposes only; this will break the internal state of existing observables,\n * but can be used to get back at a stable state after throwing errors\n */ function resetGlobalState() {\n    var defaultGlobals = new MobXGlobals();\n    for(var key in defaultGlobals){\n        if (persistentKeys.indexOf(key) === -1) {\n            globalState[key] = defaultGlobals[key];\n        }\n    }\n    globalState.allowStateChanges = !globalState.enforceActions;\n}\nfunction hasObservers(observable) {\n    return observable.observers_ && observable.observers_.size > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers_;\n}\n// function invariantObservers(observable: IObservable) {\n//     const list = observable.observers\n//     const map = observable.observersIndexes\n//     const l = list.length\n//     for (let i = 0; i < l; i++) {\n//         const id = list[i].__mapid\n//         if (i) {\n//             invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\") // for performance\n//         } else {\n//             invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldn't be held in map.\") // for performance\n//         }\n//     }\n//     invariant(\n//         list.length === 0 || Object.keys(map).length === list.length - 1,\n//         \"INTERNAL ERROR there is no junk in map\"\n//     )\n// }\nfunction addObserver(observable, node) {\n    // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\");\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\");\n    // invariantObservers(observable);\n    observable.observers_.add(node);\n    if (observable.lowestObserverState_ > node.dependenciesState_) {\n        observable.lowestObserverState_ = node.dependenciesState_;\n    }\n// invariantObservers(observable);\n// invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didn't add node\");\n}\nfunction removeObserver(observable, node) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\");\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\");\n    // invariantObservers(observable);\n    observable.observers_[\"delete\"](node);\n    if (observable.observers_.size === 0) {\n        // deleting last observer\n        queueForUnobservation(observable);\n    }\n// invariantObservers(observable);\n// invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\");\n}\nfunction queueForUnobservation(observable) {\n    if (observable.isPendingUnobservation === false) {\n        // invariant(observable._observers.length === 0, \"INTERNAL ERROR, should only queue for unobservation unobserved observables\");\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\n/**\n * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.\n * During a batch `onBecomeUnobserved` will be called at most once per observable.\n * Avoids unnecessary recalculations.\n */ function startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        // the batch is actually about to finish, all unobserving should happen here.\n        var list = globalState.pendingUnobservations;\n        for(var i = 0; i < list.length; i++){\n            var observable = list[i];\n            observable.isPendingUnobservation = false;\n            if (observable.observers_.size === 0) {\n                if (observable.isBeingObserved) {\n                    // if this observable had reactive observers, trigger the hooks\n                    observable.isBeingObserved = false;\n                    observable.onBUO();\n                }\n                if (observable instanceof ComputedValue) {\n                    // computed values are automatically teared down when the last observer leaves\n                    // this process happens recursively, this computed might be the last observabe of another, etc..\n                    observable.suspend_();\n                }\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    checkIfStateReadsAreAllowed(observable);\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        /**\n     * Simple optimization, give each derivation run an unique id (runId)\n     * Check if last time this observable was accessed the same runId is used\n     * if this is the case, the relation is already known\n     */ if (derivation.runId_ !== observable.lastAccessedBy_) {\n            observable.lastAccessedBy_ = derivation.runId_;\n            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...\n            derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\n            if (!observable.isBeingObserved && globalState.trackingContext) {\n                observable.isBeingObserved = true;\n                observable.onBO();\n            }\n        }\n        return observable.isBeingObserved;\n    } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\n        queueForUnobservation(observable);\n    }\n    return false;\n}\n// function invariantLOS(observable: IObservable, msg: string) {\n//     // it's expensive so better not run it in produciton. but temporarily helpful for testing\n//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)\n//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`\n//     throw new Error(\n//         \"lowestObserverState is wrong for \" +\n//             msg +\n//             \" because \" +\n//             min +\n//             \" < \" +\n//             observable.lowestObserverState\n//     )\n// }\n/**\n * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly\n * It will propagate changes to observers from previous run\n * It's hard or maybe impossible (with reasonable perf) to get it right with current approach\n * Hopefully self reruning autoruns aren't a feature people should depend on\n * Also most basic use cases should be ok\n */ // Called by Atom when its value changes\nfunction propagateChanged(observable) {\n    // invariantLOS(observable, \"changed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    // Ideally we use for..of here, but the downcompiled version is really slow...\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n            d.onBecomeStale_();\n        }\n        d.dependenciesState_ = IDerivationState_.STALE_;\n    });\n// invariantLOS(observable, \"changed end\");\n}\n// Called by ComputedValue when it recalculate and its value changed\nfunction propagateChangeConfirmed(observable) {\n    // invariantLOS(observable, \"confirmed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {\n            d.dependenciesState_ = IDerivationState_.STALE_;\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n        } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.\n        ) {\n            observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        }\n    });\n// invariantLOS(observable, \"confirmed end\");\n}\n// Used by computed when its dependency changed, but we don't wan't to immediately recompute.\nfunction propagateMaybeChanged(observable) {\n    // invariantLOS(observable, \"maybe start\");\n    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\n            d.onBecomeStale_();\n        }\n    });\n// invariantLOS(observable, \"maybe end\");\n}\nfunction logTraceInfo(derivation, observable) {\n    console.log(\"[mobx.trace] '\" + derivation.name_ + \"' is invalidated due to a change in: '\" + observable.name_ + \"'\");\n    if (derivation.isTracing_ === TraceMode.BREAK) {\n        var lines = [];\n        printDepTree(getDependencyTree(derivation), lines, 1);\n        // prettier-ignore\n        new Function(\"debugger;\\n/*\\nTracing '\" + derivation.name_ + \"'\\n\\nYou are entering this break point because derivation '\" + derivation.name_ + \"' is being traced and '\" + observable.name_ + \"' is now forcing it to update.\\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\\n\\n\" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\\//g, \"/\") : \"\") + \"\\n\\nThe dependencies for this derivation are:\\n\\n\" + lines.join(\"\\n\") + \"\\n*/\\n    \")();\n    }\n}\nfunction printDepTree(tree, lines, depth) {\n    if (lines.length >= 1000) {\n        lines.push(\"(and many more)\");\n        return;\n    }\n    lines.push(\"\" + \"\t\".repeat(depth - 1) + tree.name);\n    if (tree.dependencies) {\n        tree.dependencies.forEach(function(child) {\n            return printDepTree(child, lines, depth + 1);\n        });\n    }\n}\nvar Reaction = /*#__PURE__*/ function() {\n    function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Reaction@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this.onInvalidate_ = void 0;\n        this.errorHandler_ = void 0;\n        this.requiresObservable_ = void 0;\n        this.observing_ = [];\n        // nodes we are looking at. Our value depends on these nodes\n        this.newObserving_ = [];\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.runId_ = 0;\n        this.unboundDepsCount_ = 0;\n        this.flags_ = 0;\n        this.isTracing_ = TraceMode.NONE;\n        this.name_ = name_;\n        this.onInvalidate_ = onInvalidate_;\n        this.errorHandler_ = errorHandler_;\n        this.requiresObservable_ = requiresObservable_;\n    }\n    var _proto = Reaction.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        this.schedule_();\n    };\n    _proto.schedule_ = function schedule_() {\n        if (!this.isScheduled) {\n            this.isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    } /**\n   * internal, use schedule() if you intend to kick off a reaction\n   */ ;\n    _proto.runReaction_ = function runReaction_() {\n        if (!this.isDisposed) {\n            startBatch();\n            this.isScheduled = false;\n            var prev = globalState.trackingContext;\n            globalState.trackingContext = this;\n            if (shouldCompute(this)) {\n                this.isTrackPending = true;\n                try {\n                    this.onInvalidate_();\n                    if ( true && this.isTrackPending && isSpyEnabled()) {\n                        // onInvalidate didn't trigger track right away..\n                        spyReport({\n                            name: this.name_,\n                            type: \"scheduled-reaction\"\n                        });\n                    }\n                } catch (e) {\n                    this.reportExceptionInDerivation_(e);\n                }\n            }\n            globalState.trackingContext = prev;\n            endBatch();\n        }\n    };\n    _proto.track = function track(fn) {\n        if (this.isDisposed) {\n            return;\n        // console.warn(\"Reaction already disposed\") // Note: Not a warning / error in mobx 4 either\n        }\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if ( true && notify) {\n            startTime = Date.now();\n            spyReportStart({\n                name: this.name_,\n                type: \"reaction\"\n            });\n        }\n        this.isRunning = true;\n        var prevReaction = globalState.trackingContext; // reactions could create reactions...\n        globalState.trackingContext = this;\n        var result = trackDerivedFunction(this, fn, undefined);\n        globalState.trackingContext = prevReaction;\n        this.isRunning = false;\n        this.isTrackPending = false;\n        if (this.isDisposed) {\n            // disposed during last run. Clean up everything that was bound after the dispose call.\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) {\n            this.reportExceptionInDerivation_(result.cause);\n        }\n        if ( true && notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {\n        var _this = this;\n        if (this.errorHandler_) {\n            this.errorHandler_(error, this);\n            return;\n        }\n        if (globalState.disableErrorBoundaries) {\n            throw error;\n        }\n        var message =  true ? \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this + \"'\" : 0;\n        if (!globalState.suppressReactionErrors) {\n            console.error(message, error);\n        /** If debugging brought you here, please, read the above message :-). Tnx! */ } else if (true) {\n            console.warn(\"[mobx] (error in reaction '\" + this.name_ + \"' suppressed, fix error of causing action below)\");\n        } // prettier-ignore\n        if ( true && isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                name: this.name_,\n                message: message,\n                error: \"\" + error\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function(f) {\n            return f(error, _this);\n        });\n    };\n    _proto.dispose = function dispose() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this.isRunning) {\n                // if disposed while running, clean up later. Maybe not optimal, but rare case\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    _proto.getDisposer_ = function getDisposer_(abortSignal) {\n        var _this2 = this;\n        var dispose = function dispose() {\n            _this2.dispose();\n            abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener(\"abort\", dispose);\n        };\n        abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener(\"abort\", dispose);\n        dispose[$mobx] = this;\n        return dispose;\n    };\n    _proto.toString = function toString() {\n        return \"Reaction[\" + this.name_ + \"]\";\n    };\n    _proto.trace = function trace$1(enterBreakPoint) {\n        if (enterBreakPoint === void 0) {\n            enterBreakPoint = false;\n        }\n        trace(this, enterBreakPoint);\n    };\n    return _createClass(Reaction, [\n        {\n            key: \"isDisposed\",\n            get: function get() {\n                return getFlag(this.flags_, Reaction.isDisposedMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Reaction.isDisposedMask_, newValue);\n            }\n        },\n        {\n            key: \"isScheduled\",\n            get: function get() {\n                return getFlag(this.flags_, Reaction.isScheduledMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Reaction.isScheduledMask_, newValue);\n            }\n        },\n        {\n            key: \"isTrackPending\",\n            get: function get() {\n                return getFlag(this.flags_, Reaction.isTrackPendingMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Reaction.isTrackPendingMask_, newValue);\n            }\n        },\n        {\n            key: \"isRunning\",\n            get: function get() {\n                return getFlag(this.flags_, Reaction.isRunningMask_);\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Reaction.isRunningMask_, newValue);\n            }\n        },\n        {\n            key: \"diffValue\",\n            get: function get() {\n                return getFlag(this.flags_, Reaction.diffValueMask_) ? 1 : 0;\n            },\n            set: function set(newValue) {\n                this.flags_ = setFlag(this.flags_, Reaction.diffValueMask_, newValue === 1 ? true : false);\n            }\n        }\n    ]);\n}();\nReaction.isDisposedMask_ = 1;\nReaction.isScheduledMask_ = 2;\nReaction.isTrackPendingMask_ = 4;\nReaction.isRunningMask_ = 8;\nReaction.diffValueMask_ = 16;\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function() {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) {\n            globalState.globalReactionErrorHandlers.splice(idx, 1);\n        }\n    };\n}\n/**\n * Magic number alert!\n * Defines within how many times a reaction is allowed to re-trigger itself\n * until it is assumed that this is gonna be a never ending loop...\n */ var MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    // Trampolining, if runReactions are already running, new reactions will be picked up\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) {\n        return;\n    }\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    // While running reactions, new reactions might be triggered.\n    // Hence we work with two variables and check whether\n    // we converge to no remaining reactions after a while.\n    while(allReactions.length > 0){\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error( true ? \"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]) : 0);\n            allReactions.splice(0); // clear reactions\n        }\n        var remainingReactions = allReactions.splice(0);\n        for(var i = 0, l = remainingReactions.length; i < l; i++){\n            remainingReactions[i].runReaction_();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = /*#__PURE__*/ createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function() {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return  true && !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (false) {} // dead code elimination can do the rest\n    if (!globalState.spyListeners.length) {\n        return;\n    }\n    var listeners = globalState.spyListeners;\n    for(var i = 0, l = listeners.length; i < l; i++){\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    if (false) {}\n    var change = _extends({}, event, {\n        spyReportStart: true\n    });\n    spyReport(change);\n}\nvar END_EVENT = {\n    type: \"report-end\",\n    spyReportEnd: true\n};\nfunction spyReportEnd(change) {\n    if (false) {}\n    if (change) {\n        spyReport(_extends({}, change, {\n            type: \"report-end\",\n            spyReportEnd: true\n        }));\n    } else {\n        spyReport(END_EVENT);\n    }\n}\nfunction spy(listener) {\n    if (false) {} else {\n        globalState.spyListeners.push(listener);\n        return once(function() {\n            globalState.spyListeners = globalState.spyListeners.filter(function(l) {\n                return l !== listener;\n            });\n        });\n    }\n}\nvar ACTION = \"action\";\nvar ACTION_BOUND = \"action.bound\";\nvar AUTOACTION = \"autoAction\";\nvar AUTOACTION_BOUND = \"autoAction.bound\";\nvar DEFAULT_ACTION_NAME = \"<unnamed action>\";\nvar actionAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION);\nvar actionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION_BOUND, {\n    bound: true\n});\nvar autoActionAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION, {\n    autoAction: true\n});\nvar autoActionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION_BOUND, {\n    autoAction: true,\n    bound: true\n});\nfunction createActionFactory(autoAction) {\n    var res = function action(arg1, arg2) {\n        // action(fn() {})\n        if (isFunction(arg1)) {\n            return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);\n        }\n        // action(\"name\", fn() {})\n        if (isFunction(arg2)) {\n            return createAction(arg1, arg2, autoAction);\n        }\n        // @action (2022.3 Decorators)\n        if (is20223Decorator(arg2)) {\n            return (autoAction ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);\n        }\n        // @action\n        if (isStringish(arg2)) {\n            return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);\n        }\n        // action(\"name\") & @action(\"name\")\n        if (isStringish(arg1)) {\n            return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {\n                name: arg1,\n                autoAction: autoAction\n            }));\n        }\n        if (true) {\n            die(\"Invalid arguments for `action`\");\n        }\n    };\n    return res;\n}\nvar action = /*#__PURE__*/ createActionFactory(false);\nObject.assign(action, actionAnnotation);\nvar autoAction = /*#__PURE__*/ createActionFactory(true);\nObject.assign(autoAction, autoActionAnnotation);\naction.bound = /*#__PURE__*/ createDecoratorAnnotation(actionBoundAnnotation);\nautoAction.bound = /*#__PURE__*/ createDecoratorAnnotation(autoActionBoundAnnotation);\nfunction runInAction(fn) {\n    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);\n}\nfunction isAction(thing) {\n    return isFunction(thing) && thing.isMobxAction === true;\n}\n/**\n * Creates a named reactive view and keeps it alive, so that the view is always\n * updated if one of the dependencies changes, even when the view is not further used by something else.\n * @param view The reactive view\n * @returns disposer function, which can be used to stop the view from being updated in the future.\n */ function autorun(view, opts) {\n    var _opts$name, _opts, _opts2, _opts3;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(view)) {\n            die(\"Autorun expects a function as first argument\");\n        }\n        if (isAction(view)) {\n            die(\"Autorun does not accept actions since actions are untrackable\");\n        }\n    }\n    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  true ? view.name || \"Autorun@\" + getNextId() : 0;\n    var runSync = !opts.scheduler && !opts.delay;\n    var reaction;\n    if (runSync) {\n        // normal autorun\n        reaction = new Reaction(name, function() {\n            this.track(reactionRunner);\n        }, opts.onError, opts.requiresObservable);\n    } else {\n        var scheduler = createSchedulerFromOptions(opts);\n        // debounced autorun\n        var isScheduled = false;\n        reaction = new Reaction(name, function() {\n            if (!isScheduled) {\n                isScheduled = true;\n                scheduler(function() {\n                    isScheduled = false;\n                    if (!reaction.isDisposed) {\n                        reaction.track(reactionRunner);\n                    }\n                });\n            }\n        }, opts.onError, opts.requiresObservable);\n    }\n    function reactionRunner() {\n        view(reaction);\n    }\n    if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {\n        reaction.schedule_();\n    }\n    return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);\n}\nvar run = function run(f) {\n    return f();\n};\nfunction createSchedulerFromOptions(opts) {\n    return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {\n        return setTimeout(f, opts.delay);\n    } : run;\n}\nfunction reaction(expression, effect, opts) {\n    var _opts$name2, _opts4, _opts5;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(expression) || !isFunction(effect)) {\n            die(\"First and second argument to reaction should be functions\");\n        }\n        if (!isPlainObject(opts)) {\n            die(\"Third argument of reactions should be an object\");\n        }\n    }\n    var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  true ? \"Reaction@\" + getNextId() : 0;\n    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);\n    var runSync = !opts.scheduler && !opts.delay;\n    var scheduler = createSchedulerFromOptions(opts);\n    var firstTime = true;\n    var isScheduled = false;\n    var value;\n    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer[\"default\"];\n    var r = new Reaction(name, function() {\n        if (firstTime || runSync) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            scheduler(reactionRunner);\n        }\n    }, opts.onError, opts.requiresObservable);\n    function reactionRunner() {\n        isScheduled = false;\n        if (r.isDisposed) {\n            return;\n        }\n        var changed = false;\n        var oldValue = value;\n        r.track(function() {\n            var nextValue = allowStateChanges(false, function() {\n                return expression(r);\n            });\n            changed = firstTime || !equals(value, nextValue);\n            value = nextValue;\n        });\n        if (firstTime && opts.fireImmediately) {\n            effectAction(value, oldValue, r);\n        } else if (!firstTime && changed) {\n            effectAction(value, oldValue, r);\n        }\n        firstTime = false;\n    }\n    if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {\n        r.schedule_();\n    }\n    return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);\n}\nfunction wrapErrorHandler(errorHandler, baseFn) {\n    return function() {\n        try {\n            return baseFn.apply(this, arguments);\n        } catch (e) {\n            errorHandler.call(this, e);\n        }\n    };\n}\nvar ON_BECOME_OBSERVED = \"onBO\";\nvar ON_BECOME_UNOBSERVED = \"onBUO\";\nfunction onBecomeObserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);\n}\nfunction onBecomeUnobserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);\n}\nfunction interceptHook(hook, thing, arg2, arg3) {\n    var atom = typeof arg3 === \"function\" ? getAtom(thing, arg2) : getAtom(thing);\n    var cb = isFunction(arg3) ? arg3 : arg2;\n    var listenersKey = hook + \"L\";\n    if (atom[listenersKey]) {\n        atom[listenersKey].add(cb);\n    } else {\n        atom[listenersKey] = new Set([\n            cb\n        ]);\n    }\n    return function() {\n        var hookListeners = atom[listenersKey];\n        if (hookListeners) {\n            hookListeners[\"delete\"](cb);\n            if (hookListeners.size === 0) {\n                delete atom[listenersKey];\n            }\n        }\n    };\n}\nvar NEVER = \"never\";\nvar ALWAYS = \"always\";\nvar OBSERVED = \"observed\";\n// const IF_AVAILABLE = \"ifavailable\"\nfunction configure(options) {\n    if (options.isolateGlobalState === true) {\n        isolateGlobalState();\n    }\n    var useProxies = options.useProxies, enforceActions = options.enforceActions;\n    if (useProxies !== undefined) {\n        globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== \"undefined\";\n    }\n    if (useProxies === \"ifavailable\") {\n        globalState.verifyProxies = true;\n    }\n    if (enforceActions !== undefined) {\n        var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;\n        globalState.enforceActions = ea;\n        globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;\n    }\n    [\n        \"computedRequiresReaction\",\n        \"reactionRequiresObservable\",\n        \"observableRequiresReaction\",\n        \"disableErrorBoundaries\",\n        \"safeDescriptors\"\n    ].forEach(function(key) {\n        if (key in options) {\n            globalState[key] = !!options[key];\n        }\n    });\n    globalState.allowStateReads = !globalState.observableRequiresReaction;\n    if ( true && globalState.disableErrorBoundaries === true) {\n        console.warn(\"WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.\");\n    }\n    if (options.reactionScheduler) {\n        setReactionScheduler(options.reactionScheduler);\n    }\n}\nfunction extendObservable(target, properties, annotations, options) {\n    if (true) {\n        if (arguments.length > 4) {\n            die(\"'extendObservable' expected 2-4 arguments\");\n        }\n        if (typeof target !== \"object\") {\n            die(\"'extendObservable' expects an object as first argument\");\n        }\n        if (isObservableMap(target)) {\n            die(\"'extendObservable' should not be used on maps, use map.merge instead\");\n        }\n        if (!isPlainObject(properties)) {\n            die(\"'extendObservable' only accepts plain objects as second argument\");\n        }\n        if (isObservable(properties) || isObservable(annotations)) {\n            die(\"Extending an object with another observable (object) is not supported\");\n        }\n    }\n    // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)\n    var descriptors = getOwnPropertyDescriptors(properties);\n    initObservable(function() {\n        var adm = asObservableObject(target, options)[$mobx];\n        ownKeys(descriptors).forEach(function(key) {\n            adm.extend_(key, descriptors[key], // must pass \"undefined\" for { key: undefined }\n            !annotations ? true : key in annotations ? annotations[key] : true);\n        });\n    });\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (node.observing_ && node.observing_.length > 0) {\n        result.dependencies = unique(node.observing_).map(nodeToDependencyTree);\n    }\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (hasObservers(node)) {\n        result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);\n    }\n    return result;\n}\nfunction unique(list) {\n    return Array.from(new Set(list));\n}\nvar generatorId = 0;\nfunction FlowCancellationError() {\n    this.message = \"FLOW_CANCELLED\";\n}\nFlowCancellationError.prototype = /*#__PURE__*/ Object.create(Error.prototype);\nfunction isFlowCancellationError(error) {\n    return error instanceof FlowCancellationError;\n}\nvar flowAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow\");\nvar flowBoundAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow.bound\", {\n    bound: true\n});\nvar flow = /*#__PURE__*/ Object.assign(function flow(arg1, arg2) {\n    // @flow (2022.3 Decorators)\n    if (is20223Decorator(arg2)) {\n        return flowAnnotation.decorate_20223_(arg1, arg2);\n    }\n    // @flow\n    if (isStringish(arg2)) {\n        return storeAnnotation(arg1, arg2, flowAnnotation);\n    }\n    // flow(fn)\n    if ( true && arguments.length !== 1) {\n        die(\"Flow expects single argument with generator function\");\n    }\n    var generator = arg1;\n    var name = generator.name || \"<unnamed flow>\";\n    // Implementation based on https://github.com/tj/co/blob/master/index.js\n    var res = function res() {\n        var ctx = this;\n        var args = arguments;\n        var runId = ++generatorId;\n        var gen = action(name + \" - runid: \" + runId + \" - init\", generator).apply(ctx, args);\n        var rejector;\n        var pendingPromise = undefined;\n        var promise = new Promise(function(resolve, reject) {\n            var stepId = 0;\n            rejector = reject;\n            function onFulfilled(res) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen.next).call(gen, res);\n                } catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function onRejected(err) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen[\"throw\"]).call(gen, err);\n                } catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (isFunction(ret == null ? void 0 : ret.then)) {\n                    // an async iterator\n                    ret.then(next, reject);\n                    return;\n                }\n                if (ret.done) {\n                    return resolve(ret.value);\n                }\n                pendingPromise = Promise.resolve(ret.value);\n                return pendingPromise.then(onFulfilled, onRejected);\n            }\n            onFulfilled(undefined); // kick off the process\n        });\n        promise.cancel = action(name + \" - runid: \" + runId + \" - cancel\", function() {\n            try {\n                if (pendingPromise) {\n                    cancelPromise(pendingPromise);\n                }\n                // Finally block can return (or yield) stuff..\n                var _res = gen[\"return\"](undefined);\n                // eat anything that promise would do, it's cancelled!\n                var yieldedPromise = Promise.resolve(_res.value);\n                yieldedPromise.then(noop, noop);\n                cancelPromise(yieldedPromise); // maybe it can be cancelled :)\n                // reject our original promise\n                rejector(new FlowCancellationError());\n            } catch (e) {\n                rejector(e); // there could be a throwing finally block\n            }\n        });\n        return promise;\n    };\n    res.isMobXFlow = true;\n    return res;\n}, flowAnnotation);\nflow.bound = /*#__PURE__*/ createDecoratorAnnotation(flowBoundAnnotation);\nfunction cancelPromise(promise) {\n    if (isFunction(promise.cancel)) {\n        promise.cancel();\n    }\n}\nfunction flowResult(result) {\n    return result; // just tricking TypeScript :)\n}\nfunction isFlow(fn) {\n    return (fn == null ? void 0 : fn.isMobXFlow) === true;\n}\nfunction interceptReads(thing, propOrHandler, handler) {\n    var target;\n    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {\n        target = getAdministration(thing);\n    } else if (isObservableObject(thing)) {\n        if ( true && !isStringish(propOrHandler)) {\n            return die(\"InterceptReads can only be used with a specific property, not with an object in general\");\n        }\n        target = getAdministration(thing, propOrHandler);\n    } else if (true) {\n        return die(\"Expected observable map, object or array as first array\");\n    }\n    if ( true && target.dehancer !== undefined) {\n        return die(\"An intercept reader was already established\");\n    }\n    target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler;\n    return function() {\n        target.dehancer = undefined;\n    };\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (isFunction(handler)) {\n        return interceptProperty(thing, propOrHandler, handler);\n    } else {\n        return interceptInterceptable(thing, propOrHandler);\n    }\n}\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept_(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept_(handler);\n}\nfunction _isComputed(value, property) {\n    if (property === undefined) {\n        return isComputedValue(value);\n    }\n    if (isObservableObject(value) === false) {\n        return false;\n    }\n    if (!value[$mobx].values_.has(property)) {\n        return false;\n    }\n    var atom = getAtom(value, property);\n    return isComputedValue(atom);\n}\nfunction isComputed(value) {\n    if ( true && arguments.length > 1) {\n        return die(\"isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property\");\n    }\n    return _isComputed(value);\n}\nfunction isComputedProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"isComputed expected a property name as second argument\");\n    }\n    return _isComputed(value, propName);\n}\nfunction _isObservable(value, property) {\n    if (!value) {\n        return false;\n    }\n    if (property !== undefined) {\n        if ( true && (isObservableMap(value) || isObservableArray(value))) {\n            return die(\"isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n        }\n        if (isObservableObject(value)) {\n            return value[$mobx].values_.has(property);\n        }\n        return false;\n    }\n    // For first check, see #701\n    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nfunction isObservable(value) {\n    if ( true && arguments.length !== 1) {\n        die(\"isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property\");\n    }\n    return _isObservable(value);\n}\nfunction isObservableProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"expected a property name as second argument\");\n    }\n    return _isObservable(value, propName);\n}\nfunction keys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].keys_();\n    }\n    if (isObservableMap(obj) || isObservableSet(obj)) {\n        return Array.from(obj.keys());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function(_, index) {\n            return index;\n        });\n    }\n    die(5);\n}\nfunction values(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function(key) {\n            return obj[key];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function(key) {\n            return obj.get(key);\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.values());\n    }\n    if (isObservableArray(obj)) {\n        return obj.slice();\n    }\n    die(6);\n}\nfunction entries(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function(key) {\n            return [\n                key,\n                obj[key]\n            ];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function(key) {\n            return [\n                key,\n                obj.get(key)\n            ];\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.entries());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function(key, index) {\n            return [\n                index,\n                key\n            ];\n        });\n    }\n    die(7);\n}\nfunction set(obj, key, value) {\n    if (arguments.length === 2 && !isObservableSet(obj)) {\n        startBatch();\n        var _values = key;\n        try {\n            for(var _key in _values){\n                set(obj, _key, _values[_key]);\n            }\n        } finally{\n            endBatch();\n        }\n        return;\n    }\n    if (isObservableObject(obj)) {\n        obj[$mobx].set_(key, value);\n    } else if (isObservableMap(obj)) {\n        obj.set(key, value);\n    } else if (isObservableSet(obj)) {\n        obj.add(key);\n    } else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        if (key < 0) {\n            die(\"Invalid index: '\" + key + \"'\");\n        }\n        startBatch();\n        if (key >= obj.length) {\n            obj.length = key + 1;\n        }\n        obj[key] = value;\n        endBatch();\n    } else {\n        die(8);\n    }\n}\nfunction remove(obj, key) {\n    if (isObservableObject(obj)) {\n        obj[$mobx].delete_(key);\n    } else if (isObservableMap(obj)) {\n        obj[\"delete\"](key);\n    } else if (isObservableSet(obj)) {\n        obj[\"delete\"](key);\n    } else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        obj.splice(key, 1);\n    } else {\n        die(9);\n    }\n}\nfunction has(obj, key) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].has_(key);\n    } else if (isObservableMap(obj)) {\n        return obj.has(key);\n    } else if (isObservableSet(obj)) {\n        return obj.has(key);\n    } else if (isObservableArray(obj)) {\n        return key >= 0 && key < obj.length;\n    }\n    die(10);\n}\nfunction get(obj, key) {\n    if (!has(obj, key)) {\n        return undefined;\n    }\n    if (isObservableObject(obj)) {\n        return obj[$mobx].get_(key);\n    } else if (isObservableMap(obj)) {\n        return obj.get(key);\n    } else if (isObservableArray(obj)) {\n        return obj[key];\n    }\n    die(11);\n}\nfunction apiDefineProperty(obj, key, descriptor) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].defineProperty_(key, descriptor);\n    }\n    die(39);\n}\nfunction apiOwnKeys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].ownKeys_();\n    }\n    die(38);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (isFunction(cbOrFire)) {\n        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    } else {\n        return observeObservable(thing, propOrCb, cbOrFire);\n    }\n}\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe_(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe_(listener, fireImmediately);\n}\nfunction cache(map, key, value) {\n    map.set(key, value);\n    return value;\n}\nfunction toJSHelper(source, __alreadySeen) {\n    if (source == null || typeof source !== \"object\" || source instanceof Date || !isObservable(source)) {\n        return source;\n    }\n    if (isObservableValue(source) || isComputedValue(source)) {\n        return toJSHelper(source.get(), __alreadySeen);\n    }\n    if (__alreadySeen.has(source)) {\n        return __alreadySeen.get(source);\n    }\n    if (isObservableArray(source)) {\n        var res = cache(__alreadySeen, source, new Array(source.length));\n        source.forEach(function(value, idx) {\n            res[idx] = toJSHelper(value, __alreadySeen);\n        });\n        return res;\n    }\n    if (isObservableSet(source)) {\n        var _res = cache(__alreadySeen, source, new Set());\n        source.forEach(function(value) {\n            _res.add(toJSHelper(value, __alreadySeen));\n        });\n        return _res;\n    }\n    if (isObservableMap(source)) {\n        var _res2 = cache(__alreadySeen, source, new Map());\n        source.forEach(function(value, key) {\n            _res2.set(key, toJSHelper(value, __alreadySeen));\n        });\n        return _res2;\n    } else {\n        // must be observable object\n        var _res3 = cache(__alreadySeen, source, {});\n        apiOwnKeys(source).forEach(function(key) {\n            if (objectPrototype.propertyIsEnumerable.call(source, key)) {\n                _res3[key] = toJSHelper(source[key], __alreadySeen);\n            }\n        });\n        return _res3;\n    }\n}\n/**\n * Recursively converts an observable to it's non-observable native counterpart.\n * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.\n * Computed and other non-enumerable properties are completely ignored.\n * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.\n */ function toJS(source, options) {\n    if ( true && options) {\n        die(\"toJS no longer supports options\");\n    }\n    return toJSHelper(source, new Map());\n}\nfunction trace() {\n    if (false) {}\n    var enterBreakPoint = false;\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (typeof args[args.length - 1] === \"boolean\") {\n        enterBreakPoint = args.pop();\n    }\n    var derivation = getAtomFromArgs(args);\n    if (!derivation) {\n        return die(\"'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly\");\n    }\n    if (derivation.isTracing_ === TraceMode.NONE) {\n        console.log(\"[mobx.trace] '\" + derivation.name_ + \"' tracing enabled\");\n    }\n    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;\n}\nfunction getAtomFromArgs(args) {\n    switch(args.length){\n        case 0:\n            return globalState.trackingDerivation;\n        case 1:\n            return getAtom(args[0]);\n        case 2:\n            return getAtom(args[0], args[1]);\n    }\n}\n/**\n * During a transaction no views are updated until the end of the transaction.\n * The transaction will be run synchronously nonetheless.\n *\n * @param action a function that updates some reactive state\n * @returns any value that was returned by the 'action' parameter.\n */ function transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    startBatch();\n    try {\n        return action.apply(thisArg);\n    } finally{\n        endBatch();\n    }\n}\nfunction when(predicate, arg1, arg2) {\n    if (arguments.length === 1 || arg1 && typeof arg1 === \"object\") {\n        return whenPromise(predicate, arg1);\n    }\n    return _when(predicate, arg1, arg2 || {});\n}\nfunction _when(predicate, effect, opts) {\n    var timeoutHandle;\n    if (typeof opts.timeout === \"number\") {\n        var error = new Error(\"WHEN_TIMEOUT\");\n        timeoutHandle = setTimeout(function() {\n            if (!disposer[$mobx].isDisposed) {\n                disposer();\n                if (opts.onError) {\n                    opts.onError(error);\n                } else {\n                    throw error;\n                }\n            }\n        }, opts.timeout);\n    }\n    opts.name =  true ? opts.name || \"When@\" + getNextId() : 0;\n    var effectAction = createAction( true ? opts.name + \"-effect\" : 0, effect);\n    // eslint-disable-next-line\n    var disposer = autorun(function(r) {\n        // predicate should not change state\n        var cond = allowStateChanges(false, predicate);\n        if (cond) {\n            r.dispose();\n            if (timeoutHandle) {\n                clearTimeout(timeoutHandle);\n            }\n            effectAction();\n        }\n    }, opts);\n    return disposer;\n}\nfunction whenPromise(predicate, opts) {\n    var _opts$signal;\n    if ( true && opts && opts.onError) {\n        return die(\"the options 'onError' and 'promise' cannot be combined\");\n    }\n    if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {\n        return Object.assign(Promise.reject(new Error(\"WHEN_ABORTED\")), {\n            cancel: function cancel() {\n                return null;\n            }\n        });\n    }\n    var cancel;\n    var abort;\n    var res = new Promise(function(resolve, reject) {\n        var _opts$signal2;\n        var disposer = _when(predicate, resolve, _extends({}, opts, {\n            onError: reject\n        }));\n        cancel = function cancel() {\n            disposer();\n            reject(new Error(\"WHEN_CANCELLED\"));\n        };\n        abort = function abort() {\n            disposer();\n            reject(new Error(\"WHEN_ABORTED\"));\n        };\n        opts == null || (_opts$signal2 = opts.signal) == null || _opts$signal2.addEventListener == null || _opts$signal2.addEventListener(\"abort\", abort);\n    })[\"finally\"](function() {\n        var _opts$signal3;\n        return opts == null || (_opts$signal3 = opts.signal) == null || _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener(\"abort\", abort);\n    });\n    res.cancel = cancel;\n    return res;\n}\nfunction getAdm(target) {\n    return target[$mobx];\n}\n// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,\n// and skip either the internal values map, or the base object with its property descriptors!\nvar objectProxyTraps = {\n    has: function has(target, name) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.\");\n        }\n        return getAdm(target).has_(name);\n    },\n    get: function get(target, name) {\n        return getAdm(target).get_(name);\n    },\n    set: function set(target, name, value) {\n        var _getAdm$set_;\n        if (!isStringish(name)) {\n            return false;\n        }\n        if ( true && !getAdm(target).values_.has(name)) {\n            warnAboutProxyRequirement(\"add a new observable property through direct assignment. Use 'set' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;\n    },\n    deleteProperty: function deleteProperty(target, name) {\n        var _getAdm$delete_;\n        if (true) {\n            warnAboutProxyRequirement(\"delete properties from an observable object. Use 'remove' from 'mobx' instead.\");\n        }\n        if (!isStringish(name)) {\n            return false;\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;\n    },\n    defineProperty: function defineProperty(target, name, descriptor) {\n        var _getAdm$definePropert;\n        if (true) {\n            warnAboutProxyRequirement(\"define property on an observable object. Use 'defineProperty' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;\n    },\n    ownKeys: function ownKeys(target) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.\");\n        }\n        return getAdm(target).ownKeys_();\n    },\n    preventExtensions: function preventExtensions(target) {\n        die(13);\n    }\n};\nfunction asDynamicObservableObject(target, options) {\n    var _target$$mobx, _target$$mobx$proxy_;\n    assertProxies();\n    target = asObservableObject(target, options);\n    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);\n}\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);\n    interceptors.push(handler);\n    return once(function() {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) {\n            interceptors.splice(idx, 1);\n        }\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950\n        var interceptors = [].concat(interceptable.interceptors_ || []);\n        for(var i = 0, l = interceptors.length; i < l; i++){\n            change = interceptors[i](change);\n            if (change && !change.type) {\n                die(14);\n            }\n            if (!change) {\n                break;\n            }\n        }\n        return change;\n    } finally{\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);\n    listeners.push(handler);\n    return once(function() {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) {\n            listeners.splice(idx, 1);\n        }\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners_;\n    if (!listeners) {\n        return;\n    }\n    listeners = listeners.slice();\n    for(var i = 0, l = listeners.length; i < l; i++){\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction makeObservable(target, annotations, options) {\n    initObservable(function() {\n        var _annotations;\n        var adm = asObservableObject(target, options)[$mobx];\n        if ( true && annotations && target[storedAnnotationsSymbol]) {\n            die(\"makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.\");\n        }\n        // Default to decorators\n        (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);\n        // Annotate\n        ownKeys(annotations).forEach(function(key) {\n            return adm.make_(key, annotations[key]);\n        });\n    });\n    return target;\n}\n// proto[keysSymbol] = new Set<PropertyKey>()\nvar keysSymbol = /*#__PURE__*/ Symbol(\"mobx-keys\");\nfunction makeAutoObservable(target, overrides, options) {\n    if (true) {\n        if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {\n            die(\"'makeAutoObservable' can only be used for classes that don't have a superclass\");\n        }\n        if (isObservableObject(target)) {\n            die(\"makeAutoObservable can only be used on objects not already made observable\");\n        }\n    }\n    // Optimization: avoid visiting protos\n    // Assumes that annotation.make_/.extend_ works the same for plain objects\n    if (isPlainObject(target)) {\n        return extendObservable(target, target, overrides, options);\n    }\n    initObservable(function() {\n        var adm = asObservableObject(target, options)[$mobx];\n        // Optimization: cache keys on proto\n        // Assumes makeAutoObservable can be called only once per object and can't be used in subclass\n        if (!target[keysSymbol]) {\n            var proto = Object.getPrototypeOf(target);\n            var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));\n            keys[\"delete\"](\"constructor\");\n            keys[\"delete\"]($mobx);\n            addHiddenProp(proto, keysSymbol, keys);\n        }\n        target[keysSymbol].forEach(function(key) {\n            return adm.make_(key, // must pass \"undefined\" for { key: undefined }\n            !overrides ? true : key in overrides ? overrides[key] : true);\n        });\n    });\n    return target;\n}\nvar SPLICE = \"splice\";\nvar UPDATE = \"update\";\nvar MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859\nvar arrayTraps = {\n    get: function get(target, name) {\n        var adm = target[$mobx];\n        if (name === $mobx) {\n            return adm;\n        }\n        if (name === \"length\") {\n            return adm.getArrayLength_();\n        }\n        if (typeof name === \"string\" && !isNaN(name)) {\n            return adm.get_(parseInt(name));\n        }\n        if (hasProp(arrayExtensions, name)) {\n            return arrayExtensions[name];\n        }\n        return target[name];\n    },\n    set: function set(target, name, value) {\n        var adm = target[$mobx];\n        if (name === \"length\") {\n            adm.setArrayLength_(value);\n        }\n        if (typeof name === \"symbol\" || isNaN(name)) {\n            target[name] = value;\n        } else {\n            // numeric string\n            adm.set_(parseInt(name), value);\n        }\n        return true;\n    },\n    preventExtensions: function preventExtensions() {\n        die(15);\n    }\n};\nvar ObservableArrayAdministration = /*#__PURE__*/ function() {\n    function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : 0;\n        }\n        this.owned_ = void 0;\n        this.legacyMode_ = void 0;\n        this.atom_ = void 0;\n        this.values_ = [];\n        // this is the prop that gets proxied, so can't replace it!\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.enhancer_ = void 0;\n        this.dehancer = void 0;\n        this.proxy_ = void 0;\n        this.lastKnownLength_ = 0;\n        this.owned_ = owned_;\n        this.legacyMode_ = legacyMode_;\n        this.atom_ = new Atom(name);\n        this.enhancer_ = function(newV, oldV) {\n            return enhancer(newV, oldV,  true ? name + \"[..]\" : 0);\n        };\n    }\n    var _proto = ObservableArrayAdministration.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.dehanceValues_ = function dehanceValues_(values) {\n        if (this.dehancer !== undefined && values.length > 0) {\n            return values.map(this.dehancer);\n        }\n        return values;\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                observableKind: \"array\",\n                object: this.proxy_,\n                debugObjectName: this.atom_.name_,\n                type: \"splice\",\n                index: 0,\n                added: this.values_.slice(),\n                addedCount: this.values_.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.getArrayLength_ = function getArrayLength_() {\n        this.atom_.reportObserved();\n        return this.values_.length;\n    };\n    _proto.setArrayLength_ = function setArrayLength_(newLength) {\n        if (typeof newLength !== \"number\" || isNaN(newLength) || newLength < 0) {\n            die(\"Out of range: \" + newLength);\n        }\n        var currentLength = this.values_.length;\n        if (newLength === currentLength) {\n            return;\n        } else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for(var i = 0; i < newLength - currentLength; i++){\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            this.spliceWithArray_(currentLength, 0, newItems);\n        } else {\n            this.spliceWithArray_(newLength, currentLength - newLength);\n        }\n    };\n    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {\n        if (oldLength !== this.lastKnownLength_) {\n            die(16);\n        }\n        this.lastKnownLength_ += delta;\n        if (this.legacyMode_ && delta > 0) {\n            reserveArrayBuffer(oldLength + delta + 1);\n        }\n    };\n    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        var length = this.values_.length;\n        if (index === undefined) {\n            index = 0;\n        } else if (index > length) {\n            index = length;\n        } else if (index < 0) {\n            index = Math.max(0, length + index);\n        }\n        if (arguments.length === 1) {\n            deleteCount = length - index;\n        } else if (deleteCount === undefined || deleteCount === null) {\n            deleteCount = 0;\n        } else {\n            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        }\n        if (newItems === undefined) {\n            newItems = EMPTY_ARRAY;\n        }\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_,\n                type: SPLICE,\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) {\n                return EMPTY_ARRAY;\n            }\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {\n            return _this.enhancer_(v, undefined);\n        });\n        if (this.legacyMode_ || \"development\" !== \"production\") {\n            var lengthDelta = newItems.length - deleteCount;\n            this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified\n        }\n        var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) {\n            this.notifyArraySplice_(index, newItems, res);\n        }\n        return this.dehanceValues_(res);\n    };\n    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            var _this$values_;\n            return (_this$values_ = this.values_).splice.apply(_this$values_, [\n                index,\n                deleteCount\n            ].concat(newItems));\n        } else {\n            // The items removed by the splice\n            var res = this.values_.slice(index, index + deleteCount);\n            // The items that that should remain at the end of the array\n            var oldItems = this.values_.slice(index + deleteCount);\n            // New length is the previous length + addition count - deletion count\n            this.values_.length += newItems.length - deleteCount;\n            for(var i = 0; i < newItems.length; i++){\n                this.values_[index + i] = newItems[i];\n            }\n            for(var _i = 0; _i < oldItems.length; _i++){\n                this.values_[index + newItems.length + _i] = oldItems[_i];\n            }\n            return res;\n        }\n    };\n    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            type: UPDATE,\n            debugObjectName: this.atom_.name_,\n            index: index,\n            newValue: newValue,\n            oldValue: oldValue\n        } : null;\n        // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't\n        // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            debugObjectName: this.atom_.name_,\n            type: SPLICE,\n            index: index,\n            removed: removed,\n            added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get_ = function get_(index) {\n        if (this.legacyMode_ && index >= this.values_.length) {\n            console.warn( true ? \"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + this.values_.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\" : 0);\n            return undefined;\n        }\n        this.atom_.reportObserved();\n        return this.dehanceValue_(this.values_[index]);\n    };\n    _proto.set_ = function set_(index, newValue) {\n        var values = this.values_;\n        if (this.legacyMode_ && index > values.length) {\n            // out of bounds\n            die(17, index, values.length);\n        }\n        if (index < values.length) {\n            // update at index in range\n            checkIfStateModificationsAreAllowed(this.atom_);\n            var oldValue = values[index];\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    type: UPDATE,\n                    object: this.proxy_,\n                    // since \"this\" is the real array we need to pass its proxy\n                    index: index,\n                    newValue: newValue\n                });\n                if (!change) {\n                    return;\n                }\n                newValue = change.newValue;\n            }\n            newValue = this.enhancer_(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                this.notifyArrayChildUpdate_(index, newValue, oldValue);\n            }\n        } else {\n            // For out of bound index, we don't create an actual sparse array,\n            // but rather fill the holes with undefined (same as setArrayLength_).\n            // This could be considered a bug.\n            var newItems = new Array(index + 1 - values.length);\n            for(var i = 0; i < newItems.length - 1; i++){\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            newItems[newItems.length - 1] = newValue;\n            this.spliceWithArray_(values.length, 0, newItems);\n        }\n    };\n    return ObservableArrayAdministration;\n}();\nfunction createObservableArray(initialValues, enhancer, name, owned) {\n    if (name === void 0) {\n        name =  true ? \"ObservableArray@\" + getNextId() : 0;\n    }\n    if (owned === void 0) {\n        owned = false;\n    }\n    assertProxies();\n    return initObservable(function() {\n        var adm = new ObservableArrayAdministration(name, enhancer, owned, false);\n        addHiddenFinalProp(adm.values_, $mobx, adm);\n        var proxy = new Proxy(adm.values_, arrayTraps);\n        adm.proxy_ = proxy;\n        if (initialValues && initialValues.length) {\n            adm.spliceWithArray_(0, 0, initialValues);\n        }\n        return proxy;\n    });\n}\n// eslint-disable-next-line\nvar arrayExtensions = {\n    clear: function clear() {\n        return this.splice(0);\n    },\n    replace: function replace(newItems) {\n        var adm = this[$mobx];\n        return adm.spliceWithArray_(0, adm.values_.length, newItems);\n    },\n    // Used by JSON.stringify\n    toJSON: function toJSON() {\n        return this.slice();\n    },\n    /*\n   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)\n   * since these functions alter the inner structure of the array, the have side effects.\n   * Because the have side effects, they should not be used in computed function,\n   * and for that reason the do not call dependencyState.notifyObserved\n   */ splice: function splice(index, deleteCount) {\n        for(var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            newItems[_key - 2] = arguments[_key];\n        }\n        var adm = this[$mobx];\n        switch(arguments.length){\n            case 0:\n                return [];\n            case 1:\n                return adm.spliceWithArray_(index);\n            case 2:\n                return adm.spliceWithArray_(index, deleteCount);\n        }\n        return adm.spliceWithArray_(index, deleteCount, newItems);\n    },\n    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {\n        return this[$mobx].spliceWithArray_(index, deleteCount, newItems);\n    },\n    push: function push() {\n        var adm = this[$mobx];\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        adm.spliceWithArray_(adm.values_.length, 0, items);\n        return adm.values_.length;\n    },\n    pop: function pop() {\n        return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];\n    },\n    shift: function shift() {\n        return this.splice(0, 1)[0];\n    },\n    unshift: function unshift() {\n        var adm = this[$mobx];\n        for(var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            items[_key3] = arguments[_key3];\n        }\n        adm.spliceWithArray_(0, 0, items);\n        return adm.values_.length;\n    },\n    reverse: function reverse() {\n        // reverse by default mutates in place before returning the result\n        // which makes it both a 'derivation' and a 'mutation'.\n        if (globalState.trackingDerivation) {\n            die(37, \"reverse\");\n        }\n        this.replace(this.slice().reverse());\n        return this;\n    },\n    sort: function sort() {\n        // sort by default mutates in place before returning the result\n        // which goes against all good practices. Let's not change the array in place!\n        if (globalState.trackingDerivation) {\n            die(37, \"sort\");\n        }\n        var copy = this.slice();\n        copy.sort.apply(copy, arguments);\n        this.replace(copy);\n        return this;\n    },\n    remove: function remove(value) {\n        var adm = this[$mobx];\n        var idx = adm.dehanceValues_(adm.values_).indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n};\n/**\n * Wrap function from prototype\n * Without this, everything works as well, but this works\n * faster as everything works on unproxied values\n */ addArrayExtension(\"at\", simpleFunc);\naddArrayExtension(\"concat\", simpleFunc);\naddArrayExtension(\"flat\", simpleFunc);\naddArrayExtension(\"includes\", simpleFunc);\naddArrayExtension(\"indexOf\", simpleFunc);\naddArrayExtension(\"join\", simpleFunc);\naddArrayExtension(\"lastIndexOf\", simpleFunc);\naddArrayExtension(\"slice\", simpleFunc);\naddArrayExtension(\"toString\", simpleFunc);\naddArrayExtension(\"toLocaleString\", simpleFunc);\naddArrayExtension(\"toSorted\", simpleFunc);\naddArrayExtension(\"toSpliced\", simpleFunc);\naddArrayExtension(\"with\", simpleFunc);\n// map\naddArrayExtension(\"every\", mapLikeFunc);\naddArrayExtension(\"filter\", mapLikeFunc);\naddArrayExtension(\"find\", mapLikeFunc);\naddArrayExtension(\"findIndex\", mapLikeFunc);\naddArrayExtension(\"findLast\", mapLikeFunc);\naddArrayExtension(\"findLastIndex\", mapLikeFunc);\naddArrayExtension(\"flatMap\", mapLikeFunc);\naddArrayExtension(\"forEach\", mapLikeFunc);\naddArrayExtension(\"map\", mapLikeFunc);\naddArrayExtension(\"some\", mapLikeFunc);\naddArrayExtension(\"toReversed\", mapLikeFunc);\n// reduce\naddArrayExtension(\"reduce\", reduceLikeFunc);\naddArrayExtension(\"reduceRight\", reduceLikeFunc);\nfunction addArrayExtension(funcName, funcFactory) {\n    if (typeof Array.prototype[funcName] === \"function\") {\n        arrayExtensions[funcName] = funcFactory(funcName);\n    }\n}\n// Report and delegate to dehanced array\nfunction simpleFunc(funcName) {\n    return function() {\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\n// Make sure callbacks receive correct array arg #2326\nfunction mapLikeFunc(funcName) {\n    return function(callback, thisArg) {\n        var _this2 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName](function(element, index) {\n            return callback.call(thisArg, element, index, _this2);\n        });\n    };\n}\n// Make sure callbacks receive correct array arg #2326\nfunction reduceLikeFunc(funcName) {\n    return function() {\n        var _this3 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        // #2432 - reduce behavior depends on arguments.length\n        var callback = arguments[0];\n        arguments[0] = function(accumulator, currentValue, index) {\n            return callback(accumulator, currentValue, index, _this3);\n        };\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\nvar isObservableArrayAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);\n}\nvar ObservableMapMarker = {};\nvar ADD = \"add\";\nvar DELETE = \"delete\";\n// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54\n// But: https://github.com/mobxjs/mobx/issues/1556\nvar ObservableMap = /*#__PURE__*/ function() {\n    function ObservableMap(initialData, enhancer_, name_) {\n        var _this = this;\n        if (enhancer_ === void 0) {\n            enhancer_ = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableMap@\" + getNextId() : 0;\n        }\n        this.enhancer_ = void 0;\n        this.name_ = void 0;\n        this[$mobx] = ObservableMapMarker;\n        this.data_ = void 0;\n        this.hasMap_ = void 0;\n        // hasMap, not hashMap >-).\n        this.keysAtom_ = void 0;\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = enhancer_;\n        this.name_ = name_;\n        if (!isFunction(Map)) {\n            die(18);\n        }\n        initObservable(function() {\n            _this.keysAtom_ = createAtom( true ? _this.name_ + \".keys()\" : 0);\n            _this.data_ = new Map();\n            _this.hasMap_ = new Map();\n            if (initialData) {\n                _this.merge(initialData);\n            }\n        });\n    }\n    var _proto = ObservableMap.prototype;\n    _proto.has_ = function has_(key) {\n        return this.data_.has(key);\n    };\n    _proto.has = function has(key) {\n        var _this2 = this;\n        if (!globalState.trackingDerivation) {\n            return this.has_(key);\n        }\n        var entry = this.hasMap_.get(key);\n        if (!entry) {\n            var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n            this.hasMap_.set(key, newEntry);\n            onBecomeUnobserved(newEntry, function() {\n                return _this2.hasMap_[\"delete\"](key);\n            });\n        }\n        return entry.get();\n    };\n    _proto.set = function set(key, value) {\n        var hasKey = this.has_(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? UPDATE : ADD,\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) {\n                return this;\n            }\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this.updateValue_(key, value);\n        } else {\n            this.addValue_(key, value);\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(key) {\n        var _this3 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                name: key\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has_(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: this.data_.get(key).value_,\n                name: key\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            } // TODO fix type\n            transaction(function() {\n                var _this3$hasMap_$get;\n                _this3.keysAtom_.reportChanged();\n                (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);\n                var observable = _this3.data_.get(key);\n                observable.setNewValue_(undefined);\n                _this3.data_[\"delete\"](key);\n            });\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.updateValue_ = function updateValue_(key, newValue) {\n        var observable = this.data_.get(key);\n        newValue = observable.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: UPDATE,\n                object: this,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            } // TODO fix type\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.addValue_ = function addValue_(key, newValue) {\n        var _this4 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        transaction(function() {\n            var _this4$hasMap_$get;\n            var observable = new ObservableValue(newValue, _this4.enhancer_,  true ? _this4.name_ + \".\" + stringifyKey(key) : 0, false);\n            _this4.data_.set(key, observable);\n            newValue = observable.value_; // value might have been changed\n            (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);\n            _this4.keysAtom_.reportChanged();\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"map\",\n            debugObjectName: this.name_,\n            type: ADD,\n            object: this,\n            name: key,\n            newValue: newValue\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        } // TODO fix type\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get = function get(key) {\n        if (this.has(key)) {\n            return this.dehanceValue_(this.data_.get(key).get());\n        }\n        return this.dehanceValue_(undefined);\n    };\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.keys = function keys() {\n        this.keysAtom_.reportObserved();\n        return this.data_.keys();\n    };\n    _proto.values = function values() {\n        var self1 = this;\n        var keys = this.keys();\n        return makeIterableForMap({\n            next: function next() {\n                var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;\n                return {\n                    done: done,\n                    value: done ? undefined : self1.get(value)\n                };\n            }\n        });\n    };\n    _proto.entries = function entries() {\n        var self1 = this;\n        var keys = this.keys();\n        return makeIterableForMap({\n            next: function next() {\n                var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;\n                return {\n                    done: done,\n                    value: done ? undefined : [\n                        value,\n                        self1.get(value)\n                    ]\n                };\n            }\n        });\n    };\n    _proto[Symbol.iterator] = function() {\n        return this.entries();\n    };\n    _proto.forEach = function forEach(callback, thisArg) {\n        for(var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;){\n            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];\n            callback.call(thisArg, value, key, this);\n        }\n    } /** Merge another object into this object, returns this. */ ;\n    _proto.merge = function merge(other) {\n        var _this5 = this;\n        if (isObservableMap(other)) {\n            other = new Map(other);\n        }\n        transaction(function() {\n            if (isPlainObject(other)) {\n                getPlainObjectKeys(other).forEach(function(key) {\n                    return _this5.set(key, other[key]);\n                });\n            } else if (Array.isArray(other)) {\n                other.forEach(function(_ref) {\n                    var key = _ref[0], value = _ref[1];\n                    return _this5.set(key, value);\n                });\n            } else if (isES6Map(other)) {\n                if (!isPlainES6Map(other)) {\n                    die(19, other);\n                }\n                other.forEach(function(value, key) {\n                    return _this5.set(key, value);\n                });\n            } else if (other !== null && other !== undefined) {\n                die(20, other);\n            }\n        });\n        return this;\n    };\n    _proto.clear = function clear() {\n        var _this6 = this;\n        transaction(function() {\n            untracked(function() {\n                for(var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;){\n                    var key = _step2.value;\n                    _this6[\"delete\"](key);\n                }\n            });\n        });\n    };\n    _proto.replace = function replace(values) {\n        var _this7 = this;\n        // Implementation requirements:\n        // - respect ordering of replacement map\n        // - allow interceptors to run and potentially prevent individual operations\n        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)\n        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)\n        // - note that result map may differ from replacement map due to the interceptors\n        transaction(function() {\n            // Convert to map so we can do quick key lookups\n            var replacementMap = convertToMap(values);\n            var orderedData = new Map();\n            // Used for optimization\n            var keysReportChangedCalled = false;\n            // Delete keys that don't exist in replacement map\n            // if the key deletion is prevented by interceptor\n            // add entry at the beginning of the result map\n            for(var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;){\n                var key = _step3.value;\n                // Concurrently iterating/deleting keys\n                // iterator should handle this correctly\n                if (!replacementMap.has(key)) {\n                    var deleted = _this7[\"delete\"](key);\n                    // Was the key removed?\n                    if (deleted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    } else {\n                        // Delete prevented by interceptor\n                        var value = _this7.data_.get(key);\n                        orderedData.set(key, value);\n                    }\n                }\n            }\n            // Merge entries\n            for(var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;){\n                var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];\n                // We will want to know whether a new key is added\n                var keyExisted = _this7.data_.has(_key);\n                // Add or update value\n                _this7.set(_key, _value);\n                // The addition could have been prevent by interceptor\n                if (_this7.data_.has(_key)) {\n                    // The update could have been prevented by interceptor\n                    // and also we want to preserve existing values\n                    // so use value from _data map (instead of replacement map)\n                    var _value2 = _this7.data_.get(_key);\n                    orderedData.set(_key, _value2);\n                    // Was a new key added?\n                    if (!keyExisted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    }\n                }\n            }\n            // Check for possible key order change\n            if (!keysReportChangedCalled) {\n                if (_this7.data_.size !== orderedData.size) {\n                    // If size differs, keys are definitely modified\n                    _this7.keysAtom_.reportChanged();\n                } else {\n                    var iter1 = _this7.data_.keys();\n                    var iter2 = orderedData.keys();\n                    var next1 = iter1.next();\n                    var next2 = iter2.next();\n                    while(!next1.done){\n                        if (next1.value !== next2.value) {\n                            _this7.keysAtom_.reportChanged();\n                            break;\n                        }\n                        next1 = iter1.next();\n                        next2 = iter2.next();\n                    }\n                }\n            }\n            // Use correctly ordered map\n            _this7.data_ = orderedData;\n        });\n        return this;\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableMap]\";\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    /**\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\n   * for callback details\n   */ _proto.observe_ = function observe_(listener, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with maps.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    return _createClass(ObservableMap, [\n        {\n            key: \"size\",\n            get: function get() {\n                this.keysAtom_.reportObserved();\n                return this.data_.size;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"Map\";\n            }\n        }\n    ]);\n}();\n// eslint-disable-next-line\nvar isObservableMap = /*#__PURE__*/ createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nfunction makeIterableForMap(iterator) {\n    iterator[Symbol.toStringTag] = \"MapIterator\";\n    return makeIterable(iterator);\n}\nfunction convertToMap(dataStructure) {\n    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\n        return dataStructure;\n    } else if (Array.isArray(dataStructure)) {\n        return new Map(dataStructure);\n    } else if (isPlainObject(dataStructure)) {\n        var map = new Map();\n        for(var key in dataStructure){\n            map.set(key, dataStructure[key]);\n        }\n        return map;\n    } else {\n        return die(21, dataStructure);\n    }\n}\nvar ObservableSetMarker = {};\nvar ObservableSet = /*#__PURE__*/ function() {\n    function ObservableSet(initialData, enhancer, name_) {\n        var _this = this;\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableSet@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this[$mobx] = ObservableSetMarker;\n        this.data_ = new Set();\n        this.atom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = void 0;\n        this.name_ = name_;\n        if (!isFunction(Set)) {\n            die(22);\n        }\n        this.enhancer_ = function(newV, oldV) {\n            return enhancer(newV, oldV, name_);\n        };\n        initObservable(function() {\n            _this.atom_ = createAtom(_this.name_);\n            if (initialData) {\n                _this.replace(initialData);\n            }\n        });\n    }\n    var _proto = ObservableSet.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.clear = function clear() {\n        var _this2 = this;\n        transaction(function() {\n            untracked(function() {\n                for(var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done;){\n                    var value = _step.value;\n                    _this2[\"delete\"](value);\n                }\n            });\n        });\n    };\n    _proto.forEach = function forEach(callbackFn, thisArg) {\n        for(var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;){\n            var value = _step2.value;\n            callbackFn.call(thisArg, value, value, this);\n        }\n    };\n    _proto.add = function add(value) {\n        var _this3 = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: ADD,\n                object: this,\n                newValue: value\n            });\n            if (!change) {\n                return this;\n            }\n            // implemented reassignment same as it's done for ObservableMap\n            value = change.newValue;\n        }\n        if (!this.has(value)) {\n            transaction(function() {\n                _this3.data_.add(_this3.enhancer_(value, undefined));\n                _this3.atom_.reportChanged();\n            });\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: ADD,\n                object: this,\n                newValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change);\n            }\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(value) {\n        var _this4 = this;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                oldValue: value\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has(value)) {\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change2 = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change2);\n            }\n            transaction(function() {\n                _this4.atom_.reportChanged();\n                _this4.data_[\"delete\"](value);\n            });\n            if (notify) {\n                notifyListeners(this, _change2);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.has = function has(value) {\n        this.atom_.reportObserved();\n        return this.data_.has(this.dehanceValue_(value));\n    };\n    _proto.entries = function entries() {\n        var values = this.values();\n        return makeIterableForSet({\n            next: function next() {\n                var _values$next = values.next(), value = _values$next.value, done = _values$next.done;\n                return !done ? {\n                    value: [\n                        value,\n                        value\n                    ],\n                    done: done\n                } : {\n                    value: undefined,\n                    done: done\n                };\n            }\n        });\n    };\n    _proto.keys = function keys() {\n        return this.values();\n    };\n    _proto.values = function values() {\n        this.atom_.reportObserved();\n        var self1 = this;\n        var values = this.data_.values();\n        return makeIterableForSet({\n            next: function next() {\n                var _values$next2 = values.next(), value = _values$next2.value, done = _values$next2.done;\n                return !done ? {\n                    value: self1.dehanceValue_(value),\n                    done: done\n                } : {\n                    value: undefined,\n                    done: done\n                };\n            }\n        });\n    };\n    _proto.intersection = function intersection(otherSet) {\n        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n            return otherSet.intersection(this);\n        } else {\n            var dehancedSet = new Set(this);\n            return dehancedSet.intersection(otherSet);\n        }\n    };\n    _proto.union = function union(otherSet) {\n        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n            return otherSet.union(this);\n        } else {\n            var dehancedSet = new Set(this);\n            return dehancedSet.union(otherSet);\n        }\n    };\n    _proto.difference = function difference(otherSet) {\n        return new Set(this).difference(otherSet);\n    };\n    _proto.symmetricDifference = function symmetricDifference(otherSet) {\n        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n            return otherSet.symmetricDifference(this);\n        } else {\n            var dehancedSet = new Set(this);\n            return dehancedSet.symmetricDifference(otherSet);\n        }\n    };\n    _proto.isSubsetOf = function isSubsetOf(otherSet) {\n        return new Set(this).isSubsetOf(otherSet);\n    };\n    _proto.isSupersetOf = function isSupersetOf(otherSet) {\n        return new Set(this).isSupersetOf(otherSet);\n    };\n    _proto.isDisjointFrom = function isDisjointFrom(otherSet) {\n        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n            return otherSet.isDisjointFrom(this);\n        } else {\n            var dehancedSet = new Set(this);\n            return dehancedSet.isDisjointFrom(otherSet);\n        }\n    };\n    _proto.replace = function replace(other) {\n        var _this5 = this;\n        if (isObservableSet(other)) {\n            other = new Set(other);\n        }\n        transaction(function() {\n            if (Array.isArray(other)) {\n                _this5.clear();\n                other.forEach(function(value) {\n                    return _this5.add(value);\n                });\n            } else if (isES6Set(other)) {\n                _this5.clear();\n                other.forEach(function(value) {\n                    return _this5.add(value);\n                });\n            } else if (other !== null && other !== undefined) {\n                die(\"Cannot initialize set from \" + other);\n            }\n        });\n        return this;\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        // ... 'fireImmediately' could also be true?\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with sets.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableSet]\";\n    };\n    _proto[Symbol.iterator] = function() {\n        return this.values();\n    };\n    return _createClass(ObservableSet, [\n        {\n            key: \"size\",\n            get: function get() {\n                this.atom_.reportObserved();\n                return this.data_.size;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"Set\";\n            }\n        }\n    ]);\n}();\n// eslint-disable-next-line\nvar isObservableSet = /*#__PURE__*/ createInstanceofPredicate(\"ObservableSet\", ObservableSet);\nfunction makeIterableForSet(iterator) {\n    iterator[Symbol.toStringTag] = \"SetIterator\";\n    return makeIterable(iterator);\n}\nvar descriptorCache = /*#__PURE__*/ Object.create(null);\nvar REMOVE = \"remove\";\nvar ObservableObjectAdministration = /*#__PURE__*/ function() {\n    function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided\n    defaultAnnotation_) {\n        if (values_ === void 0) {\n            values_ = new Map();\n        }\n        if (defaultAnnotation_ === void 0) {\n            defaultAnnotation_ = autoAnnotation;\n        }\n        this.target_ = void 0;\n        this.values_ = void 0;\n        this.name_ = void 0;\n        this.defaultAnnotation_ = void 0;\n        this.keysAtom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.proxy_ = void 0;\n        this.isPlainObject_ = void 0;\n        this.appliedAnnotations_ = void 0;\n        this.pendingKeys_ = void 0;\n        this.target_ = target_;\n        this.values_ = values_;\n        this.name_ = name_;\n        this.defaultAnnotation_ = defaultAnnotation_;\n        this.keysAtom_ = new Atom( true ? this.name_ + \".keys\" : 0);\n        // Optimization: we use this frequently\n        this.isPlainObject_ = isPlainObject(this.target_);\n        if ( true && !isAnnotation(this.defaultAnnotation_)) {\n            die(\"defaultAnnotation must be valid annotation\");\n        }\n        if (true) {\n            // Prepare structure for tracking which fields were already annotated\n            this.appliedAnnotations_ = {};\n        }\n    }\n    var _proto = ObservableObjectAdministration.prototype;\n    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {\n        return this.values_.get(key).get();\n    };\n    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {\n        var observable = this.values_.get(key);\n        if (observable instanceof ComputedValue) {\n            observable.set(newValue);\n            return true;\n        }\n        // intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: UPDATE,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: newValue\n            });\n            if (!change) {\n                return null;\n            }\n            newValue = change.newValue;\n        }\n        newValue = observable.prepareNewValue_(newValue);\n        // notify spy & observers\n        if (newValue !== globalState.UNCHANGED) {\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var _change = notify || notifySpy ? {\n                type: UPDATE,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            }\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        return true;\n    };\n    _proto.get_ = function get_(key) {\n        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\n            // Key doesn't exist yet, subscribe for it in case it's added later\n            this.has_(key);\n        }\n        return this.target_[key];\n    } /**\n   * @param {PropertyKey} key\n   * @param {any} value\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\n   * @param {boolean} proxyTrap whether it's called from proxy trap\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\n   */ ;\n    _proto.set_ = function set_(key, value, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        // Don't use .has(key) - we care about own\n        if (hasProp(this.target_, key)) {\n            // Existing prop\n            if (this.values_.has(key)) {\n                // Observable (can be intercepted)\n                return this.setObservablePropValue_(key, value);\n            } else if (proxyTrap) {\n                // Non-observable - proxy\n                return Reflect.set(this.target_, key, value);\n            } else {\n                // Non-observable\n                this.target_[key] = value;\n                return true;\n            }\n        } else {\n            // New prop\n            return this.extend_(key, {\n                value: value,\n                enumerable: true,\n                writable: true,\n                configurable: true\n            }, this.defaultAnnotation_, proxyTrap);\n        }\n    };\n    _proto.has_ = function has_(key) {\n        if (!globalState.trackingDerivation) {\n            // Skip key subscription outside derivation\n            return key in this.target_;\n        }\n        this.pendingKeys_ || (this.pendingKeys_ = new Map());\n        var entry = this.pendingKeys_.get(key);\n        if (!entry) {\n            entry = new ObservableValue(key in this.target_, referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n            this.pendingKeys_.set(key, entry);\n        }\n        return entry.get();\n    } /**\n   * @param {PropertyKey} key\n   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop\n   */ ;\n    _proto.make_ = function make_(key, annotation) {\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return;\n        }\n        assertAnnotable(this, annotation, key);\n        if (!(key in this.target_)) {\n            var _this$target_$storedA;\n            // Throw on missing key, except for decorators:\n            // Decorator annotations are collected from whole prototype chain.\n            // When called from super() some props may not exist yet.\n            // However we don't have to worry about missing prop,\n            // because the decorator must have been applied to something.\n            if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {\n                return; // will be annotated by subclass constructor\n            } else {\n                die(1, annotation.annotationType_, this.name_ + \".\" + key.toString());\n            }\n        }\n        var source = this.target_;\n        while(source && source !== objectPrototype){\n            var descriptor = getDescriptor(source, key);\n            if (descriptor) {\n                var outcome = annotation.make_(this, key, descriptor, source);\n                if (outcome === 0 /* MakeResult.Cancel */ ) {\n                    return;\n                }\n                if (outcome === 1 /* MakeResult.Break */ ) {\n                    break;\n                }\n            }\n            source = Object.getPrototypeOf(source);\n        }\n        recordAnnotationApplied(this, annotation, key);\n    } /**\n   * @param {PropertyKey} key\n   * @param {PropertyDescriptor} descriptor\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\n   * @param {boolean} proxyTrap whether it's called from proxy trap\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\n   */ ;\n    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return this.defineProperty_(key, descriptor, proxyTrap);\n        }\n        assertAnnotable(this, annotation, key);\n        var outcome = annotation.extend_(this, key, descriptor, proxyTrap);\n        if (outcome) {\n            recordAnnotationApplied(this, annotation, key);\n        }\n        return outcome;\n    } /**\n   * @param {PropertyKey} key\n   * @param {PropertyDescriptor} descriptor\n   * @param {boolean} proxyTrap whether it's called from proxy trap\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\n   */ ;\n    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: descriptor.value\n                });\n                if (!change) {\n                    return null;\n                }\n                var newValue = change.newValue;\n                if (descriptor.value !== newValue) {\n                    descriptor = _extends({}, descriptor, {\n                        value: newValue\n                    });\n                }\n            }\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            // Notify\n            this.notifyPropertyAddition_(key, descriptor.value);\n        } finally{\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: value\n                });\n                if (!change) {\n                    return null;\n                }\n                value = change.newValue;\n            }\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: true,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            var observable = new ObservableValue(value, enhancer,  true ? this.name_ + \".\" + key.toString() : 0, false);\n            this.values_.set(key, observable);\n            // Notify (value possibly changed by ObservableValue)\n            this.notifyPropertyAddition_(key, observable.value_);\n        } finally{\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: undefined\n                });\n                if (!change) {\n                    return null;\n                }\n            }\n            options.name || (options.name =  true ? this.name_ + \".\" + key.toString() : 0);\n            options.context = this.proxy_ || this.target_;\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: false,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            this.values_.set(key, new ComputedValue(options));\n            // Notify\n            this.notifyPropertyAddition_(key, undefined);\n        } finally{\n            endBatch();\n        }\n        return true;\n    } /**\n   * @param {PropertyKey} key\n   * @param {PropertyDescriptor} descriptor\n   * @param {boolean} proxyTrap whether it's called from proxy trap\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\n   */ ;\n    _proto.delete_ = function delete_(key, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        // No such prop\n        if (!hasProp(this.target_, key)) {\n            return true;\n        }\n        // Intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_ || this.target_,\n                name: key,\n                type: REMOVE\n            });\n            // Cancelled\n            if (!change) {\n                return null;\n            }\n        }\n        // Delete\n        try {\n            var _this$pendingKeys_;\n            startBatch();\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var observable = this.values_.get(key);\n            // Value needed for spies/listeners\n            var value = undefined;\n            // Optimization: don't pull the value unless we will need it\n            if (!observable && (notify || notifySpy)) {\n                var _getDescriptor;\n                value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;\n            }\n            // delete prop (do first, may fail)\n            if (proxyTrap) {\n                if (!Reflect.deleteProperty(this.target_, key)) {\n                    return false;\n                }\n            } else {\n                delete this.target_[key];\n            }\n            // Allow re-annotating this field\n            if (true) {\n                delete this.appliedAnnotations_[key];\n            }\n            // Clear observable\n            if (observable) {\n                this.values_[\"delete\"](key);\n                // for computed, value is undefined\n                if (observable instanceof ObservableValue) {\n                    value = observable.value_;\n                }\n                // Notify: autorun(() => obj[key]), see #1796\n                propagateChanged(observable);\n            }\n            // Notify \"keys/entries/values\" observers\n            this.keysAtom_.reportChanged();\n            // Notify \"has\" observers\n            // \"in\" as it may still exist in proto\n            (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);\n            // Notify spies/listeners\n            if (notify || notifySpy) {\n                var _change2 = {\n                    type: REMOVE,\n                    observableKind: \"object\",\n                    object: this.proxy_ || this.target_,\n                    debugObjectName: this.name_,\n                    oldValue: value,\n                    name: key\n                };\n                if ( true && notifySpy) {\n                    spyReportStart(_change2);\n                }\n                if (notify) {\n                    notifyListeners(this, _change2);\n                }\n                if ( true && notifySpy) {\n                    spyReportEnd();\n                }\n            }\n        } finally{\n            endBatch();\n        }\n        return true;\n    } /**\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\n   * for callback details\n   */ ;\n    _proto.observe_ = function observe_(callback, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support the fire immediately property for observable objects.\");\n        }\n        return registerListener(this, callback);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {\n        var _this$pendingKeys_2;\n        var notify = hasListeners(this);\n        var notifySpy =  true && isSpyEnabled();\n        if (notify || notifySpy) {\n            var change = notify || notifySpy ? {\n                type: ADD,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: value\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            }\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);\n        // Notify \"keys/entries/values\" observers\n        this.keysAtom_.reportChanged();\n    };\n    _proto.ownKeys_ = function ownKeys_() {\n        this.keysAtom_.reportObserved();\n        return ownKeys(this.target_);\n    };\n    _proto.keys_ = function keys_() {\n        // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.\n        // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.\n        // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)\n        // We choose to over-report in Object.keys(object), because:\n        // - typically it's used with simple data objects\n        // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected\n        this.keysAtom_.reportObserved();\n        return Object.keys(this.target_);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, options) {\n    var _options$name;\n    if ( true && options && isObservableObject(target)) {\n        die(\"Options can't be provided for already observable objects.\");\n    }\n    if (hasProp(target, $mobx)) {\n        if ( true && !(getAdministration(target) instanceof ObservableObjectAdministration)) {\n            die(\"Cannot convert '\" + getDebugName(target) + \"' into observable object:\" + \"\\nThe target is already observable of different type.\" + \"\\nExtending builtins is not supported.\");\n        }\n        return target;\n    }\n    if ( true && !Object.isExtensible(target)) {\n        die(\"Cannot make the designated object observable; it is not extensible\");\n    }\n    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  true ? (isPlainObject(target) ? \"ObservableObject\" : target.constructor.name) + \"@\" + getNextId() : 0;\n    var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));\n    addHiddenProp(target, $mobx, adm);\n    return target;\n}\nvar isObservableObjectAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction getCachedObservablePropDescriptor(key) {\n    return descriptorCache[key] || (descriptorCache[key] = {\n        get: function get() {\n            return this[$mobx].getObservablePropValue_(key);\n        },\n        set: function set(value) {\n            return this[$mobx].setObservablePropValue_(key, value);\n        }\n    });\n}\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        return isObservableObjectAdministration(thing[$mobx]);\n    }\n    return false;\n}\nfunction recordAnnotationApplied(adm, annotation, key) {\n    var _adm$target_$storedAn;\n    if (true) {\n        adm.appliedAnnotations_[key] = annotation;\n    }\n    // Remove applied decorator annotation so we don't try to apply it again in subclass constructor\n    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];\n}\nfunction assertAnnotable(adm, annotation, key) {\n    // Valid annotation\n    if ( true && !isAnnotation(annotation)) {\n        die(\"Cannot annotate '\" + adm.name_ + \".\" + key.toString() + \"': Invalid annotation.\");\n    }\n    /*\n  // Configurable, not sealed, not frozen\n  // Possibly not needed, just a little better error then the one thrown by engine.\n  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.\n  if (__DEV__) {\n      const configurable = getDescriptor(adm.target_, key)?.configurable\n      const frozen = Object.isFrozen(adm.target_)\n      const sealed = Object.isSealed(adm.target_)\n      if (!configurable || frozen || sealed) {\n          const fieldName = `${adm.name_}.${key.toString()}`\n          const requestedAnnotationType = annotation.annotationType_\n          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`\n          if (frozen) {\n              error += `\\nObject is frozen.`\n          }\n          if (sealed) {\n              error += `\\nObject is sealed.`\n          }\n          if (!configurable) {\n              error += `\\nproperty is not configurable.`\n              // Mention only if caused by us to avoid confusion\n              if (hasProp(adm.appliedAnnotations!, key)) {\n                  error += `\\nTo prevent accidental re-definition of a field by a subclass, `\n                  error += `all annotated fields of non-plain objects (classes) are not configurable.`\n              }\n          }\n          die(error)\n      }\n  }\n  */ // Not annotated\n    if ( true && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {\n        var fieldName = adm.name_ + \".\" + key.toString();\n        var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already annotated with '\" + currentAnnotationType + \"'.\") + \"\\nRe-annotating fields is not allowed.\" + \"\\nUse 'override' annotation for methods overridden by subclass.\");\n    }\n}\n// Bug in safari 9.* (or iOS 9 safari mobile). See #364\nvar ENTRY_0 = /*#__PURE__*/ createArrayEntryDescriptor(0);\nvar safariPrototypeSetterInheritanceBug = /*#__PURE__*/ function() {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", {\n        set: function set() {\n            v = true;\n        }\n    });\n    /*#__PURE__*/ Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\n/**\n * This array buffer contains two lists of properties, so that all arrays\n * can recycle their property definitions, which significantly improves performance of creating\n * properties on the fly.\n */ var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n// Typescript workaround to make sure ObservableArray extends Array\nvar StubArray = function StubArray() {};\nfunction inherit(ctor, proto) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(ctor.prototype, proto);\n    } else if (ctor.prototype.__proto__ !== undefined) {\n        ctor.prototype.__proto__ = proto;\n    } else {\n        ctor.prototype = proto;\n    }\n}\ninherit(StubArray, Array.prototype);\n// Weex proto freeze protection was here,\n// but it is unclear why the hack is need as MobX never changed the prototype\n// anyway, so removed it in V6\nvar LegacyObservableArray = /*#__PURE__*/ function(_StubArray) {\n    function LegacyObservableArray(initialValues, enhancer, name, owned) {\n        var _this;\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : 0;\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        _this = _StubArray.call(this) || this;\n        initObservable(function() {\n            var adm = new ObservableArrayAdministration(name, enhancer, owned, true);\n            adm.proxy_ = _this;\n            addHiddenFinalProp(_this, $mobx, adm);\n            if (initialValues && initialValues.length) {\n                // @ts-ignore\n                _this.spliceWithArray(0, 0, initialValues);\n            }\n            if (safariPrototypeSetterInheritanceBug) {\n                // Seems that Safari won't use numeric prototype setter until any * numeric property is\n                // defined on the instance. After that it works fine, even if this property is deleted.\n                Object.defineProperty(_this, \"0\", ENTRY_0);\n            }\n        });\n        return _this;\n    }\n    _inheritsLoose(LegacyObservableArray, _StubArray);\n    var _proto = LegacyObservableArray.prototype;\n    _proto.concat = function concat() {\n        this[$mobx].atom_.reportObserved();\n        for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){\n            arrays[_key] = arguments[_key];\n        }\n        return Array.prototype.concat.apply(this.slice(), //@ts-ignore\n        arrays.map(function(a) {\n            return isObservableArray(a) ? a.slice() : a;\n        }));\n    };\n    _proto[Symbol.iterator] = function() {\n        var self1 = this;\n        var nextIndex = 0;\n        return makeIterable({\n            next: function next() {\n                return nextIndex < self1.length ? {\n                    value: self1[nextIndex++],\n                    done: false\n                } : {\n                    done: true,\n                    value: undefined\n                };\n            }\n        });\n    };\n    return _createClass(LegacyObservableArray, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this[$mobx].getArrayLength_();\n            },\n            set: function set(newLength) {\n                this[$mobx].setArrayLength_(newLength);\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"Array\";\n            }\n        }\n    ]);\n}(StubArray);\nObject.entries(arrayExtensions).forEach(function(_ref) {\n    var prop = _ref[0], fn = _ref[1];\n    if (prop !== \"concat\") {\n        addHiddenProp(LegacyObservableArray.prototype, prop, fn);\n    }\n});\nfunction createArrayEntryDescriptor(index) {\n    return {\n        enumerable: false,\n        configurable: true,\n        get: function get() {\n            return this[$mobx].get_(index);\n        },\n        set: function set(value) {\n            this[$mobx].set_(index, value);\n        }\n    };\n}\nfunction createArrayBufferItem(index) {\n    defineProperty(LegacyObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index));\n}\nfunction reserveArrayBuffer(max) {\n    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {\n        for(var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++){\n            createArrayBufferItem(index);\n        }\n        OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n    }\n}\nreserveArrayBuffer(1000);\nfunction createLegacyArray(initialValues, enhancer, name) {\n    return new LegacyObservableArray(initialValues, enhancer, name);\n}\nfunction getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            if (property !== undefined) {\n                die(23);\n            }\n            return thing[$mobx].atom_;\n        }\n        if (isObservableSet(thing)) {\n            return thing.atom_;\n        }\n        if (isObservableMap(thing)) {\n            if (property === undefined) {\n                return thing.keysAtom_;\n            }\n            var observable = thing.data_.get(property) || thing.hasMap_.get(property);\n            if (!observable) {\n                die(25, property, getDebugName(thing));\n            }\n            return observable;\n        }\n        if (isObservableObject(thing)) {\n            if (!property) {\n                return die(26);\n            }\n            var _observable = thing[$mobx].values_.get(property);\n            if (!_observable) {\n                die(27, property, getDebugName(thing));\n            }\n            return _observable;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (isFunction(thing)) {\n        if (isReaction(thing[$mobx])) {\n            // disposer function\n            return thing[$mobx];\n        }\n    }\n    die(28);\n}\nfunction getAdministration(thing, property) {\n    if (!thing) {\n        die(29);\n    }\n    if (property !== undefined) {\n        return getAdministration(getAtom(thing, property));\n    }\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n        return thing;\n    }\n    if (isObservableMap(thing) || isObservableSet(thing)) {\n        return thing;\n    }\n    if (thing[$mobx]) {\n        return thing[$mobx];\n    }\n    die(24, thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) {\n        named = getAtom(thing, property);\n    } else if (isAction(thing)) {\n        return thing.name;\n    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {\n        named = getAdministration(thing);\n    } else {\n        // valid for arrays as well\n        named = getAtom(thing);\n    }\n    return named.name_;\n}\n/**\n * Helper function for initializing observable structures, it applies:\n * 1. allowStateChanges so we don't violate enforceActions.\n * 2. untracked so we don't accidentaly subscribe to anything observable accessed during init in case the observable is created inside derivation.\n * 3. batch to avoid state version updates\n */ function initObservable(cb) {\n    var derivation = untrackedStart();\n    var allowStateChanges = allowStateChangesStart(true);\n    startBatch();\n    try {\n        return cb();\n    } finally{\n        endBatch();\n        allowStateChangesEnd(allowStateChanges);\n        untrackedEnd(derivation);\n    }\n}\nvar toString = objectPrototype.toString;\nfunction deepEqual(a, b, depth) {\n    if (depth === void 0) {\n        depth = -1;\n    }\n    return eq(a, b, depth);\n}\n// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289\n// Modified: \"Deep compare objects\" part to iterate over keys in forward order instead of reverse order.\n//\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, depth, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) {\n        return a !== 0 || 1 / a === 1 / b;\n    }\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) {\n        return false;\n    }\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) {\n        return b !== b;\n    }\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== \"function\" && type !== \"object\" && typeof b != \"object\") {\n        return false;\n    }\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) {\n        return false;\n    }\n    switch(className){\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case \"[object RegExp]\":\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case \"[object String]\":\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return \"\" + a === \"\" + b;\n        case \"[object Number]\":\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN.\n            if (+a !== +a) {\n                return +b !== +b;\n            }\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case \"[object Date]\":\n        case \"[object Boolean]\":\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n        case \"[object Symbol]\":\n            return typeof Symbol !== \"undefined\" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);\n        case \"[object Map]\":\n        case \"[object Set]\":\n            // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.\n            // Hide this extra level by increasing the depth.\n            if (depth >= 0) {\n                depth++;\n            }\n            break;\n    }\n    // Unwrap any wrapped objects.\n    a = unwrap(a);\n    b = unwrap(b);\n    var areArrays = className === \"[object Array]\";\n    if (!areArrays) {\n        if (typeof a != \"object\" || typeof b != \"object\") {\n            return false;\n        }\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && \"constructor\" in a && \"constructor\" in b) {\n            return false;\n        }\n    }\n    if (depth === 0) {\n        return false;\n    } else if (depth < 0) {\n        depth = -1;\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while(length--){\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a) {\n            return bStack[length] === b;\n        }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        // Deep compare the contents, ignoring non-numeric properties.\n        while(length--){\n            if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {\n                return false;\n            }\n        }\n    } else {\n        // Deep compare objects.\n        var keys = Object.keys(a);\n        var _length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== _length) {\n            return false;\n        }\n        for(var i = 0; i < _length; i++){\n            // Deep compare each member\n            var key = keys[i];\n            if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {\n                return false;\n            }\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\nfunction unwrap(a) {\n    if (isObservableArray(a)) {\n        return a.slice();\n    }\n    if (isES6Map(a) || isObservableMap(a)) {\n        return Array.from(a.entries());\n    }\n    if (isES6Set(a) || isObservableSet(a)) {\n        return Array.from(a.entries());\n    }\n    return a;\n}\nvar _getGlobal$Iterator;\n// safely get iterator prototype if available\nvar maybeIteratorPrototype = ((_getGlobal$Iterator = /*#__PURE__*/ getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};\nfunction makeIterable(iterator) {\n    iterator[Symbol.iterator] = getSelf;\n    return Object.assign(Object.create(maybeIteratorPrototype), iterator);\n}\nfunction getSelf() {\n    return this;\n}\nfunction isAnnotation(thing) {\n    return(// Can be function\n    thing instanceof Object && typeof thing.annotationType_ === \"string\" && isFunction(thing.make_) && isFunction(thing.extend_));\n}\n/**\n * (c) Michel Weststrate 2015 - 2020\n * MIT Licensed\n *\n * Welcome to the mobx sources! To get a global overview of how MobX internally works,\n * this is a good place to start:\n * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74\n *\n * Source folders:\n * ===============\n *\n * - api/     Most of the public static methods exposed by the module can be found here.\n * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.\n * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.\n * - utils/   Utility stuff.\n *\n */ [\n    \"Symbol\",\n    \"Map\",\n    \"Set\"\n].forEach(function(m) {\n    var g = getGlobal();\n    if (typeof g[m] === \"undefined\") {\n        die(\"MobX requires global '\" + m + \"' to be available or polyfilled\");\n    }\n});\nif (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"object\") {\n    // See: https://github.com/andykog/mobx-devtools/\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({\n        spy: spy,\n        extras: {\n            getDebugName: getDebugName\n        },\n        $mobx: $mobx\n    });\n}\n //# sourceMappingURL=mobx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC9kaXN0L21vYnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsYUFBYTtJQUNmLEdBQUc7SUFDSCxHQUFHLFNBQVNDLEVBQUVDLGNBQWMsRUFBRUMsR0FBRztRQUMvQixPQUFPLG1CQUFtQkQsaUJBQWlCLFdBQVdDLElBQUlDLFFBQVEsS0FBSztJQUN6RTtJQUNBOzs7Ozs7Ozs7O0VBVUEsR0FDQSxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJLFNBQVNILEVBQUVJLEtBQUssRUFBRUMsTUFBTTtRQUMxQixPQUFPLHVDQUF1Q0QsUUFBUSxxQkFBcUJDO0lBQzdFO0lBQ0EsSUFBSTtJQUNKLElBQUksU0FBU0wsRUFBRU0sS0FBSztRQUNsQixPQUFPLDJEQUEyREEsTUFBTUMsV0FBVyxDQUFDQyxJQUFJO0lBQzFGO0lBQ0EsSUFBSSxTQUFTUixFQUFFTSxLQUFLO1FBQ2xCLE9BQU8sZ0NBQWdDQTtJQUN6QztJQUNBLElBQUksU0FBU04sRUFBRVMsYUFBYTtRQUMxQixPQUFPLGlDQUFpQ0EsZ0JBQWdCO0lBQzFEO0lBQ0EsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJLFNBQVNULEVBQUVVLEtBQUs7UUFDbEIsT0FBTyx1Q0FBdUNBO0lBQ2hEO0lBQ0EsSUFBSSxTQUFTVixFQUFFVyxRQUFRLEVBQUVILElBQUk7UUFDM0IsT0FBTyxnQkFBZ0JHLFdBQVcsNkNBQTZDSCxPQUFPO0lBQ3hGO0lBQ0EsSUFBSTtJQUNKLElBQUksU0FBU1IsRUFBRVcsUUFBUSxFQUFFSCxJQUFJO1FBQzNCLE9BQU8sNkJBQTZCRyxTQUFTUixRQUFRLEtBQUssdUNBQXVDSyxPQUFPO0lBQzFHO0lBQ0EsSUFBSSxTQUFTUixFQUFFVSxLQUFLO1FBQ2xCLE9BQU8sNkJBQTZCQTtJQUN0QztJQUNBLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUksU0FBU1YsRUFBRVEsSUFBSSxFQUFFSSxVQUFVO1FBQzdCLE9BQU8sbUNBQW1DSixPQUFPLE9BQU9JO0lBQzFEO0lBQ0EsSUFBSSxTQUFTWixFQUFFUSxJQUFJO1FBQ2pCLE9BQU8sbUNBQW1DQSxPQUFPO0lBQ25EO0lBQ0EsSUFBSSxTQUFTUixFQUFFUSxJQUFJO1FBQ2pCLE9BQU8scUJBQXFCQSxPQUFPO0lBQ3JDO0lBQ0EsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJLFNBQVNSLEVBQUVhLE1BQU07UUFDbkIsT0FBTyw2QkFBNkJBLFNBQVMsa0dBQWtHQSxTQUFTO0lBQzFKO0lBQ0EsSUFBSTtJQUNKLElBQUk7QUFDTjtBQUNBLElBQUlDLFNBQVNDLEtBQXFDLEdBQUdoQixhQUFhLENBQUU7QUFDcEUsU0FBU2lCLElBQUlDLEtBQUs7SUFDaEIsSUFBSyxJQUFJQyxPQUFPQyxVQUFVZCxNQUFNLEVBQUVlLE9BQU8sSUFBSUMsTUFBTUgsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUksT0FBTyxHQUFHQSxPQUFPSixNQUFNSSxPQUFRO1FBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSCxTQUFTLENBQUNHLEtBQUs7SUFDbEM7SUFDQSxJQUFJUCxJQUFxQyxFQUFFO1FBQ3pDLElBQUlRLElBQUksT0FBT04sVUFBVSxXQUFXQSxRQUFRSCxNQUFNLENBQUNHLE1BQU07UUFDekQsSUFBSSxPQUFPTSxNQUFNLFlBQVlBLElBQUlBLEVBQUVDLEtBQUssQ0FBQyxNQUFNSjtRQUMvQyxNQUFNLElBQUlLLE1BQU0sWUFBWUY7SUFDOUI7SUFDQSxNQUFNLElBQUlFLE1BQU0sT0FBT1IsVUFBVSxXQUFXLCtCQUErQkEsUUFBU0csQ0FBQUEsS0FBS2YsTUFBTSxHQUFHLE1BQU1lLEtBQUtNLEdBQUcsQ0FBQ0MsUUFBUUMsSUFBSSxDQUFDLE9BQU8sRUFBQyxJQUFLLG1HQUFtRyxZQUFZWDtBQUM1UDtBQUVBLElBQUlZLGFBQWEsQ0FBQztBQUNsQixTQUFTQztJQUNQLElBQUksT0FBT0MsZUFBZSxhQUFhO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDRCxJQUFJLE9BQU9FLFdBQVcsYUFBYTtRQUNqQyxPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQyxTQUFTLGFBQWE7UUFDL0IsT0FBT0E7SUFDVDtJQUNBLE9BQU9MO0FBQ1Q7QUFFQSxxQ0FBcUM7QUFDckMsSUFBSU0sU0FBU0MsT0FBT0QsTUFBTTtBQUMxQixJQUFJRSxnQkFBZ0JELE9BQU9FLHdCQUF3QjtBQUNuRCxJQUFJQyxpQkFBaUJILE9BQU9HLGNBQWM7QUFDMUMsSUFBSUMsa0JBQWtCSixPQUFPSyxTQUFTO0FBQ3RDLElBQUlDLGNBQWMsRUFBRTtBQUNwQk4sT0FBT08sTUFBTSxDQUFDRDtBQUNkLElBQUlFLGVBQWUsQ0FBQztBQUNwQlIsT0FBT08sTUFBTSxDQUFDQztBQUNkLElBQUlDLFdBQVcsT0FBT0MsVUFBVTtBQUNoQyxJQUFJQyxvQkFBb0IsV0FBVyxHQUFFWCxPQUFPakMsUUFBUTtBQUNwRCxTQUFTNkM7SUFDUCxJQUFJLENBQUNILFVBQVU7UUFDYjdCLElBQUlELEtBQXFDLEdBQUcsOEhBQThILENBQXFCO0lBQ2pNO0FBQ0Y7QUFDQSxTQUFTa0MsMEJBQTBCQyxHQUFHO0lBQ3BDLElBQUluQyxLQUFxQyxJQUFJb0MsWUFBWUMsYUFBYSxFQUFFO1FBQ3RFcEMsSUFBSSxrR0FBa0drQztJQUN4RztBQUNGO0FBQ0EsU0FBU0c7SUFDUCxPQUFPLEVBQUVGLFlBQVlHLFFBQVE7QUFDL0I7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLEtBQUtDLElBQUk7SUFDaEIsSUFBSUMsVUFBVTtJQUNkLE9BQU87UUFDTCxJQUFJQSxTQUFTO1lBQ1g7UUFDRjtRQUNBQSxVQUFVO1FBQ1YsT0FBT0QsS0FBS2hDLEtBQUssQ0FBQyxJQUFJLEVBQUVMO0lBQzFCO0FBQ0Y7QUFDQSxJQUFJdUMsT0FBTyxTQUFTQSxRQUFRO0FBQzVCLFNBQVNDLFdBQVdDLEVBQUU7SUFDcEIsT0FBTyxPQUFPQSxPQUFPO0FBQ3ZCO0FBQ0EsU0FBU0MsWUFBWUMsS0FBSztJQUN4QixJQUFJQyxJQUFJLE9BQU9EO0lBQ2YsT0FBUUM7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxTQUFTRixLQUFLO0lBQ3JCLE9BQU9BLFVBQVUsUUFBUSxPQUFPQSxVQUFVO0FBQzVDO0FBQ0EsU0FBU0csY0FBY0gsS0FBSztJQUMxQixJQUFJLENBQUNFLFNBQVNGLFFBQVE7UUFDcEIsT0FBTztJQUNUO0lBQ0EsSUFBSUksUUFBUTlCLE9BQU8rQixjQUFjLENBQUNMO0lBQ2xDLElBQUlJLFNBQVMsTUFBTTtRQUNqQixPQUFPO0lBQ1Q7SUFDQSxJQUFJRSxtQkFBbUJoQyxPQUFPaUMsY0FBYyxDQUFDQyxJQUFJLENBQUNKLE9BQU8sa0JBQWtCQSxNQUFNM0QsV0FBVztJQUM1RixPQUFPLE9BQU82RCxxQkFBcUIsY0FBY0EsaUJBQWlCakUsUUFBUSxPQUFPNEM7QUFDbkY7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBU3dCLFlBQVlDLEdBQUc7SUFDdEIsSUFBSWpFLGNBQWNpRSxPQUFPLE9BQU8sS0FBSyxJQUFJQSxJQUFJakUsV0FBVztJQUN4RCxJQUFJLENBQUNBLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsSUFBSSx3QkFBd0JBLFlBQVlDLElBQUksSUFBSSx3QkFBd0JELFlBQVlrRSxXQUFXLEVBQUU7UUFDL0YsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU0MsY0FBY0MsTUFBTSxFQUFFQyxRQUFRLEVBQUVkLEtBQUs7SUFDNUN2QixlQUFlb0MsUUFBUUMsVUFBVTtRQUMvQkMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLGNBQWM7UUFDZGpCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNrQixtQkFBbUJMLE1BQU0sRUFBRUMsUUFBUSxFQUFFZCxLQUFLO0lBQ2pEdkIsZUFBZW9DLFFBQVFDLFVBQVU7UUFDL0JDLFlBQVk7UUFDWkMsVUFBVTtRQUNWQyxjQUFjO1FBQ2RqQixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxTQUFTbUIsMEJBQTBCekUsSUFBSSxFQUFFMEUsUUFBUTtJQUMvQyxJQUFJTixXQUFXLFdBQVdwRTtJQUMxQjBFLFNBQVN6QyxTQUFTLENBQUNtQyxTQUFTLEdBQUc7SUFDL0IsT0FBTyxTQUFVTyxDQUFDO1FBQ2hCLE9BQU9uQixTQUFTbUIsTUFBTUEsQ0FBQyxDQUFDUCxTQUFTLEtBQUs7SUFDeEM7QUFDRjtBQUNBOztDQUVDLEdBQ0QsU0FBU1EsU0FBUzFFLEtBQUs7SUFDckIsT0FBT0EsU0FBUyxRQUFRMEIsT0FBT0ssU0FBUyxDQUFDdEMsUUFBUSxDQUFDbUUsSUFBSSxDQUFDNUQsV0FBVztBQUNwRTtBQUNBOztDQUVDLEdBQ0QsU0FBUzJFLGNBQWMzRSxLQUFLO0lBQzFCLElBQUk0RSxXQUFXbEQsT0FBTytCLGNBQWMsQ0FBQ3pEO0lBQ3JDLElBQUk2RSxjQUFjbkQsT0FBTytCLGNBQWMsQ0FBQ21CO0lBQ3hDLElBQUlFLFlBQVlwRCxPQUFPK0IsY0FBYyxDQUFDb0I7SUFDdEMsT0FBT0MsY0FBYztBQUN2QjtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsU0FBUy9FLEtBQUs7SUFDckIsT0FBT0EsU0FBUyxRQUFRMEIsT0FBT0ssU0FBUyxDQUFDdEMsUUFBUSxDQUFDbUUsSUFBSSxDQUFDNUQsV0FBVztBQUNwRTtBQUNBLElBQUlnRiwyQkFBMkIsT0FBT3RELE9BQU91RCxxQkFBcUIsS0FBSztBQUN2RTs7Q0FFQyxHQUNELFNBQVNDLG1CQUFtQmpCLE1BQU07SUFDaEMsSUFBSWtCLE9BQU96RCxPQUFPeUQsSUFBSSxDQUFDbEI7SUFDdkIsMkVBQTJFO0lBQzNFLElBQUksQ0FBQ2UsMEJBQTBCO1FBQzdCLE9BQU9HO0lBQ1Q7SUFDQSxJQUFJQyxVQUFVMUQsT0FBT3VELHFCQUFxQixDQUFDaEI7SUFDM0MsSUFBSSxDQUFDbUIsUUFBUXpGLE1BQU0sRUFBRTtRQUNuQixPQUFPd0Y7SUFDVDtJQUNBLE9BQU8sRUFBRSxDQUFDRSxNQUFNLENBQUNGLE1BQU1DLFFBQVFFLE1BQU0sQ0FBQyxTQUFVQyxDQUFDO1FBQy9DLE9BQU96RCxnQkFBZ0IwRCxvQkFBb0IsQ0FBQzVCLElBQUksQ0FBQ0ssUUFBUXNCO0lBQzNEO0FBQ0Y7QUFDQSxtQkFBbUI7QUFDbkIsOERBQThEO0FBQzlELElBQUlFLFVBQVUsT0FBT0MsWUFBWSxlQUFlQSxRQUFRRCxPQUFPLEdBQUdDLFFBQVFELE9BQU8sR0FBR1QsMkJBQTJCLFNBQVVsQixHQUFHO0lBQzFILE9BQU9wQyxPQUFPaUUsbUJBQW1CLENBQUM3QixLQUFLdUIsTUFBTSxDQUFDM0QsT0FBT3VELHFCQUFxQixDQUFDbkI7QUFDN0UsSUFBSSx3QkFBd0IsR0FBRXBDLE9BQU9pRSxtQkFBbUI7QUFDeEQsU0FBU0MsYUFBYXBHLEdBQUc7SUFDdkIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDM0IsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQzNCLE9BQU9BLElBQUlDLFFBQVE7SUFDckI7SUFDQSxPQUFPLElBQUl3QixPQUFPekIsS0FBS0MsUUFBUTtBQUNqQztBQUNBLFNBQVNvRyxZQUFZekMsS0FBSztJQUN4QixPQUFPQSxVQUFVLE9BQU8sT0FBTyxPQUFPQSxVQUFVLFdBQVcsS0FBS0EsUUFBUUE7QUFDMUU7QUFDQSxTQUFTMEMsUUFBUUMsTUFBTSxFQUFFQyxJQUFJO0lBQzNCLE9BQU9sRSxnQkFBZ0I2QixjQUFjLENBQUNDLElBQUksQ0FBQ21DLFFBQVFDO0FBQ3JEO0FBQ0EsbUJBQW1CO0FBQ25CLElBQUlDLDRCQUE0QnZFLE9BQU91RSx5QkFBeUIsSUFBSSxTQUFTQSwwQkFBMEJGLE1BQU07SUFDM0csdUZBQXVGO0lBQ3ZGLElBQUlHLE1BQU0sQ0FBQztJQUNYLGlFQUFpRTtJQUNqRVQsUUFBUU0sUUFBUUksT0FBTyxDQUFDLFNBQVUzRyxHQUFHO1FBQ25DMEcsR0FBRyxDQUFDMUcsSUFBSSxHQUFHbUMsY0FBY29FLFFBQVF2RztJQUNuQztJQUNBLE9BQU8wRztBQUNUO0FBQ0EsU0FBU0UsUUFBUUMsS0FBSyxFQUFFQyxJQUFJO0lBQzFCLE9BQU8sQ0FBQyxDQUFFRCxDQUFBQSxRQUFRQyxJQUFHO0FBQ3ZCO0FBQ0EsU0FBU0MsUUFBUUYsS0FBSyxFQUFFQyxJQUFJLEVBQUVFLFFBQVE7SUFDcEMsSUFBSUEsVUFBVTtRQUNaSCxTQUFTQztJQUNYLE9BQU87UUFDTEQsU0FBUyxDQUFDQztJQUNaO0lBQ0EsT0FBT0Q7QUFDVDtBQUVBLFNBQVNJLGtCQUFrQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLFNBQVFBLEtBQUtBLElBQUlELEVBQUUvRyxNQUFNLEtBQU1nSCxDQUFBQSxJQUFJRCxFQUFFL0csTUFBTTtJQUM1QyxJQUFLLElBQUlrQixJQUFJLEdBQUcrRixJQUFJakcsTUFBTWdHLElBQUk5RixJQUFJOEYsR0FBRzlGLElBQUsrRixDQUFDLENBQUMvRixFQUFFLEdBQUc2RixDQUFDLENBQUM3RixFQUFFO0lBQ3JELE9BQU8rRjtBQUNUO0FBQ0EsU0FBU0Msa0JBQWtCaEcsQ0FBQyxFQUFFNkYsQ0FBQztJQUM3QixJQUFLLElBQUlyRCxJQUFJLEdBQUdBLElBQUlxRCxFQUFFL0csTUFBTSxFQUFFMEQsSUFBSztRQUNqQyxJQUFJeUQsSUFBSUosQ0FBQyxDQUFDckQsRUFBRTtRQUNaeUQsRUFBRTNDLFVBQVUsR0FBRzJDLEVBQUUzQyxVQUFVLElBQUksQ0FBQyxHQUFHMkMsRUFBRXpDLFlBQVksR0FBRyxDQUFDLEdBQUcsV0FBV3lDLEtBQU1BLENBQUFBLEVBQUUxQyxRQUFRLEdBQUcsQ0FBQyxJQUFJMUMsT0FBT0csY0FBYyxDQUFDaEIsR0FBR2tHLGVBQWVELEVBQUV0SCxHQUFHLEdBQUdzSDtJQUM3STtBQUNGO0FBQ0EsU0FBU0UsYUFBYW5HLENBQUMsRUFBRTZGLENBQUMsRUFBRXJELENBQUM7SUFDM0IsT0FBT3FELEtBQUtHLGtCQUFrQmhHLEVBQUVrQixTQUFTLEVBQUUyRSxJQUFJckQsS0FBS3dELGtCQUFrQmhHLEdBQUd3QyxJQUFJM0IsT0FBT0csY0FBYyxDQUFDaEIsR0FBRyxhQUFhO1FBQ2pIdUQsVUFBVSxDQUFDO0lBQ2IsSUFBSXZEO0FBQ047QUFDQSxTQUFTb0csZ0NBQWdDUCxDQUFDLEVBQUU3RixDQUFDO0lBQzNDLElBQUl3QyxJQUFJLGVBQWUsT0FBTzZELFVBQVVSLENBQUMsQ0FBQ1EsT0FBT0MsUUFBUSxDQUFDLElBQUlULENBQUMsQ0FBQyxhQUFhO0lBQzdFLElBQUlyRCxHQUFHLE9BQU8sQ0FBQ0EsSUFBSUEsRUFBRU8sSUFBSSxDQUFDOEMsRUFBQyxFQUFHVSxJQUFJLENBQUNDLElBQUksQ0FBQ2hFO0lBQ3hDLElBQUkxQyxNQUFNMkcsT0FBTyxDQUFDWixNQUFPckQsQ0FBQUEsSUFBSWtFLDRCQUE0QmIsRUFBQyxLQUFNN0YsS0FBSzZGLEtBQUssWUFBWSxPQUFPQSxFQUFFL0csTUFBTSxFQUFFO1FBQ3JHMEQsS0FBTXFELENBQUFBLElBQUlyRCxDQUFBQTtRQUNWLElBQUl5RCxJQUFJO1FBQ1IsT0FBTztZQUNMLE9BQU9BLEtBQUtKLEVBQUUvRyxNQUFNLEdBQUc7Z0JBQ3JCNkgsTUFBTSxDQUFDO1lBQ1QsSUFBSTtnQkFDRkEsTUFBTSxDQUFDO2dCQUNQcEUsT0FBT3NELENBQUMsQ0FBQ0ksSUFBSTtZQUNmO1FBQ0Y7SUFDRjtJQUNBLE1BQU0sSUFBSVcsVUFBVTtBQUN0QjtBQUNBLFNBQVNDO0lBQ1AsT0FBT0EsV0FBV2hHLE9BQU9ELE1BQU0sR0FBR0MsT0FBT0QsTUFBTSxDQUFDNEYsSUFBSSxLQUFLLFNBQVVULENBQUM7UUFDbEUsSUFBSyxJQUFJL0YsSUFBSSxHQUFHQSxJQUFJSixVQUFVZCxNQUFNLEVBQUVrQixJQUFLO1lBQ3pDLElBQUl3QyxJQUFJNUMsU0FBUyxDQUFDSSxFQUFFO1lBQ3BCLElBQUssSUFBSTZGLEtBQUtyRCxFQUFHLENBQUMsQ0FBQyxHQUFHTSxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR3FELE1BQU9FLENBQUFBLENBQUMsQ0FBQ0YsRUFBRSxHQUFHckQsQ0FBQyxDQUFDcUQsRUFBRTtRQUNqRTtRQUNBLE9BQU9FO0lBQ1QsR0FBR2MsU0FBUzVHLEtBQUssQ0FBQyxNQUFNTDtBQUMxQjtBQUNBLFNBQVNrSCxlQUFldEUsQ0FBQyxFQUFFeUQsQ0FBQztJQUMxQnpELEVBQUV0QixTQUFTLEdBQUdMLE9BQU9rRyxNQUFNLENBQUNkLEVBQUUvRSxTQUFTLEdBQUdzQixFQUFFdEIsU0FBUyxDQUFDbEMsV0FBVyxHQUFHd0QsR0FBR3dFLGdCQUFnQnhFLEdBQUd5RDtBQUM1RjtBQUNBLFNBQVNlLGdCQUFnQnhFLENBQUMsRUFBRXhDLENBQUM7SUFDM0IsT0FBT2dILGtCQUFrQm5HLE9BQU9vRyxjQUFjLEdBQUdwRyxPQUFPb0csY0FBYyxDQUFDVCxJQUFJLEtBQUssU0FBVWhFLENBQUMsRUFBRXhDLENBQUM7UUFDNUYsT0FBT3dDLEVBQUUwRSxTQUFTLEdBQUdsSCxHQUFHd0M7SUFDMUIsR0FBR3dFLGdCQUFnQnhFLEdBQUd4QztBQUN4QjtBQUNBLFNBQVNtSCxhQUFhM0UsQ0FBQyxFQUFFcUQsQ0FBQztJQUN4QixJQUFJLFlBQVksT0FBT3JELEtBQUssQ0FBQ0EsR0FBRyxPQUFPQTtJQUN2QyxJQUFJeEMsSUFBSXdDLENBQUMsQ0FBQzZELE9BQU9yQixXQUFXLENBQUM7SUFDN0IsSUFBSSxLQUFLLE1BQU1oRixHQUFHO1FBQ2hCLElBQUlvSCxJQUFJcEgsRUFBRStDLElBQUksQ0FBQ1AsR0FBR3FELEtBQUs7UUFDdkIsSUFBSSxZQUFZLE9BQU91QixHQUFHLE9BQU9BO1FBQ2pDLE1BQU0sSUFBSVIsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQyxhQUFhZixJQUFJekYsU0FBU2lILE1BQUssRUFBRzdFO0FBQzVDO0FBQ0EsU0FBUzBELGVBQWUxRCxDQUFDO0lBQ3ZCLElBQUk0RSxJQUFJRCxhQUFhM0UsR0FBRztJQUN4QixPQUFPLFlBQVksT0FBTzRFLElBQUlBLElBQUlBLElBQUk7QUFDeEM7QUFDQSxTQUFTViw0QkFBNEJiLENBQUMsRUFBRUMsQ0FBQztJQUN2QyxJQUFJRCxHQUFHO1FBQ0wsSUFBSSxZQUFZLE9BQU9BLEdBQUcsT0FBT0Qsa0JBQWtCQyxHQUFHQztRQUN0RCxJQUFJdEQsSUFBSSxFQUFDLEdBQUU1RCxRQUFRLENBQUNtRSxJQUFJLENBQUM4QyxHQUFHeUIsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUN0QyxPQUFPLGFBQWE5RSxLQUFLcUQsRUFBRTdHLFdBQVcsSUFBS3dELENBQUFBLElBQUlxRCxFQUFFN0csV0FBVyxDQUFDQyxJQUFJLEdBQUcsVUFBVXVELEtBQUssVUFBVUEsSUFBSTFDLE1BQU15SCxJQUFJLENBQUMxQixLQUFLLGdCQUFnQnJELEtBQUssMkNBQTJDZ0YsSUFBSSxDQUFDaEYsS0FBS29ELGtCQUFrQkMsR0FBR0MsS0FBSyxLQUFLO0lBQzVOO0FBQ0Y7QUFFQSxJQUFJMkIsMEJBQTBCLFdBQVcsR0FBRXBCLE9BQU87QUFDbEQ7Ozs7Q0FJQyxHQUNELFNBQVNxQiwwQkFBMEJDLFVBQVU7SUFDM0MsU0FBU0MsVUFBVTFDLE1BQU0sRUFBRTlGLFFBQVE7UUFDakMsSUFBSXlJLGlCQUFpQnpJLFdBQVc7WUFDOUIsT0FBT3VJLFdBQVdHLGVBQWUsQ0FBQzVDLFFBQVE5RjtRQUM1QyxPQUFPO1lBQ0wySSxnQkFBZ0I3QyxRQUFROUYsVUFBVXVJO1FBQ3BDO0lBQ0Y7SUFDQSxPQUFPOUcsT0FBT0QsTUFBTSxDQUFDZ0gsV0FBV0Q7QUFDbEM7QUFDQTs7O0NBR0MsR0FDRCxTQUFTSSxnQkFBZ0I3RyxTQUFTLEVBQUV2QyxHQUFHLEVBQUVnSixVQUFVO0lBQ2pELElBQUksQ0FBQzFDLFFBQVEvRCxXQUFXdUcsMEJBQTBCO1FBQ2hEdEUsY0FBY2pDLFdBQVd1Ryx5QkFBeUJaLFNBQVMsQ0FBQyxHQUFHM0YsU0FBUyxDQUFDdUcsd0JBQXdCO0lBQ25HO0lBQ0Esb0NBQW9DO0lBQ3BDLElBQUlqSSxLQUFxQyxJQUFJd0ksV0FBV0wsZUFBZSxDQUFDMUMsUUFBUS9ELFNBQVMsQ0FBQ3VHLHdCQUF3QixFQUFFOUksTUFBTTtRQUN4SCxJQUFJc0osWUFBWS9HLFVBQVVsQyxXQUFXLENBQUNDLElBQUksR0FBRyxnQkFBZ0JOLElBQUlDLFFBQVE7UUFDekVhLElBQUksTUFBTXdJLFlBQVkscUNBQXFDO0lBQzdEO0lBQ0EscUJBQXFCO0lBQ3JCQyxtQkFBbUJoSCxXQUFXeUcsWUFBWWhKO0lBQzFDLGtCQUFrQjtJQUNsQixJQUFJLENBQUNxSixXQUFXTCxhQUFhO1FBQzNCekcsU0FBUyxDQUFDdUcsd0JBQXdCLENBQUM5SSxJQUFJLEdBQUdnSjtJQUM1QztBQUNGO0FBQ0EsU0FBU08sbUJBQW1CaEgsU0FBUyxFQUFFeUcsVUFBVSxFQUFFaEosR0FBRztJQUNwRCxJQUFJYSxLQUFxQyxJQUFJLENBQUN3SSxXQUFXTCxlQUFlMUMsUUFBUS9ELFNBQVMsQ0FBQ3VHLHdCQUF3QixFQUFFOUksTUFBTTtRQUN4SCxJQUFJc0osWUFBWS9HLFVBQVVsQyxXQUFXLENBQUNDLElBQUksR0FBRyxnQkFBZ0JOLElBQUlDLFFBQVE7UUFDekUsSUFBSXVKLHdCQUF3QmpILFNBQVMsQ0FBQ3VHLHdCQUF3QixDQUFDOUksSUFBSSxDQUFDeUosZUFBZTtRQUNuRixJQUFJQywwQkFBMEJWLFdBQVdTLGVBQWU7UUFDeEQzSSxJQUFJLG9CQUFvQjRJLDBCQUEwQixXQUFXSixZQUFZLE9BQVEsOENBQTZDRSx3QkFBd0IsSUFBRyxJQUFLLDJDQUEyQztJQUMzTTtBQUNGO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRyx5QkFBeUJwRCxNQUFNO0lBQ3RDLElBQUksQ0FBQ0QsUUFBUUMsUUFBUXVDLDBCQUEwQjtRQUM3QyxxREFBcUQ7UUFDckQsV0FBVztRQUNYLDBHQUEwRztRQUMxRyxRQUFRO1FBQ1IsSUFBSTtRQUNKLCtFQUErRTtRQUMvRXRFLGNBQWMrQixRQUFRdUMseUJBQXlCWixTQUFTLENBQUMsR0FBRzNCLE1BQU0sQ0FBQ3VDLHdCQUF3QjtJQUM3RjtJQUNBLE9BQU92QyxNQUFNLENBQUN1Qyx3QkFBd0I7QUFDeEM7QUFDQSxTQUFTSSxpQkFBaUJVLE9BQU87SUFDL0IsT0FBTyxPQUFPQSxXQUFXLFlBQVksT0FBT0EsT0FBTyxDQUFDLE9BQU8sSUFBSTtBQUNqRTtBQUNBLFNBQVNDLHlCQUF5QkQsT0FBTyxFQUFFRSxLQUFLO0lBQzlDLElBQUlqSixLQUFxQyxJQUFJLENBQUNpSixNQUFNQyxRQUFRLENBQUNILFFBQVFJLElBQUksR0FBRztRQUMxRWxKLElBQUksK0JBQStCVyxPQUFPbUksUUFBUXRKLElBQUksSUFBSSwyQkFBMkJzSixRQUFRSSxJQUFJLEdBQUc7SUFDdEc7QUFDRjtBQUVBLElBQUlDLFFBQVEsV0FBVyxHQUFFdkMsT0FBTztBQUNoQyxJQUFJd0MsT0FBTyxXQUFXLEdBQUU7SUFDdEI7OztHQUdDLEdBQ0QsU0FBU0EsS0FBS0MsS0FBSztRQUNqQixJQUFJQSxVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUXRKLEtBQXFDLEdBQUcsVUFBVXNDLGNBQWMsQ0FBTTtRQUNoRjtRQUNBLElBQUksQ0FBQ2dILEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSUM7UUFDdEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBR0Msa0JBQWtCQyxhQUFhO1FBQzNELDRCQUE0QjtRQUM1QixJQUFJLENBQUNDLEtBQUssR0FBRyxLQUFLO1FBQ2xCLDhCQUE4QjtRQUM5QixJQUFJLENBQUNDLE1BQU0sR0FBRyxLQUFLO1FBQ25CLElBQUksQ0FBQ1QsS0FBSyxHQUFHQTtJQUNmO0lBQ0EsNklBQTZJO0lBQzdJLElBQUlVLFNBQVNYLEtBQUszSCxTQUFTO0lBQzNCc0ksT0FBT0MsSUFBSSxHQUFHLFNBQVNBO1FBQ3JCLElBQUksSUFBSSxDQUFDSCxLQUFLLEVBQUU7WUFDZCxJQUFJLENBQUNBLEtBQUssQ0FBQ2hFLE9BQU8sQ0FBQyxTQUFVb0UsUUFBUTtnQkFDbkMsT0FBT0E7WUFDVDtRQUNGO0lBQ0Y7SUFDQUYsT0FBT0csS0FBSyxHQUFHLFNBQVNBO1FBQ3RCLElBQUksSUFBSSxDQUFDSixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ2pFLE9BQU8sQ0FBQyxTQUFVb0UsUUFBUTtnQkFDcEMsT0FBT0E7WUFDVDtRQUNGO0lBQ0YsRUFDQTs7O0dBR0M7SUFDREYsT0FBT0ksY0FBYyxHQUFHLFNBQVNDO1FBQy9CLE9BQU9ELGVBQWUsSUFBSTtJQUM1QixFQUNBOztHQUVDO0lBQ0RKLE9BQU9NLGFBQWEsR0FBRyxTQUFTQTtRQUM5QkM7UUFDQUMsaUJBQWlCLElBQUk7UUFDckJDO0lBQ0Y7SUFDQVQsT0FBTzVLLFFBQVEsR0FBRyxTQUFTQTtRQUN6QixPQUFPLElBQUksQ0FBQ2tLLEtBQUs7SUFDbkI7SUFDQSxPQUFPM0MsYUFBYTBDLE1BQU07UUFBQztZQUN6QmxLLEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFRixLQUFLc0Isb0JBQW9CO1lBQ3ZEO1lBQ0FDLEtBQUssU0FBU0EsSUFBSXpFLFFBQVE7Z0JBQ3hCLElBQUksQ0FBQ29ELE1BQU0sR0FBR3JELFFBQVEsSUFBSSxDQUFDcUQsTUFBTSxFQUFFRixLQUFLc0Isb0JBQW9CLEVBQUV4RTtZQUNoRTtRQUNGO1FBQUc7WUFDRGhILEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFRixLQUFLd0IsMkJBQTJCO1lBQzlEO1lBQ0FELEtBQUssU0FBU0EsSUFBSXpFLFFBQVE7Z0JBQ3hCLElBQUksQ0FBQ29ELE1BQU0sR0FBR3JELFFBQVEsSUFBSSxDQUFDcUQsTUFBTSxFQUFFRixLQUFLd0IsMkJBQTJCLEVBQUUxRTtZQUN2RTtRQUNGO1FBQUc7WUFDRGhILEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFRixLQUFLeUIsY0FBYyxJQUFJLElBQUk7WUFDekQ7WUFDQUYsS0FBSyxTQUFTQSxJQUFJekUsUUFBUTtnQkFDeEIsSUFBSSxDQUFDb0QsTUFBTSxHQUFHckQsUUFBUSxJQUFJLENBQUNxRCxNQUFNLEVBQUVGLEtBQUt5QixjQUFjLEVBQUUzRSxhQUFhLElBQUksT0FBTztZQUNsRjtRQUNGO0tBQUU7QUFDSjtBQUNBa0QsS0FBS3NCLG9CQUFvQixHQUFHO0FBQzVCdEIsS0FBS3dCLDJCQUEyQixHQUFHO0FBQ25DeEIsS0FBS3lCLGNBQWMsR0FBRztBQUN0QixJQUFJQyxTQUFTLFdBQVcsR0FBRTdHLDBCQUEwQixRQUFRbUY7QUFDNUQsU0FBUzJCLFdBQVd2TCxJQUFJLEVBQUV3TCx1QkFBdUIsRUFBRUMseUJBQXlCO0lBQzFFLElBQUlELDRCQUE0QixLQUFLLEdBQUc7UUFDdENBLDBCQUEwQnRJO0lBQzVCO0lBQ0EsSUFBSXVJLDhCQUE4QixLQUFLLEdBQUc7UUFDeENBLDRCQUE0QnZJO0lBQzlCO0lBQ0EsSUFBSXdJLE9BQU8sSUFBSTlCLEtBQUs1SjtJQUNwQiwyREFBMkQ7SUFDM0QsSUFBSXdMLDRCQUE0QnRJLE1BQU07UUFDcEN5SSxpQkFBaUJELE1BQU1GO0lBQ3pCO0lBQ0EsSUFBSUMsOEJBQThCdkksTUFBTTtRQUN0QzBJLG1CQUFtQkYsTUFBTUQ7SUFDM0I7SUFDQSxPQUFPQztBQUNUO0FBRUEsU0FBU0csaUJBQWlCaEYsQ0FBQyxFQUFFaUYsQ0FBQztJQUM1QixPQUFPakYsTUFBTWlGO0FBQ2Y7QUFDQSxTQUFTQyxtQkFBbUJsRixDQUFDLEVBQUVpRixDQUFDO0lBQzlCLE9BQU9FLFVBQVVuRixHQUFHaUY7QUFDdEI7QUFDQSxTQUFTRyxnQkFBZ0JwRixDQUFDLEVBQUVpRixDQUFDO0lBQzNCLE9BQU9FLFVBQVVuRixHQUFHaUYsR0FBRztBQUN6QjtBQUNBLFNBQVNJLGdCQUFnQnJGLENBQUMsRUFBRWlGLENBQUM7SUFDM0IsSUFBSWxLLE9BQU91SyxFQUFFLEVBQUU7UUFDYixPQUFPdkssT0FBT3VLLEVBQUUsQ0FBQ3RGLEdBQUdpRjtJQUN0QjtJQUNBLE9BQU9qRixNQUFNaUYsSUFBSWpGLE1BQU0sS0FBSyxJQUFJQSxNQUFNLElBQUlpRixJQUFJakYsTUFBTUEsS0FBS2lGLE1BQU1BO0FBQ2pFO0FBQ0EsSUFBSU0sV0FBVztJQUNiQyxVQUFVUjtJQUNWUyxZQUFZUDtJQUNaLFdBQVdHO0lBQ1hLLFNBQVNOO0FBQ1g7QUFFQSxTQUFTTyxhQUFhQyxDQUFDLEVBQUVqTixDQUFDLEVBQUVRLElBQUk7SUFDOUIsb0NBQW9DO0lBQ3BDLElBQUkwTSxhQUFhRCxJQUFJO1FBQ25CLE9BQU9BO0lBQ1Q7SUFDQSwrQ0FBK0M7SUFDL0MsSUFBSTVMLE1BQU0yRyxPQUFPLENBQUNpRixJQUFJO1FBQ3BCLE9BQU9FLFdBQVdDLEtBQUssQ0FBQ0gsR0FBRztZQUN6QnpNLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLElBQUl5RCxjQUFjZ0osSUFBSTtRQUNwQixPQUFPRSxXQUFXeEksTUFBTSxDQUFDc0ksR0FBR0ksV0FBVztZQUNyQzdNLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLElBQUk0RSxTQUFTNkgsSUFBSTtRQUNmLE9BQU9FLFdBQVd6TCxHQUFHLENBQUN1TCxHQUFHO1lBQ3ZCek0sTUFBTUE7UUFDUjtJQUNGO0lBQ0EsSUFBSWlGLFNBQVN3SCxJQUFJO1FBQ2YsT0FBT0UsV0FBV3hCLEdBQUcsQ0FBQ3NCLEdBQUc7WUFDdkJ6TSxNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFJLE9BQU95TSxNQUFNLGNBQWMsQ0FBQ0ssU0FBU0wsTUFBTSxDQUFDTSxPQUFPTixJQUFJO1FBQ3pELElBQUkxSSxZQUFZMEksSUFBSTtZQUNsQixPQUFPTyxLQUFLUDtRQUNkLE9BQU87WUFDTCxPQUFPUSxXQUFXak4sTUFBTXlNO1FBQzFCO0lBQ0Y7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU1MsZ0JBQWdCVCxDQUFDLEVBQUVqTixDQUFDLEVBQUVRLElBQUk7SUFDakMsSUFBSXlNLE1BQU1JLGFBQWFKLE1BQU0sTUFBTTtRQUNqQyxPQUFPQTtJQUNUO0lBQ0EsSUFBSVUsbUJBQW1CVixNQUFNVyxrQkFBa0JYLE1BQU1ZLGdCQUFnQlosTUFBTWEsZ0JBQWdCYixJQUFJO1FBQzdGLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJNUwsTUFBTTJHLE9BQU8sQ0FBQ2lGLElBQUk7UUFDcEIsT0FBT0UsV0FBV0MsS0FBSyxDQUFDSCxHQUFHO1lBQ3pCek0sTUFBTUE7WUFDTnVOLE1BQU07UUFDUjtJQUNGO0lBQ0EsSUFBSTlKLGNBQWNnSixJQUFJO1FBQ3BCLE9BQU9FLFdBQVd4SSxNQUFNLENBQUNzSSxHQUFHSSxXQUFXO1lBQ3JDN00sTUFBTUE7WUFDTnVOLE1BQU07UUFDUjtJQUNGO0lBQ0EsSUFBSTNJLFNBQVM2SCxJQUFJO1FBQ2YsT0FBT0UsV0FBV3pMLEdBQUcsQ0FBQ3VMLEdBQUc7WUFDdkJ6TSxNQUFNQTtZQUNOdU4sTUFBTTtRQUNSO0lBQ0Y7SUFDQSxJQUFJdEksU0FBU3dILElBQUk7UUFDZixPQUFPRSxXQUFXeEIsR0FBRyxDQUFDc0IsR0FBRztZQUN2QnpNLE1BQU1BO1lBQ051TixNQUFNO1FBQ1I7SUFDRjtJQUNBLElBQUloTixJQUFxQyxFQUFFO1FBQ3pDQyxJQUFJO0lBQ047QUFDRjtBQUNBLFNBQVNnTixrQkFBa0I5RyxRQUFRO0lBQ2pDLGdDQUFnQztJQUNoQyxPQUFPQTtBQUNUO0FBQ0EsU0FBUytHLGtCQUFrQmhCLENBQUMsRUFBRWlCLFFBQVE7SUFDcEMsSUFBSW5OLEtBQXFDLElBQUltTSxhQUFhRCxJQUFJO1FBQzVEak0sSUFBSTtJQUNOO0lBQ0EsSUFBSXdMLFVBQVVTLEdBQUdpQixXQUFXO1FBQzFCLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPakI7QUFDVDtBQUVBLElBQUlrQixXQUFXO0FBQ2YsSUFBSUMsV0FBVyxXQUFXLEdBQUVuRiwwQkFBMEI7SUFDcERVLGlCQUFpQndFO0lBQ2pCRSxPQUFPQTtJQUNQQyxTQUFTQTtJQUNUakYsaUJBQWlCQTtBQUNuQjtBQUNBLFNBQVNFLFdBQVdMLFVBQVU7SUFDNUIsT0FBT0EsV0FBV1MsZUFBZSxLQUFLd0U7QUFDeEM7QUFDQSxTQUFTRSxNQUFNRSxHQUFHLEVBQUVyTyxHQUFHO0lBQ3JCLDJCQUEyQjtJQUMzQixJQUFJYSxLQUFxQyxJQUFJd04sSUFBSUMsY0FBYyxFQUFFO1FBQy9EeE4sSUFBSSxtQkFBbUIsSUFBSSxDQUFDMkksZUFBZSxHQUFHLFdBQVc0RSxJQUFJbEUsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRLEtBQUssT0FBUSxTQUFRLElBQUksQ0FBQ3dKLGVBQWUsR0FBRyxvQ0FBbUM7SUFDeEs7SUFDQSwwQkFBMEI7SUFDMUIsSUFBSTVJLEtBQXFDLElBQUksQ0FBQ3lGLFFBQVErSCxJQUFJRSxtQkFBbUIsRUFBRXZPLE1BQU07UUFDbkZjLElBQUksTUFBTXVOLElBQUlsRSxLQUFLLEdBQUcsTUFBTW5LLElBQUlDLFFBQVEsS0FBSywwQkFBMEIsSUFBSSxDQUFDd0osZUFBZSxHQUFHLFFBQVE7SUFDeEc7SUFDQSxPQUFPLEVBQUUscUJBQXFCO0FBQ2hDO0FBQ0EsU0FBUzJFLFFBQVFDLEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVUsRUFBRUMsU0FBUztJQUM5QzNOLElBQUksTUFBTSxJQUFJLENBQUMySSxlQUFlLEdBQUc7QUFDbkM7QUFDQSxTQUFTTixnQkFBZ0J1RixJQUFJLEVBQUU5RSxPQUFPO0lBQ3BDK0UsUUFBUUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDbkYsZUFBZSxHQUFHO0FBQzVDO0FBRUEsU0FBU29GLHVCQUF1QnZPLElBQUksRUFBRXdPLE9BQU87SUFDM0MsT0FBTztRQUNMckYsaUJBQWlCbko7UUFDakJ5TyxVQUFVRDtRQUNWWCxPQUFPYTtRQUNQWixTQUFTYTtRQUNUOUYsaUJBQWlCK0Y7SUFDbkI7QUFDRjtBQUNBLFNBQVNGLFFBQVFYLEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVUsRUFBRVcsTUFBTTtJQUMzQyxJQUFJQztJQUNKLFFBQVE7SUFDUixJQUFJLENBQUNBLGlCQUFpQixJQUFJLENBQUNMLFFBQVEsS0FBSyxRQUFRSyxlQUFlQyxLQUFLLEVBQUU7UUFDcEUsT0FBTyxJQUFJLENBQUNqQixPQUFPLENBQUNDLEtBQUtyTyxLQUFLd08sWUFBWSxXQUFXLE9BQU8sRUFBRSxxQkFBcUIsTUFBSyxFQUFFLG9CQUFvQjtJQUNoSDtJQUNBLE1BQU07SUFDTixJQUFJVyxXQUFXZCxJQUFJaUIsT0FBTyxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDbEIsT0FBTyxDQUFDQyxLQUFLck8sS0FBS3dPLFlBQVksV0FBVyxPQUFPLEVBQUUscUJBQXFCLE1BQUssRUFBRSx1QkFBdUI7SUFDbkg7SUFDQSxZQUFZO0lBQ1osSUFBSXBCLFNBQVNvQixXQUFXNUssS0FBSyxHQUFHO1FBQzlCLHNFQUFzRTtRQUN0RSxvREFBb0Q7UUFDcEQsT0FBTyxFQUFFLG9CQUFvQjtJQUMvQjtJQUNBLElBQUkyTCxtQkFBbUJDLHVCQUF1Qm5CLEtBQUssSUFBSSxFQUFFck8sS0FBS3dPLFlBQVk7SUFDMUVuTSxlQUFlOE0sUUFBUW5QLEtBQUt1UDtJQUM1QixPQUFPLEVBQUUsdUJBQXVCO0FBQ2xDO0FBQ0EsU0FBU04sVUFBVVosR0FBRyxFQUFFck8sR0FBRyxFQUFFd08sVUFBVSxFQUFFQyxTQUFTO0lBQ2hELElBQUljLG1CQUFtQkMsdUJBQXVCbkIsS0FBSyxJQUFJLEVBQUVyTyxLQUFLd087SUFDOUQsT0FBT0gsSUFBSW9CLGVBQWUsQ0FBQ3pQLEtBQUt1UCxrQkFBa0JkO0FBQ3BEO0FBQ0EsU0FBU1Msa0JBQWtCUSxJQUFJLEVBQUU5RixPQUFPO0lBQ3RDLElBQUkvSSxJQUFxQyxFQUFFO1FBQ3pDZ0oseUJBQXlCRCxTQUFTO1lBQUM7WUFBVTtTQUFRO0lBQ3ZEO0lBQ0EsSUFBSUksT0FBT0osUUFBUUksSUFBSSxFQUNyQjFKLE9BQU9zSixRQUFRdEosSUFBSSxFQUNuQnFQLGlCQUFpQi9GLFFBQVErRixjQUFjO0lBQ3pDLElBQUlDLE1BQU0sSUFBSTtJQUNkLElBQUlDLGdCQUFnQixTQUFTQSxjQUFjQyxDQUFDO1FBQzFDLElBQUlDLG9CQUFvQkMsZUFBZUMsdUJBQXVCQztRQUM5RCxPQUFPQyxhQUFhLENBQUNKLHFCQUFxQixDQUFDQyxnQkFBZ0JKLElBQUliLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSWlCLGNBQWMxUCxJQUFJLEtBQUssT0FBT3lQLHFCQUFxQnpQLEtBQUtMLFFBQVEsSUFBSTZQLEdBQUcsQ0FBQ0csd0JBQXdCLENBQUNDLGlCQUFpQk4sSUFBSWIsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJbUIsZUFBZTNDLFVBQVUsS0FBSyxPQUFPMEMsd0JBQXdCO0lBQzlTO0lBQ0EsSUFBSWpHLFFBQVEsU0FBUztRQUNuQixPQUFPLFNBQVVvRyxRQUFRO1lBQ3ZCLElBQUlDO1lBQ0osSUFBSVgsT0FBT1U7WUFDWCxJQUFJLENBQUNoRCxTQUFTc0MsT0FBTztnQkFDbkJBLE9BQU9HLGNBQWNIO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDVyxpQkFBaUJULElBQUliLFFBQVEsS0FBSyxRQUFRc0IsZUFBZWhCLEtBQUssRUFBRTtnQkFDbkVLLE9BQU9BLEtBQUs3SCxJQUFJLENBQUMsSUFBSTtnQkFDckI2SCxLQUFLWSxZQUFZLEdBQUc7WUFDdEI7WUFDQSxPQUFPWjtRQUNUO0lBQ0Y7SUFDQSxJQUFJMUYsUUFBUSxVQUFVO1FBQ3BCLElBQUl1RztRQUNKLElBQUksQ0FBQ25ELFNBQVNzQyxPQUFPO1lBQ25CQSxPQUFPRyxjQUFjSDtRQUN2QjtRQUNBLElBQUksQ0FBQ2Esa0JBQWtCLElBQUksQ0FBQ3hCLFFBQVEsS0FBSyxRQUFRd0IsZ0JBQWdCbEIsS0FBSyxFQUFFO1lBQ3RFTSxlQUFlO2dCQUNiLElBQUkzTixRQUFPLElBQUk7Z0JBQ2YsSUFBSXFOLFFBQVFyTixLQUFJLENBQUMxQixLQUFLLENBQUN1SCxJQUFJLENBQUM3RjtnQkFDNUJxTixNQUFNaUIsWUFBWSxHQUFHO2dCQUNyQnRPLEtBQUksQ0FBQzFCLEtBQUssR0FBRytPO1lBQ2Y7UUFDRjtRQUNBLE9BQU9LO0lBQ1Q7SUFDQTVPLElBQUksbUJBQW1COE8sSUFBSW5HLGVBQWUsR0FBRyxXQUFXaEksT0FBT25CLFFBQVEsY0FBYzBKLE9BQU8sT0FBUSxTQUFRNEYsSUFBSW5HLGVBQWUsR0FBRyx5REFBd0Q7QUFDNUw7QUFDQSxTQUFTK0csdUJBQXVCbkMsR0FBRyxFQUFFb0MsSUFBSSxFQUFFelEsR0FBRyxFQUFFMFEsS0FBSztJQUNuRCxJQUFJakgsa0JBQWtCZ0gsS0FBS2hILGVBQWU7SUFDMUMsSUFBSTdGLFFBQVE4TSxNQUFNOU0sS0FBSztJQUN2QixJQUFJL0MsS0FBcUMsSUFBSSxDQUFDNEMsV0FBV0csUUFBUTtRQUMvRDlDLElBQUksbUJBQW1CMkksa0JBQWtCLFdBQVc0RSxJQUFJbEUsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRLEtBQUssT0FBUSxTQUFRd0osa0JBQWtCLHlEQUF3RDtJQUNuTDtBQUNGO0FBQ0EsU0FBUytGLHVCQUF1Qm5CLEdBQUcsRUFBRXJGLFVBQVUsRUFBRWhKLEdBQUcsRUFBRXdPLFVBQVUsRUFDaEUsNkRBQTZEO0FBQzdEbUMsZUFBZTtJQUNiLElBQUlDLHNCQUFzQkMsdUJBQXVCQyx1QkFBdUJDLHdCQUF3QkMsdUJBQXVCQyx1QkFBdUJDO0lBQzlJLElBQUlQLG9CQUFvQixLQUFLLEdBQUc7UUFDOUJBLGtCQUFrQjFOLFlBQVkwTixlQUFlO0lBQy9DO0lBQ0FILHVCQUF1Qm5DLEtBQUtyRixZQUFZaEosS0FBS3dPO0lBQzdDLElBQUk1SyxRQUFRNEssV0FBVzVLLEtBQUs7SUFDNUIsSUFBSSxDQUFDZ04sdUJBQXVCNUgsV0FBVytGLFFBQVEsS0FBSyxRQUFRNkIscUJBQXFCdkIsS0FBSyxFQUFFO1FBQ3RGLElBQUk4QjtRQUNKdk4sUUFBUUEsTUFBTWlFLElBQUksQ0FBQyxDQUFDc0osY0FBYzlDLElBQUkrQyxNQUFNLEtBQUssT0FBT0QsY0FBYzlDLElBQUlpQixPQUFPO0lBQ25GO0lBQ0EsT0FBTztRQUNMMUwsT0FBT3VNLGFBQWEsQ0FBQ1Usd0JBQXdCLENBQUNDLHdCQUF3QjlILFdBQVcrRixRQUFRLEtBQUssT0FBTyxLQUFLLElBQUkrQixzQkFBc0J4USxJQUFJLEtBQUssT0FBT3VRLHdCQUF3QjdRLElBQUlDLFFBQVEsSUFBSTJELE9BQU8sQ0FBQ21OLHlCQUF5QixDQUFDQyx3QkFBd0JoSSxXQUFXK0YsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJaUMsc0JBQXNCekQsVUFBVSxLQUFLLE9BQU93RCx5QkFBeUIsT0FFblcsa0RBRGtEO1FBQ2pERSxDQUFBQSx3QkFBd0JqSSxXQUFXK0YsUUFBUSxLQUFLLFFBQVFrQyxzQkFBc0I1QixLQUFLLEdBQUcsQ0FBQzZCLGVBQWU3QyxJQUFJK0MsTUFBTSxLQUFLLE9BQU9GLGVBQWU3QyxJQUFJaUIsT0FBTyxHQUFHbkM7UUFDMUosK0JBQStCO1FBQy9CLHFEQUFxRDtRQUNyRHRJLGNBQWM4TCxrQkFBa0J0QyxJQUFJQyxjQUFjLEdBQUc7UUFDckQsa0VBQWtFO1FBQ2xFM0osWUFBWTtRQUNaLHdDQUF3QztRQUN4QyxrREFBa0Q7UUFDbERDLFVBQVUrTCxrQkFBa0IsUUFBUTtJQUN0QztBQUNGO0FBRUEsU0FBU1UscUJBQXFCL1EsSUFBSSxFQUFFd08sT0FBTztJQUN6QyxPQUFPO1FBQ0xyRixpQkFBaUJuSjtRQUNqQnlPLFVBQVVEO1FBQ1ZYLE9BQU9tRDtRQUNQbEQsU0FBU21EO1FBQ1RwSSxpQkFBaUJxSTtJQUNuQjtBQUNGO0FBQ0EsU0FBU0YsUUFBUWpELEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVUsRUFBRVcsTUFBTTtJQUMzQyxJQUFJQztJQUNKLE1BQU07SUFDTixJQUFJRCxXQUFXZCxJQUFJaUIsT0FBTyxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDbEIsT0FBTyxDQUFDQyxLQUFLck8sS0FBS3dPLFlBQVksV0FBVyxPQUFPLEVBQUUscUJBQXFCLE1BQUssRUFBRSx1QkFBdUI7SUFDbkg7SUFDQSxZQUFZO0lBQ1osdURBQXVEO0lBQ3ZELElBQUksQ0FBQ1ksaUJBQWlCLElBQUksQ0FBQ0wsUUFBUSxLQUFLLFFBQVFLLGVBQWVDLEtBQUssSUFBSyxFQUFDL0ksUUFBUStILElBQUlpQixPQUFPLEVBQUV0UCxRQUFRLENBQUNxTixPQUFPZ0IsSUFBSWlCLE9BQU8sQ0FBQ3RQLElBQUksSUFBSTtRQUNqSSxJQUFJLElBQUksQ0FBQ29PLE9BQU8sQ0FBQ0MsS0FBS3JPLEtBQUt3TyxZQUFZLFdBQVcsTUFBTTtZQUN0RCxPQUFPLEVBQUUscUJBQXFCO1FBQ2hDO0lBQ0Y7SUFDQSxJQUFJbkIsT0FBT21CLFdBQVc1SyxLQUFLLEdBQUc7UUFDNUIsc0VBQXNFO1FBQ3RFLG9EQUFvRDtRQUNwRCxPQUFPLEVBQUUsb0JBQW9CO0lBQy9CO0lBQ0EsSUFBSTZOLGlCQUFpQkMscUJBQXFCckQsS0FBSyxJQUFJLEVBQUVyTyxLQUFLd08sWUFBWSxPQUFPO0lBQzdFbk0sZUFBZThNLFFBQVFuUCxLQUFLeVI7SUFDNUIsT0FBTyxFQUFFLHVCQUF1QjtBQUNsQztBQUNBLFNBQVNGLFVBQVVsRCxHQUFHLEVBQUVyTyxHQUFHLEVBQUV3TyxVQUFVLEVBQUVDLFNBQVM7SUFDaEQsSUFBSThCO0lBQ0osSUFBSWtCLGlCQUFpQkMscUJBQXFCckQsS0FBSyxJQUFJLEVBQUVyTyxLQUFLd08sWUFBWSxDQUFDK0Isa0JBQWtCLElBQUksQ0FBQ3hCLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSXdCLGdCQUFnQmxCLEtBQUs7SUFDaEosT0FBT2hCLElBQUlvQixlQUFlLENBQUN6UCxLQUFLeVIsZ0JBQWdCaEQ7QUFDbEQ7QUFDQSxTQUFTK0Msa0JBQWtCOUIsSUFBSSxFQUFFOUYsT0FBTztJQUN0QyxJQUFJK0g7SUFDSixJQUFJOVEsSUFBcUMsRUFBRTtRQUN6Q2dKLHlCQUF5QkQsU0FBUztZQUFDO1NBQVM7SUFDOUM7SUFDQSxJQUFJdEosT0FBT3NKLFFBQVF0SixJQUFJLEVBQ3JCcVAsaUJBQWlCL0YsUUFBUStGLGNBQWM7SUFDekMsSUFBSSxDQUFDdEMsT0FBT3FDLE9BQU87UUFDakJBLE9BQU9wQyxLQUFLb0M7SUFDZDtJQUNBLElBQUksQ0FBQ2lDLGtCQUFrQixJQUFJLENBQUM1QyxRQUFRLEtBQUssUUFBUTRDLGdCQUFnQnRDLEtBQUssRUFBRTtRQUN0RU0sZUFBZTtZQUNiLElBQUkzTixRQUFPLElBQUk7WUFDZixJQUFJcU4sUUFBUXJOLEtBQUksQ0FBQzFCLEtBQUssQ0FBQ3VILElBQUksQ0FBQzdGO1lBQzVCcU4sTUFBTXVDLFVBQVUsR0FBRztZQUNuQjVQLEtBQUksQ0FBQzFCLEtBQUssR0FBRytPO1FBQ2Y7SUFDRjtJQUNBLE9BQU9LO0FBQ1Q7QUFDQSxTQUFTbUMscUJBQXFCeEQsR0FBRyxFQUFFb0MsSUFBSSxFQUFFelEsR0FBRyxFQUFFMFEsS0FBSztJQUNqRCxJQUFJakgsa0JBQWtCZ0gsS0FBS2hILGVBQWU7SUFDMUMsSUFBSTdGLFFBQVE4TSxNQUFNOU0sS0FBSztJQUN2QixJQUFJL0MsS0FBcUMsSUFBSSxDQUFDNEMsV0FBV0csUUFBUTtRQUMvRDlDLElBQUksbUJBQW1CMkksa0JBQWtCLFdBQVc0RSxJQUFJbEUsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRLEtBQUssT0FBUSxTQUFRd0osa0JBQWtCLG1FQUFrRTtJQUM3TDtBQUNGO0FBQ0EsU0FBU2lJLHFCQUFxQnJELEdBQUcsRUFBRXJGLFVBQVUsRUFBRWhKLEdBQUcsRUFBRXdPLFVBQVUsRUFBRWEsS0FBSyxFQUNyRSw2REFBNkQ7QUFDN0RzQixlQUFlO0lBQ2IsSUFBSUEsb0JBQW9CLEtBQUssR0FBRztRQUM5QkEsa0JBQWtCMU4sWUFBWTBOLGVBQWU7SUFDL0M7SUFDQWtCLHFCQUFxQnhELEtBQUtyRixZQUFZaEosS0FBS3dPO0lBQzNDLElBQUk1SyxRQUFRNEssV0FBVzVLLEtBQUs7SUFDNUIsZ0ZBQWdGO0lBQ2hGLElBQUksQ0FBQ3lKLE9BQU96SixRQUFRO1FBQ2xCQSxRQUFRMEosS0FBSzFKO0lBQ2Y7SUFDQSxJQUFJeUwsT0FBTztRQUNULElBQUk4QjtRQUNKLHdFQUF3RTtRQUN4RXZOLFFBQVFBLE1BQU1pRSxJQUFJLENBQUMsQ0FBQ3NKLGNBQWM5QyxJQUFJK0MsTUFBTSxLQUFLLE9BQU9ELGNBQWM5QyxJQUFJaUIsT0FBTztRQUNqRixxRUFBcUU7UUFDckUxTCxNQUFNZ08sVUFBVSxHQUFHO0lBQ3JCO0lBQ0EsT0FBTztRQUNMaE8sT0FBT0E7UUFDUCwrQkFBK0I7UUFDL0IscURBQXFEO1FBQ3JEaUIsY0FBYzhMLGtCQUFrQnRDLElBQUlDLGNBQWMsR0FBRztRQUNyRCxrRUFBa0U7UUFDbEUzSixZQUFZO1FBQ1osd0NBQXdDO1FBQ3hDLGtEQUFrRDtRQUNsREMsVUFBVStMLGtCQUFrQixRQUFRO0lBQ3RDO0FBQ0Y7QUFFQSxTQUFTbUIseUJBQXlCeFIsSUFBSSxFQUFFd08sT0FBTztJQUM3QyxPQUFPO1FBQ0xyRixpQkFBaUJuSjtRQUNqQnlPLFVBQVVEO1FBQ1ZYLE9BQU80RDtRQUNQM0QsU0FBUzREO1FBQ1Q3SSxpQkFBaUI4STtJQUNuQjtBQUNGO0FBQ0EsU0FBU0YsUUFBUTFELEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVU7SUFDbkMsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQ0MsS0FBS3JPLEtBQUt3TyxZQUFZLFdBQVcsT0FBTyxFQUFFLHFCQUFxQixNQUFLLEVBQUUsb0JBQW9CO0FBQ2hIO0FBQ0EsU0FBU3dELFVBQVUzRCxHQUFHLEVBQUVyTyxHQUFHLEVBQUV3TyxVQUFVLEVBQUVDLFNBQVM7SUFDaER5RCx5QkFBeUI3RCxLQUFLLElBQUksRUFBRXJPLEtBQUt3TztJQUN6QyxPQUFPSCxJQUFJOEQsdUJBQXVCLENBQUNuUyxLQUFLa0ksU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDNkcsUUFBUSxFQUFFO1FBQ2xFeEQsS0FBS2lELFdBQVdqRCxHQUFHO1FBQ25CRSxLQUFLK0MsV0FBVy9DLEdBQUc7SUFDckIsSUFBSWdEO0FBQ047QUFDQSxTQUFTd0Qsa0JBQWtCMUcsR0FBRyxFQUFFM0IsT0FBTztJQUNyQyxJQUFJL0ksSUFBcUMsRUFBRTtRQUN6Q2dKLHlCQUF5QkQsU0FBUztZQUFDO1NBQVM7SUFDOUM7SUFDQSxJQUFJZ0csTUFBTSxJQUFJO0lBQ2QsSUFBSTVQLE1BQU00SixRQUFRdEosSUFBSSxFQUNwQnFQLGlCQUFpQi9GLFFBQVErRixjQUFjO0lBQ3pDQSxlQUFlO1FBQ2IsSUFBSXRCLE1BQU0rRCxtQkFBbUIsSUFBSSxDQUFDLENBQUNuSSxNQUFNO1FBQ3pDLElBQUk2RSxVQUFVNUcsU0FBUyxDQUFDLEdBQUcwSCxJQUFJYixRQUFRLEVBQUU7WUFDdkN4RCxLQUFLQTtZQUNMM0IsU0FBUyxJQUFJO1FBQ2Y7UUFDQWtGLFFBQVF4TyxJQUFJLElBQUt3TyxDQUFBQSxRQUFReE8sSUFBSSxHQUFHTyxLQUFxQyxHQUFHd04sSUFBSWxFLEtBQUssR0FBRyxNQUFNbkssSUFBSUMsUUFBUSxLQUFLLENBQW1DO1FBQzlJb08sSUFBSWdFLE9BQU8sQ0FBQzVHLEdBQUcsQ0FBQ3pMLEtBQUssSUFBSXNTLGNBQWN4RDtJQUN6QztJQUNBLE9BQU87UUFDTCxPQUFPLElBQUksQ0FBQzdFLE1BQU0sQ0FBQ3NJLHVCQUF1QixDQUFDdlM7SUFDN0M7QUFDRjtBQUNBLFNBQVNrUyx5QkFBeUI3RCxHQUFHLEVBQUVvQyxJQUFJLEVBQUV6USxHQUFHLEVBQUUwUSxLQUFLO0lBQ3JELElBQUlqSCxrQkFBa0JnSCxLQUFLaEgsZUFBZTtJQUMxQyxJQUFJOEIsTUFBTW1GLE1BQU1uRixHQUFHO0lBQ25CLElBQUkxSyxLQUFxQyxJQUFJLENBQUMwSyxLQUFLO1FBQ2pEekssSUFBSSxtQkFBbUIySSxrQkFBa0IsV0FBVzRFLElBQUlsRSxLQUFLLEdBQUcsTUFBTW5LLElBQUlDLFFBQVEsS0FBSyxPQUFRLFNBQVF3SixrQkFBa0IsbURBQWtEO0lBQzdLO0FBQ0Y7QUFFQSxTQUFTK0ksMkJBQTJCbFMsSUFBSSxFQUFFd08sT0FBTztJQUMvQyxPQUFPO1FBQ0xyRixpQkFBaUJuSjtRQUNqQnlPLFVBQVVEO1FBQ1ZYLE9BQU9zRTtRQUNQckUsU0FBU3NFO1FBQ1R2SixpQkFBaUJ3SjtJQUNuQjtBQUNGO0FBQ0EsU0FBU0YsUUFBUXBFLEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVU7SUFDbkMsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQ0MsS0FBS3JPLEtBQUt3TyxZQUFZLFdBQVcsT0FBTyxFQUFFLHFCQUFxQixNQUFLLEVBQUUsb0JBQW9CO0FBQ2hIO0FBQ0EsU0FBU2tFLFVBQVVyRSxHQUFHLEVBQUVyTyxHQUFHLEVBQUV3TyxVQUFVLEVBQUVDLFNBQVM7SUFDaEQsSUFBSW1FLHVCQUF1QnhEO0lBQzNCeUQsMkJBQTJCeEUsS0FBSyxJQUFJLEVBQUVyTyxLQUFLd087SUFDM0MsT0FBT0gsSUFBSXlFLHlCQUF5QixDQUFDOVMsS0FBS3dPLFdBQVc1SyxLQUFLLEVBQUUsQ0FBQ2dQLHdCQUF3QixDQUFDeEQsaUJBQWlCLElBQUksQ0FBQ0wsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJSyxlQUFlMkQsUUFBUSxLQUFLLE9BQU9ILHdCQUF3QjlGLGNBQWMyQjtBQUNwTjtBQUNBLFNBQVNrRSxrQkFBa0JqRSxJQUFJLEVBQUU5RSxPQUFPO0lBQ3RDLElBQUkvSSxJQUFxQyxFQUFFO1FBQ3pDLElBQUkrSSxRQUFRSSxJQUFJLEtBQUssU0FBUztZQUM1QixNQUFNbEosSUFBSSxzQ0FBc0NXLE9BQU9tSSxRQUFRdEosSUFBSSxJQUFJLCtCQUErQm1CLE9BQU9tSSxRQUFRdEosSUFBSSxJQUFJO1FBQy9IO1FBQ0F1Six5QkFBeUJELFNBQVM7WUFBQztTQUFXO0lBQ2hEO0lBQ0EsSUFBSWdHLE1BQU0sSUFBSTtJQUNkLElBQUk1RixPQUFPSixRQUFRSSxJQUFJLEVBQ3JCMUosT0FBT3NKLFFBQVF0SixJQUFJO0lBQ3JCLGdHQUFnRztJQUNoRywrSEFBK0g7SUFDL0gsNEdBQTRHO0lBQzVHLDJHQUEyRztJQUMzRywwREFBMEQ7SUFDMUQseUZBQXlGO0lBQ3pGLGlCQUFpQjtJQUNqQixJQUFJMFMscUJBQXFCLElBQUlDO0lBQzdCLFNBQVNDLHFCQUFxQjNNLE1BQU0sRUFBRTNDLEtBQUs7UUFDekMsSUFBSXVQLHVCQUF1Qm5EO1FBQzNCLElBQUkzQixNQUFNK0QsbUJBQW1CN0wsT0FBTyxDQUFDMEQsTUFBTTtRQUMzQyxJQUFJZ0QsYUFBYSxJQUFJbUcsZ0JBQWdCeFAsT0FBTyxDQUFDdVAsd0JBQXdCLENBQUNuRCxnQkFBZ0JKLElBQUliLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSWlCLGNBQWMrQyxRQUFRLEtBQUssT0FBT0ksd0JBQXdCckcsY0FBY2pNLEtBQXFDLEdBQUd3TixJQUFJbEUsS0FBSyxHQUFHLE1BQU03SixLQUFLTCxRQUFRLEtBQUssQ0FBcUMsRUFBRTtRQUNsVG9PLElBQUlnRSxPQUFPLENBQUM1RyxHQUFHLENBQUNuTCxNQUFNMk07UUFDdEIrRixtQkFBbUJLLEdBQUcsQ0FBQzlNO0lBQ3pCO0lBQ0EsSUFBSXlELFFBQVEsWUFBWTtRQUN0QixPQUFPO1lBQ0x1QixLQUFLLFNBQVNBO2dCQUNaLElBQUksQ0FBQ3lILG1CQUFtQk0sR0FBRyxDQUFDLElBQUksR0FBRztvQkFDakNKLHFCQUFxQixJQUFJLEVBQUV4RSxLQUFLbkQsR0FBRyxDQUFDbkgsSUFBSSxDQUFDLElBQUk7Z0JBQy9DO2dCQUNBLE9BQU8sSUFBSSxDQUFDNkYsTUFBTSxDQUFDc0ksdUJBQXVCLENBQUNqUztZQUM3QztZQUNBbUwsS0FBSyxTQUFTQSxJQUFJN0gsS0FBSztnQkFDckIsSUFBSSxDQUFDb1AsbUJBQW1CTSxHQUFHLENBQUMsSUFBSSxHQUFHO29CQUNqQ0oscUJBQXFCLElBQUksRUFBRXRQO2dCQUM3QjtnQkFDQSxPQUFPLElBQUksQ0FBQ3FHLE1BQU0sQ0FBQ3NKLHVCQUF1QixDQUFDalQsTUFBTXNEO1lBQ25EO1lBQ0E0UCxNQUFNLFNBQVNBLEtBQUs1UCxLQUFLO2dCQUN2QixJQUFJLENBQUNvUCxtQkFBbUJNLEdBQUcsQ0FBQyxJQUFJLEdBQUc7b0JBQ2pDSixxQkFBcUIsSUFBSSxFQUFFdFA7Z0JBQzdCO2dCQUNBLE9BQU9BO1lBQ1Q7UUFDRjtJQUNGO0lBQ0E7QUFDRjtBQUNBLFNBQVNpUCwyQkFBMkJ4RSxHQUFHLEVBQUVvQyxJQUFJLEVBQUV6USxHQUFHLEVBQUV3TyxVQUFVO0lBQzVELElBQUkvRSxrQkFBa0JnSCxLQUFLaEgsZUFBZTtJQUMxQyxJQUFJNUksS0FBcUMsSUFBSSxDQUFFLFlBQVcyTixVQUFTLEdBQUk7UUFDckUxTixJQUFJLG1CQUFtQjJJLGtCQUFrQixXQUFXNEUsSUFBSWxFLEtBQUssR0FBRyxNQUFNbkssSUFBSUMsUUFBUSxLQUFLLE9BQVEsU0FBUXdKLGtCQUFrQiw4Q0FBNkM7SUFDeEs7QUFDRjtBQUVBLElBQUlnSyxPQUFPO0FBQ1gsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUM7QUFDbEMsU0FBU0EscUJBQXFCN0UsT0FBTztJQUNuQyxPQUFPO1FBQ0xyRixpQkFBaUJnSztRQUNqQjFFLFVBQVVEO1FBQ1ZYLE9BQU95RjtRQUNQeEYsU0FBU3lGO1FBQ1QxSyxpQkFBaUIySztJQUNuQjtBQUNGO0FBQ0EsU0FBU0YsUUFBUXZGLEdBQUcsRUFBRXJPLEdBQUcsRUFBRXdPLFVBQVUsRUFBRVcsTUFBTTtJQUMzQyxJQUFJd0MsaUJBQWlCb0M7SUFDckIscUJBQXFCO0lBQ3JCLElBQUl2RixXQUFXakQsR0FBRyxFQUFFO1FBQ2xCLE9BQU95SSxTQUFTN0YsS0FBSyxDQUFDRSxLQUFLck8sS0FBS3dPLFlBQVlXO0lBQzlDO0lBQ0EsK0JBQStCO0lBQy9CLElBQUlYLFdBQVcvQyxHQUFHLEVBQUU7UUFDbEIscUVBQXFFO1FBQ3JFLElBQUlBLE1BQU0wRSxhQUFhblEsSUFBSUMsUUFBUSxJQUFJdU8sV0FBVy9DLEdBQUc7UUFDckQsTUFBTTtRQUNOLElBQUkwRCxXQUFXZCxJQUFJaUIsT0FBTyxFQUFFO1lBQzFCLE9BQU9qQixJQUFJb0IsZUFBZSxDQUFDelAsS0FBSztnQkFDOUI2RSxjQUFjNUIsWUFBWTBOLGVBQWUsR0FBR3RDLElBQUlDLGNBQWMsR0FBRztnQkFDakU3QyxLQUFLQTtZQUNQLE9BQU8sT0FBTyxFQUFFLHFCQUFxQixNQUFLLEVBQUUsdUJBQXVCO1FBQ3JFO1FBQ0EsUUFBUTtRQUNScEosZUFBZThNLFFBQVFuUCxLQUFLO1lBQzFCNkUsY0FBYztZQUNkNEcsS0FBS0E7UUFDUDtRQUNBLE9BQU8sRUFBRSx1QkFBdUI7SUFDbEM7SUFDQSx1Q0FBdUM7SUFDdkMsSUFBSTBELFdBQVdkLElBQUlpQixPQUFPLElBQUksT0FBT2QsV0FBVzVLLEtBQUssS0FBSyxZQUFZO1FBQ3BFLElBQUkyTTtRQUNKLElBQUlsTSxZQUFZbUssV0FBVzVLLEtBQUssR0FBRztZQUNqQyxJQUFJd0w7WUFDSixJQUFJNkUsaUJBQWlCLENBQUM3RSxpQkFBaUIsSUFBSSxDQUFDTCxRQUFRLEtBQUssUUFBUUssZUFBZThFLFFBQVEsR0FBRzVHLEtBQUsrQixLQUFLLEdBQUcvQjtZQUN4RyxPQUFPMkcsZUFBZTlGLEtBQUssQ0FBQ0UsS0FBS3JPLEtBQUt3TyxZQUFZVztRQUNwRDtRQUNBLElBQUlnRixtQkFBbUIsQ0FBQzVELGtCQUFrQixJQUFJLENBQUN4QixRQUFRLEtBQUssUUFBUXdCLGdCQUFnQjJELFFBQVEsR0FBRzNHLFdBQVc4QixLQUFLLEdBQUc5QjtRQUNsSCxPQUFPNEcsaUJBQWlCaEcsS0FBSyxDQUFDRSxLQUFLck8sS0FBS3dPLFlBQVlXO0lBQ3REO0lBQ0Esc0JBQXNCO0lBQ3RCLDJDQUEyQztJQUMzQyw0Q0FBNEM7SUFDNUMsSUFBSWlGLHVCQUF1QixDQUFDLENBQUN6QyxrQkFBa0IsSUFBSSxDQUFDNUMsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJNEMsZ0JBQWdCOUQsSUFBSSxNQUFNLFFBQVFaLFdBQVdvSCxHQUFHLEdBQUdwSDtJQUNwSSxzQ0FBc0M7SUFDdEMsSUFBSSxPQUFPdUIsV0FBVzVLLEtBQUssS0FBSyxjQUFjLENBQUNtUSxrQkFBa0IsSUFBSSxDQUFDaEYsUUFBUSxLQUFLLFFBQVFnRixnQkFBZ0JHLFFBQVEsRUFBRTtRQUNuSCxJQUFJL0M7UUFDSjNDLFdBQVc1SyxLQUFLLEdBQUc0SyxXQUFXNUssS0FBSyxDQUFDaUUsSUFBSSxDQUFDLENBQUNzSixjQUFjOUMsSUFBSStDLE1BQU0sS0FBSyxPQUFPRCxjQUFjOUMsSUFBSWlCLE9BQU87SUFDekc7SUFDQSxPQUFPOEUscUJBQXFCakcsS0FBSyxDQUFDRSxLQUFLck8sS0FBS3dPLFlBQVlXO0FBQzFEO0FBQ0EsU0FBUzBFLFVBQVV4RixHQUFHLEVBQUVyTyxHQUFHLEVBQUV3TyxVQUFVLEVBQUVDLFNBQVM7SUFDaEQsSUFBSTZGLGlCQUFpQkM7SUFDckIscUJBQXFCO0lBQ3JCLElBQUkvRixXQUFXakQsR0FBRyxFQUFFO1FBQ2xCLE9BQU95SSxTQUFTNUYsT0FBTyxDQUFDQyxLQUFLck8sS0FBS3dPLFlBQVlDO0lBQ2hEO0lBQ0EsK0JBQStCO0lBQy9CLElBQUlELFdBQVcvQyxHQUFHLEVBQUU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU80QyxJQUFJb0IsZUFBZSxDQUFDelAsS0FBSztZQUM5QjZFLGNBQWM1QixZQUFZME4sZUFBZSxHQUFHdEMsSUFBSUMsY0FBYyxHQUFHO1lBQ2pFN0MsS0FBSzBFLGFBQWFuUSxJQUFJQyxRQUFRLElBQUl1TyxXQUFXL0MsR0FBRztRQUNsRCxHQUFHZ0Q7SUFDTDtJQUNBLHNCQUFzQjtJQUN0QixzQ0FBc0M7SUFDdEMsSUFBSSxPQUFPRCxXQUFXNUssS0FBSyxLQUFLLGNBQWMsQ0FBQzBRLGtCQUFrQixJQUFJLENBQUN2RixRQUFRLEtBQUssUUFBUXVGLGdCQUFnQkosUUFBUSxFQUFFO1FBQ25ILElBQUloRDtRQUNKMUMsV0FBVzVLLEtBQUssR0FBRzRLLFdBQVc1SyxLQUFLLENBQUNpRSxJQUFJLENBQUMsQ0FBQ3FKLGVBQWU3QyxJQUFJK0MsTUFBTSxLQUFLLE9BQU9GLGVBQWU3QyxJQUFJaUIsT0FBTztJQUMzRztJQUNBLElBQUk4RSx1QkFBdUIsQ0FBQyxDQUFDRyxrQkFBa0IsSUFBSSxDQUFDeEYsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJd0YsZ0JBQWdCMUcsSUFBSSxNQUFNLFFBQVFaLFdBQVdvSCxHQUFHLEdBQUdwSDtJQUNwSSxPQUFPbUgscUJBQXFCaEcsT0FBTyxDQUFDQyxLQUFLck8sS0FBS3dPLFlBQVlDO0FBQzVEO0FBQ0EsU0FBU3FGLGtCQUFrQnBGLElBQUksRUFBRTlFLE9BQU87SUFDdEM5SSxJQUFJLE1BQU0sSUFBSSxDQUFDMkksZUFBZSxHQUFHO0FBQ25DO0FBRUEsSUFBSStLLGFBQWE7QUFDakIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyxvQkFBb0I7QUFDeEIsK0ZBQStGO0FBQy9GLDJCQUEyQjtBQUMzQixJQUFJQyxpQ0FBaUM7SUFDbkMvRyxNQUFNO0lBQ052TixNQUFNNk07SUFDTjBILGtCQUFrQjFIO0lBQ2xCMkgsT0FBTztBQUNUO0FBQ0E1UyxPQUFPTyxNQUFNLENBQUNtUztBQUNkLFNBQVNHLDBCQUEwQnZVLEtBQUs7SUFDdEMsT0FBT0EsU0FBU29VO0FBQ2xCO0FBQ0EsSUFBSVIsdUJBQXVCLFdBQVcsR0FBRTVCLDJCQUEyQmdDO0FBQ25FLElBQUlRLDBCQUEwQixXQUFXLEdBQUV4QywyQkFBMkJpQyxnQkFBZ0I7SUFDcEYxQixVQUFVakY7QUFDWjtBQUNBLElBQUltSCw4QkFBOEIsV0FBVyxHQUFFekMsMkJBQTJCa0Msb0JBQW9CO0lBQzVGM0IsVUFBVXZGO0FBQ1o7QUFDQSxJQUFJMEgsNkJBQTZCLFdBQVcsR0FBRTFDLDJCQUEyQm1DLG1CQUFtQjtJQUMxRjVCLFVBQVVoRjtBQUNaO0FBQ0EsSUFBSW9ILGdDQUFnQyxXQUFXLEdBQUVwTSwwQkFBMEJxTDtBQUMzRSxTQUFTZ0IsdUJBQXVCdEcsT0FBTztJQUNyQyxPQUFPQSxRQUFRakIsSUFBSSxLQUFLLE9BQU9mLGVBQWVnQyxRQUFRakIsSUFBSSxLQUFLLFFBQVFDLG9CQUFvQnVILDBCQUEwQnZHLFFBQVErRixnQkFBZ0I7QUFDL0k7QUFDQSxTQUFTUyx5QkFBeUJ4RyxPQUFPO0lBQ3ZDLElBQUl5RztJQUNKLE9BQU96RyxVQUFVLENBQUN5Ryx3QkFBd0J6RyxRQUFRK0YsZ0JBQWdCLEtBQUssT0FBT1Usd0JBQXdCNUIscUJBQXFCN0UsV0FBVzNCO0FBQ3hJO0FBQ0EsU0FBU2tJLDBCQUEwQnJNLFVBQVU7SUFDM0MsSUFBSTZILHVCQUF1QkQ7SUFDM0IsT0FBTyxDQUFDNUgsYUFBYThELGVBQWUsQ0FBQytELHdCQUF3QixDQUFDRCx1QkFBdUI1SCxXQUFXK0YsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJNkIscUJBQXFCbUMsUUFBUSxLQUFLLE9BQU9sQyx3QkFBd0IvRDtBQUNoTTtBQUNBOzs7Q0FHQyxHQUNELFNBQVMwSSxpQkFBaUJ6SSxDQUFDLEVBQUUwSSxJQUFJLEVBQUVDLElBQUk7SUFDckMsNENBQTRDO0lBQzVDLElBQUl4TSxpQkFBaUJ1TSxPQUFPO1FBQzFCLE9BQU9yQixxQkFBcUJqTCxlQUFlLENBQUM0RCxHQUFHMEk7SUFDakQ7SUFDQSx3QkFBd0I7SUFDeEIsSUFBSTlSLFlBQVk4UixPQUFPO1FBQ3JCck0sZ0JBQWdCMkQsR0FBRzBJLE1BQU1yQjtRQUN6QjtJQUNGO0lBQ0EsOEJBQThCO0lBQzlCLElBQUlwSCxhQUFhRCxJQUFJO1FBQ25CLE9BQU9BO0lBQ1Q7SUFDQSxlQUFlO0lBQ2YsSUFBSWhKLGNBQWNnSixJQUFJO1FBQ3BCLE9BQU9FLFdBQVd4SSxNQUFNLENBQUNzSSxHQUFHMEksTUFBTUM7SUFDcEM7SUFDQSxRQUFRO0lBQ1IsSUFBSXZVLE1BQU0yRyxPQUFPLENBQUNpRixJQUFJO1FBQ3BCLE9BQU9FLFdBQVdDLEtBQUssQ0FBQ0gsR0FBRzBJO0lBQzdCO0lBQ0EsTUFBTTtJQUNOLElBQUl2USxTQUFTNkgsSUFBSTtRQUNmLE9BQU9FLFdBQVd6TCxHQUFHLENBQUN1TCxHQUFHMEk7SUFDM0I7SUFDQSxNQUFNO0lBQ04sSUFBSWxRLFNBQVN3SCxJQUFJO1FBQ2YsT0FBT0UsV0FBV3hCLEdBQUcsQ0FBQ3NCLEdBQUcwSTtJQUMzQjtJQUNBLHdCQUF3QjtJQUN4QixJQUFJLE9BQU8xSSxNQUFNLFlBQVlBLE1BQU0sTUFBTTtRQUN2QyxPQUFPQTtJQUNUO0lBQ0EsZ0JBQWdCO0lBQ2hCLE9BQU9FLFdBQVcwSSxHQUFHLENBQUM1SSxHQUFHMEk7QUFDM0I7QUFDQXhULE9BQU91VCxrQkFBa0JMO0FBQ3pCLElBQUlTLHNCQUFzQjtJQUN4QkQsS0FBSyxTQUFTQSxJQUFJL1IsS0FBSyxFQUFFa0wsT0FBTztRQUM5QixJQUFJeEgsSUFBSXlOLDBCQUEwQmpHO1FBQ2xDLE9BQU8sSUFBSXNFLGdCQUFnQnhQLE9BQU93Uix1QkFBdUI5TixJQUFJQSxFQUFFaEgsSUFBSSxFQUFFLE1BQU1nSCxFQUFFdU8sTUFBTTtJQUNyRjtJQUNBM0ksT0FBTyxTQUFTQSxNQUFNNEksYUFBYSxFQUFFaEgsT0FBTztRQUMxQyxJQUFJeEgsSUFBSXlOLDBCQUEwQmpHO1FBQ2xDLE9BQU8sQ0FBQzdMLFlBQVk4UyxVQUFVLEtBQUssU0FBU3pPLEVBQUV3TixLQUFLLEtBQUssUUFBUWtCLG9CQUFvQkMscUJBQW9CLEVBQUdILGVBQWVWLHVCQUF1QjlOLElBQUlBLEVBQUVoSCxJQUFJO0lBQzdKO0lBQ0FrQixLQUFLLFNBQVNBLElBQUlzVSxhQUFhLEVBQUVoSCxPQUFPO1FBQ3RDLElBQUl4SCxJQUFJeU4sMEJBQTBCakc7UUFDbEMsT0FBTyxJQUFJb0gsY0FBY0osZUFBZVYsdUJBQXVCOU4sSUFBSUEsRUFBRWhILElBQUk7SUFDM0U7SUFDQW1MLEtBQUssU0FBU0EsSUFBSXFLLGFBQWEsRUFBRWhILE9BQU87UUFDdEMsSUFBSXhILElBQUl5TiwwQkFBMEJqRztRQUNsQyxPQUFPLElBQUlxSCxjQUFjTCxlQUFlVix1QkFBdUI5TixJQUFJQSxFQUFFaEgsSUFBSTtJQUMzRTtJQUNBbUUsUUFBUSxTQUFTQSxPQUFPMlIsS0FBSyxFQUFFQyxVQUFVLEVBQUV2SCxPQUFPO1FBQ2hELE9BQU93SCxlQUFlO1lBQ3BCLE9BQU9DLGlCQUFpQnRULFlBQVk4UyxVQUFVLEtBQUssU0FBUyxDQUFDakgsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWdHLEtBQUssTUFBTSxRQUFRMUMsbUJBQW1CLENBQUMsR0FBR3RELFdBQVcwSCwwQkFBMEIsQ0FBQyxHQUFHMUgsVUFBVXNILE9BQU9DO1FBQ3RNO0lBQ0Y7SUFDQWhDLEtBQUssV0FBVyxHQUFFdEwsMEJBQTBCaU07SUFDNUNuSSxTQUFTLFdBQVcsR0FBRTlELDBCQUEwQmtNO0lBQ2hEcEgsTUFBTXNIO0lBQ05zQixRQUFRLFdBQVcsR0FBRTFOLDBCQUEwQm1NO0FBQ2pEO0FBQ0EsMkJBQTJCO0FBQzNCLElBQUlqSSxhQUFhLFdBQVcsR0FBRWhMLE9BQU91VCxrQkFBa0JJO0FBRXZELElBQUljLFdBQVc7QUFDZixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMscUJBQXFCLFdBQVcsR0FBRTlFLHlCQUF5QjRFO0FBQy9ELElBQUlHLDJCQUEyQixXQUFXLEdBQUUvRSx5QkFBeUI2RSxpQkFBaUI7SUFDcEZkLFFBQVFuSixTQUFTRSxVQUFVO0FBQzdCO0FBQ0E7OztDQUdDLEdBQ0QsSUFBSW9ILFdBQVcsU0FBU0EsU0FBUzhDLElBQUksRUFBRXJCLElBQUk7SUFDekMsSUFBSXZNLGlCQUFpQnVNLE9BQU87UUFDMUIsZ0NBQWdDO1FBQ2hDLE9BQU9tQixtQkFBbUJ6TixlQUFlLENBQUMyTixNQUFNckI7SUFDbEQ7SUFDQSxJQUFJOVIsWUFBWThSLE9BQU87UUFDckIsWUFBWTtRQUNaLE9BQU9yTSxnQkFBZ0IwTixNQUFNckIsTUFBTW1CO0lBQ3JDO0lBQ0EsSUFBSTdTLGNBQWMrUyxPQUFPO1FBQ3ZCLHlCQUF5QjtRQUN6QixPQUFPL04sMEJBQTBCK0kseUJBQXlCNEUsVUFBVUk7SUFDdEU7SUFDQSwyQkFBMkI7SUFDM0IsSUFBSWpXLElBQXFDLEVBQUU7UUFDekMsSUFBSSxDQUFDNEMsV0FBV3FULE9BQU87WUFDckJoVyxJQUFJO1FBQ047UUFDQSxJQUFJMkMsV0FBV2dTLE9BQU87WUFDcEIzVSxJQUFJO1FBQ047SUFDRjtJQUNBLElBQUlpVyxPQUFPaFQsY0FBYzBSLFFBQVFBLE9BQU8sQ0FBQztJQUN6Q3NCLEtBQUt4TCxHQUFHLEdBQUd1TDtJQUNYQyxLQUFLelcsSUFBSSxJQUFLeVcsQ0FBQUEsS0FBS3pXLElBQUksR0FBR3dXLEtBQUt4VyxJQUFJLElBQUksRUFBQyxHQUFJLHNCQUFzQjtJQUNsRSxPQUFPLElBQUlnUyxjQUFjeUU7QUFDM0I7QUFDQTdVLE9BQU9ELE1BQU0sQ0FBQytSLFVBQVU0QztBQUN4QjVDLFNBQVN5QyxNQUFNLEdBQUcsV0FBVyxHQUFFMU4sMEJBQTBCOE47QUFFekQsSUFBSUcsdUJBQXVCQztBQUMzQixxRkFBcUY7QUFDckYsZ0JBQWdCO0FBQ2hCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLDZCQUE2QixDQUFDSix3QkFBd0IsQ0FBQ0MsaUJBQWlCLFdBQVcsR0FBRTlVLGNBQWMsWUFBYSxHQUFHLE9BQU0sS0FBTSxPQUFPLEtBQUssSUFBSThVLGVBQWVwUyxZQUFZLEtBQUssT0FBT21TLHdCQUF3QjtBQUNsTixvQ0FBb0M7QUFDcEMsSUFBSUssb0JBQW9CO0lBQ3RCelQsT0FBTztJQUNQaUIsY0FBYztJQUNkRCxVQUFVO0lBQ1ZELFlBQVk7QUFDZDtBQUNBLFNBQVN3TCxhQUFhbUgsVUFBVSxFQUFFNVQsRUFBRSxFQUFFNkosVUFBVSxFQUFFOEcsR0FBRztJQUNuRCxJQUFJOUcsZUFBZSxLQUFLLEdBQUc7UUFDekJBLGFBQWE7SUFDZjtJQUNBLElBQUkxTSxJQUFxQyxFQUFFO1FBQ3pDLElBQUksQ0FBQzRDLFdBQVdDLEtBQUs7WUFDbkI1QyxJQUFJO1FBQ047UUFDQSxJQUFJLE9BQU93VyxlQUFlLFlBQVksQ0FBQ0EsWUFBWTtZQUNqRHhXLElBQUksNENBQTRDd1csYUFBYTtRQUMvRDtJQUNGO0lBQ0EsU0FBUzVRO1FBQ1AsT0FBTzZRLGNBQWNELFlBQVkvSixZQUFZN0osSUFBSTJRLE9BQU8sSUFBSSxFQUFFcFQ7SUFDaEU7SUFDQXlGLElBQUk0SixZQUFZLEdBQUc7SUFDbkI1SixJQUFJekcsUUFBUSxHQUFHO1FBQ2IsT0FBT3lELEdBQUd6RCxRQUFRO0lBQ3BCO0lBQ0EsSUFBSW1YLDRCQUE0QjtRQUM5QkMsa0JBQWtCelQsS0FBSyxHQUFHMFQ7UUFDMUJqVixlQUFlcUUsS0FBSyxRQUFRMlE7SUFDOUI7SUFDQSxPQUFPM1E7QUFDVDtBQUNBLFNBQVM2USxjQUFjRCxVQUFVLEVBQUVFLGtCQUFrQixFQUFFOVQsRUFBRSxFQUFFK1QsS0FBSyxFQUFFdlcsSUFBSTtJQUNwRSxJQUFJd1csVUFBVUMsYUFBYUwsWUFBWUUsb0JBQW9CQyxPQUFPdlc7SUFDbEUsSUFBSTtRQUNGLE9BQU93QyxHQUFHcEMsS0FBSyxDQUFDbVcsT0FBT3ZXO0lBQ3pCLEVBQUUsT0FBTzBXLEtBQUs7UUFDWkYsUUFBUUcsTUFBTSxHQUFHRDtRQUNqQixNQUFNQTtJQUNSLFNBQVU7UUFDUkUsV0FBV0o7SUFDYjtBQUNGO0FBQ0EsU0FBU0MsYUFBYUwsVUFBVSxFQUFFRSxrQkFBa0IsRUFDcEQsc0JBQXNCO0FBQ3RCQyxLQUFLLEVBQUV2VyxJQUFJO0lBQ1QsSUFBSTZXLGFBQWFsWCxLQUFxQyxJQUFJbVgsa0JBQWtCLENBQUMsQ0FBQ1Y7SUFDOUUsSUFBSVcsYUFBYTtJQUNqQixJQUFJcFgsS0FBcUMsSUFBSWtYLFlBQVk7UUFDdkRFLGFBQWFDLEtBQUtDLEdBQUc7UUFDckIsSUFBSUMsZ0JBQWdCbFgsT0FBT0MsTUFBTXlILElBQUksQ0FBQzFILFFBQVFzQjtRQUM5QzZWLGVBQWU7WUFDYkMsTUFBTUM7WUFDTmpZLE1BQU1nWDtZQUNON1MsUUFBUWdUO1lBQ1J4VyxXQUFXbVg7UUFDYjtJQUNGO0lBQ0EsSUFBSUksa0JBQWtCdlYsWUFBWXdWLGtCQUFrQjtJQUNwRCxJQUFJQyxjQUFjLENBQUNsQixzQkFBc0IsQ0FBQ2dCO0lBQzFDcE47SUFDQSxJQUFJdU4seUJBQXlCMVYsWUFBWTJWLGlCQUFpQixFQUFFLHFDQUFxQztJQUNqRyxJQUFJRixhQUFhO1FBQ2ZHO1FBQ0FGLHlCQUF5QkcsdUJBQXVCO0lBQ2xEO0lBQ0EsSUFBSUMsdUJBQXVCQyxxQkFBcUI7SUFDaEQsSUFBSXRCLFVBQVU7UUFDWnVCLGNBQWNQO1FBQ2RGLGlCQUFpQkE7UUFDakJHLHdCQUF3QkE7UUFDeEJJLHNCQUFzQkE7UUFDdEJoQixZQUFZQTtRQUNaRSxZQUFZQTtRQUNaaUIsV0FBVy9CO1FBQ1hnQyxpQkFBaUJqQztJQUNuQjtJQUNBQSxrQkFBa0JRLFFBQVF3QixTQUFTO0lBQ25DLE9BQU94QjtBQUNUO0FBQ0EsU0FBU0ksV0FBV0osT0FBTztJQUN6QixJQUFJUixvQkFBb0JRLFFBQVF3QixTQUFTLEVBQUU7UUFDekNwWSxJQUFJO0lBQ047SUFDQW9XLGtCQUFrQlEsUUFBUXlCLGVBQWU7SUFDekMsSUFBSXpCLFFBQVFHLE1BQU0sS0FBSzFLLFdBQVc7UUFDaENsSyxZQUFZbVcsc0JBQXNCLEdBQUc7SUFDdkM7SUFDQUMscUJBQXFCM0IsUUFBUWlCLHNCQUFzQjtJQUNuRFcsbUJBQW1CNUIsUUFBUXFCLG9CQUFvQjtJQUMvQ3pOO0lBQ0EsSUFBSW9NLFFBQVF1QixZQUFZLEVBQUU7UUFDeEJNLGFBQWE3QixRQUFRYyxlQUFlO0lBQ3RDO0lBQ0EsSUFBSTNYLEtBQXFDLElBQUk2VyxRQUFRSyxVQUFVLEVBQUU7UUFDL0R5QixhQUFhO1lBQ1hDLE1BQU12QixLQUFLQyxHQUFHLEtBQUtULFFBQVFPLFVBQVU7UUFDdkM7SUFDRjtJQUNBaFYsWUFBWW1XLHNCQUFzQixHQUFHO0FBQ3ZDO0FBQ0EsU0FBU1Isa0JBQWtCQSxpQkFBaUIsRUFBRXRWLElBQUk7SUFDaEQsSUFBSW9XLE9BQU9aLHVCQUF1QkY7SUFDbEMsSUFBSTtRQUNGLE9BQU90VjtJQUNULFNBQVU7UUFDUitWLHFCQUFxQks7SUFDdkI7QUFDRjtBQUNBLFNBQVNaLHVCQUF1QkYsaUJBQWlCO0lBQy9DLElBQUljLE9BQU96VyxZQUFZMlYsaUJBQWlCO0lBQ3hDM1YsWUFBWTJWLGlCQUFpQixHQUFHQTtJQUNoQyxPQUFPYztBQUNUO0FBQ0EsU0FBU0wscUJBQXFCSyxJQUFJO0lBQ2hDelcsWUFBWTJWLGlCQUFpQixHQUFHYztBQUNsQztBQUVBLElBQUlDLFNBQVM7QUFDYixJQUFJdkcsa0JBQWtCLFdBQVcsR0FBRSxTQUFVd0csS0FBSztJQUNoRCxTQUFTeEcsZ0JBQWdCeFAsS0FBSyxFQUFFbVAsUUFBUSxFQUFFNUksS0FBSyxFQUFFMFAsU0FBUyxFQUFFaEUsTUFBTTtRQUNoRSxJQUFJaUU7UUFDSixJQUFJM1AsVUFBVSxLQUFLLEdBQUc7WUFDcEJBLFFBQVF0SixLQUFxQyxHQUFHLHFCQUFxQnNDLGNBQWMsQ0FBaUI7UUFDdEc7UUFDQSxJQUFJMFcsY0FBYyxLQUFLLEdBQUc7WUFDeEJBLFlBQVk7UUFDZDtRQUNBLElBQUloRSxXQUFXLEtBQUssR0FBRztZQUNyQkEsU0FBU25KLFFBQVEsQ0FBQyxVQUFVO1FBQzlCO1FBQ0FvTixRQUFRRixNQUFNeFYsSUFBSSxDQUFDLElBQUksRUFBRStGLFVBQVUsSUFBSTtRQUN2QzJQLE1BQU0vRyxRQUFRLEdBQUcsS0FBSztRQUN0QitHLE1BQU0zUCxLQUFLLEdBQUcsS0FBSztRQUNuQjJQLE1BQU1qRSxNQUFNLEdBQUcsS0FBSztRQUNwQmlFLE1BQU1DLG9CQUFvQixHQUFHO1FBQzdCRCxNQUFNRSxhQUFhLEdBQUcsS0FBSztRQUMzQkYsTUFBTUcsZ0JBQWdCLEdBQUcsS0FBSztRQUM5QkgsTUFBTUksTUFBTSxHQUFHLEtBQUs7UUFDcEJKLE1BQU1LLFFBQVEsR0FBRyxLQUFLO1FBQ3RCTCxNQUFNL0csUUFBUSxHQUFHQTtRQUNqQitHLE1BQU0zUCxLQUFLLEdBQUdBO1FBQ2QyUCxNQUFNakUsTUFBTSxHQUFHQTtRQUNmaUUsTUFBTUksTUFBTSxHQUFHbkgsU0FBU25QLE9BQU91SixXQUFXaEQ7UUFDMUMsSUFBSXRKLEtBQXFDLElBQUlnWixhQUFhN0IsZ0JBQWdCO1lBQ3hFLHNEQUFzRDtZQUN0RG9DLFVBQVU7Z0JBQ1I5QixNQUFNcUI7Z0JBQ05sVixRQUFRcVY7Z0JBQ1JPLGdCQUFnQjtnQkFDaEJDLGlCQUFpQlIsTUFBTTNQLEtBQUs7Z0JBQzVCbkQsVUFBVSxLQUFLOFMsTUFBTUksTUFBTTtZQUM3QjtRQUNGO1FBQ0EsT0FBT0o7SUFDVDtJQUNBM1IsZUFBZWlMLGlCQUFpQndHO0lBQ2hDLElBQUkvTyxTQUFTdUksZ0JBQWdCN1EsU0FBUztJQUN0Q3NJLE9BQU8wUCxZQUFZLEdBQUcsU0FBU0EsYUFBYTNXLEtBQUs7UUFDL0MsSUFBSSxJQUFJLENBQUN1VyxRQUFRLEtBQUtoTixXQUFXO1lBQy9CLE9BQU8sSUFBSSxDQUFDZ04sUUFBUSxDQUFDdlc7UUFDdkI7UUFDQSxPQUFPQTtJQUNUO0lBQ0FpSCxPQUFPWSxHQUFHLEdBQUcsU0FBU0EsSUFBSXpFLFFBQVE7UUFDaEMsSUFBSWdILFdBQVcsSUFBSSxDQUFDa00sTUFBTTtRQUMxQmxULFdBQVcsSUFBSSxDQUFDd1QsZ0JBQWdCLENBQUN4VDtRQUNqQyxJQUFJQSxhQUFhL0QsWUFBWXdYLFNBQVMsRUFBRTtZQUN0QyxJQUFJWixZQUFZN0I7WUFDaEIsSUFBSW5YLEtBQXFDLElBQUlnWixXQUFXO2dCQUN0RHhCLGVBQWU7b0JBQ2JDLE1BQU1vQztvQkFDTmpXLFFBQVEsSUFBSTtvQkFDWjRWLGdCQUFnQjtvQkFDaEJDLGlCQUFpQixJQUFJLENBQUNuUSxLQUFLO29CQUMzQm5ELFVBQVVBO29CQUNWZ0gsVUFBVUE7Z0JBQ1o7WUFDRjtZQUNBLElBQUksQ0FBQzJNLFlBQVksQ0FBQzNUO1lBQ2xCLElBQUluRyxLQUFxQyxJQUFJZ1osV0FBVztnQkFDdERMO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EzTyxPQUFPMlAsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWlCeFQsUUFBUTtRQUMxRDRULG9DQUFvQyxJQUFJO1FBQ3hDLElBQUlDLGdCQUFnQixJQUFJLEdBQUc7WUFDekIsSUFBSUMsU0FBU0MsZ0JBQWdCLElBQUksRUFBRTtnQkFDakN0VyxRQUFRLElBQUk7Z0JBQ1o2VCxNQUFNb0M7Z0JBQ04xVCxVQUFVQTtZQUNaO1lBQ0EsSUFBSSxDQUFDOFQsUUFBUTtnQkFDWCxPQUFPN1gsWUFBWXdYLFNBQVM7WUFDOUI7WUFDQXpULFdBQVc4VCxPQUFPOVQsUUFBUTtRQUM1QjtRQUNBLGlCQUFpQjtRQUNqQkEsV0FBVyxJQUFJLENBQUMrTCxRQUFRLENBQUMvTCxVQUFVLElBQUksQ0FBQ2tULE1BQU0sRUFBRSxJQUFJLENBQUMvUCxLQUFLO1FBQzFELE9BQU8sSUFBSSxDQUFDMEwsTUFBTSxDQUFDLElBQUksQ0FBQ3FFLE1BQU0sRUFBRWxULFlBQVkvRCxZQUFZd1gsU0FBUyxHQUFHelQ7SUFDdEU7SUFDQTZELE9BQU84UCxZQUFZLEdBQUcsU0FBU0EsYUFBYTNULFFBQVE7UUFDbEQsSUFBSWdILFdBQVcsSUFBSSxDQUFDa00sTUFBTTtRQUMxQixJQUFJLENBQUNBLE1BQU0sR0FBR2xUO1FBQ2QsSUFBSSxDQUFDbUUsYUFBYTtRQUNsQixJQUFJNlAsYUFBYSxJQUFJLEdBQUc7WUFDdEJDLGdCQUFnQixJQUFJLEVBQUU7Z0JBQ3BCM0MsTUFBTW9DO2dCQUNOalcsUUFBUSxJQUFJO2dCQUNadUMsVUFBVUE7Z0JBQ1ZnSCxVQUFVQTtZQUNaO1FBQ0Y7SUFDRjtJQUNBbkQsT0FBT1UsR0FBRyxHQUFHLFNBQVNBO1FBQ3BCLElBQUksQ0FBQ04sY0FBYztRQUNuQixPQUFPLElBQUksQ0FBQ3NQLFlBQVksQ0FBQyxJQUFJLENBQUNMLE1BQU07SUFDdEM7SUFDQXJQLE9BQU9xUSxVQUFVLEdBQUcsU0FBU0EsV0FBV0MsT0FBTztRQUM3QyxPQUFPQyxvQkFBb0IsSUFBSSxFQUFFRDtJQUNuQztJQUNBdFEsT0FBT3dRLFFBQVEsR0FBRyxTQUFTQSxTQUFTdFEsUUFBUSxFQUFFdVEsZUFBZTtRQUMzRCxJQUFJQSxpQkFBaUI7WUFDbkJ2USxTQUFTO2dCQUNQc1AsZ0JBQWdCO2dCQUNoQkMsaUJBQWlCLElBQUksQ0FBQ25RLEtBQUs7Z0JBQzNCMUYsUUFBUSxJQUFJO2dCQUNaNlQsTUFBTW9DO2dCQUNOMVQsVUFBVSxJQUFJLENBQUNrVCxNQUFNO2dCQUNyQmxNLFVBQVViO1lBQ1o7UUFDRjtRQUNBLE9BQU9vTyxpQkFBaUIsSUFBSSxFQUFFeFE7SUFDaEM7SUFDQUYsT0FBTzJRLEdBQUcsR0FBRyxTQUFTQTtRQUNwQixzQ0FBc0M7UUFDdEMsT0FBTyxJQUFJLENBQUN0QixNQUFNO0lBQ3BCO0lBQ0FyUCxPQUFPNFEsTUFBTSxHQUFHLFNBQVNBO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDbFEsR0FBRztJQUNqQjtJQUNBVixPQUFPNUssUUFBUSxHQUFHLFNBQVNBO1FBQ3pCLE9BQU8sSUFBSSxDQUFDa0ssS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDK1AsTUFBTSxHQUFHO0lBQzFDO0lBQ0FyUCxPQUFPNlEsT0FBTyxHQUFHLFNBQVNBO1FBQ3hCLE9BQU9yVixZQUFZLElBQUksQ0FBQ2tGLEdBQUc7SUFDN0I7SUFDQVYsTUFBTSxDQUFDbkQsT0FBT3JCLFdBQVcsQ0FBQyxHQUFHO1FBQzNCLE9BQU8sSUFBSSxDQUFDcVYsT0FBTztJQUNyQjtJQUNBLE9BQU90STtBQUNULEVBQUVsSjtBQUNGLElBQUl5UixvQkFBb0IsV0FBVyxHQUFFNVcsMEJBQTBCLG1CQUFtQnFPO0FBRWxGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxJQUFJZCxnQkFBZ0IsV0FBVyxHQUFFO0lBQy9COzs7Ozs7Ozs7OztHQVdDLEdBQ0QsU0FBU0EsY0FBY3hELE9BQU87UUFDNUIsSUFBSSxDQUFDOE0sa0JBQWtCLEdBQUduUixrQkFBa0JDLGFBQWE7UUFDekQsSUFBSSxDQUFDbVIsVUFBVSxHQUFHLEVBQUU7UUFDcEIsNERBQTREO1FBQzVELElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLDREQUE0RDtRQUM1RCxJQUFJLENBQUN6UixVQUFVLEdBQUcsSUFBSUM7UUFDdEIsSUFBSSxDQUFDeVIsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDeFIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUdDLGtCQUFrQnVSLFdBQVc7UUFDekQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUMvQixNQUFNLEdBQUcsSUFBSWdDLGdCQUFnQjtRQUNsQyxJQUFJLENBQUMvUixLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNnUyxZQUFZLEdBQUcsS0FBSztRQUN6QixJQUFJLENBQUMvUixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUMxSixVQUFVLEdBQUcsS0FBSztRQUN2Qix1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDMGIsT0FBTyxHQUFHLEtBQUs7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLEdBQUdDLFVBQVVDLElBQUk7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUNDLE9BQU8sR0FBRyxLQUFLO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsS0FBSztRQUM5QixJQUFJLENBQUNDLFVBQVUsR0FBRyxLQUFLO1FBQ3ZCLElBQUksQ0FBQ2hTLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDa0UsUUFBUXZELEdBQUcsRUFBRTtZQUNoQnpLLElBQUk7UUFDTjtRQUNBLElBQUksQ0FBQ0osVUFBVSxHQUFHb08sUUFBUXZELEdBQUc7UUFDN0IsSUFBSSxDQUFDcEIsS0FBSyxHQUFHMkUsUUFBUXhPLElBQUksSUFBS08sQ0FBQUEsS0FBcUMsR0FBRyxtQkFBbUJzQyxjQUFjLENBQWM7UUFDckgsSUFBSTJMLFFBQVFyRCxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMyUSxPQUFPLEdBQUdqTSxhQUFhdFAsS0FBcUMsR0FBRyxJQUFJLENBQUNzSixLQUFLLEdBQUcsWUFBWSxDQUFzQixFQUFFMkUsUUFBUXJELEdBQUc7UUFDbEk7UUFDQSxJQUFJLENBQUNnUixPQUFPLEdBQUczTixRQUFRK0csTUFBTSxJQUFLL0csQ0FBQUEsUUFBUThOLGlCQUFpQixJQUFJOU4sUUFBUTJILE1BQU0sR0FBRy9KLFNBQVNFLFVBQVUsR0FBR0YsUUFBUSxDQUFDLFVBQVU7UUFDekgsSUFBSSxDQUFDOFAsTUFBTSxHQUFHMU4sUUFBUWxGLE9BQU87UUFDN0IsSUFBSSxDQUFDOFMsaUJBQWlCLEdBQUc1TixRQUFRK04sZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ0YsVUFBVSxHQUFHLENBQUMsQ0FBQzdOLFFBQVFnTyxTQUFTO0lBQ3ZDO0lBQ0EsSUFBSWpTLFNBQVN5SCxjQUFjL1AsU0FBUztJQUNwQ3NJLE9BQU9rUyxjQUFjLEdBQUcsU0FBU0E7UUFDL0JDLHNCQUFzQixJQUFJO0lBQzVCO0lBQ0FuUyxPQUFPQyxJQUFJLEdBQUcsU0FBU0E7UUFDckIsSUFBSSxJQUFJLENBQUNILEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQ0EsS0FBSyxDQUFDaEUsT0FBTyxDQUFDLFNBQVVvRSxRQUFRO2dCQUNuQyxPQUFPQTtZQUNUO1FBQ0Y7SUFDRjtJQUNBRixPQUFPRyxLQUFLLEdBQUcsU0FBU0E7UUFDdEIsSUFBSSxJQUFJLENBQUNKLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDakUsT0FBTyxDQUFDLFNBQVVvRSxRQUFRO2dCQUNwQyxPQUFPQTtZQUNUO1FBQ0Y7SUFDRjtJQUdBOzs7R0FHQyxHQUNERixPQUFPVSxHQUFHLEdBQUcsU0FBU0E7UUFDcEIsSUFBSSxJQUFJLENBQUMwUixXQUFXLEVBQUU7WUFDcEJuYyxJQUFJLElBQUksSUFBSSxDQUFDcUosS0FBSyxFQUFFLElBQUksQ0FBQ3pKLFVBQVU7UUFDckM7UUFDQSxJQUFJdUMsWUFBWWlhLE9BQU8sS0FBSyxLQUM1QixzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDN1MsVUFBVSxDQUFDOFMsSUFBSSxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUM5QyxJQUFJUyxjQUFjLElBQUksR0FBRztnQkFDdkIsSUFBSSxDQUFDQyx1QkFBdUI7Z0JBQzVCalMsY0FBYyx1Q0FBdUM7Z0JBQ3JELElBQUksQ0FBQzhPLE1BQU0sR0FBRyxJQUFJLENBQUNvRCxhQUFhLENBQUM7Z0JBQ2pDaFM7WUFDRjtRQUNGLE9BQU87WUFDTEwsZUFBZSxJQUFJO1lBQ25CLElBQUltUyxjQUFjLElBQUksR0FBRztnQkFDdkIsSUFBSUcsc0JBQXNCdGEsWUFBWXVhLGVBQWU7Z0JBQ3JELElBQUksSUFBSSxDQUFDYixVQUFVLElBQUksQ0FBQ1kscUJBQXFCO29CQUMzQ3RhLFlBQVl1YSxlQUFlLEdBQUcsSUFBSTtnQkFDcEM7Z0JBQ0EsSUFBSSxJQUFJLENBQUNDLGVBQWUsSUFBSTtvQkFDMUJDLHlCQUF5QixJQUFJO2dCQUMvQjtnQkFDQXphLFlBQVl1YSxlQUFlLEdBQUdEO1lBQ2hDO1FBQ0Y7UUFDQSxJQUFJSSxTQUFTLElBQUksQ0FBQ3pELE1BQU07UUFDeEIsSUFBSTBELGtCQUFrQkQsU0FBUztZQUM3QixNQUFNQSxPQUFPRSxLQUFLO1FBQ3BCO1FBQ0EsT0FBT0Y7SUFDVDtJQUNBOVMsT0FBT1ksR0FBRyxHQUFHLFNBQVNBLElBQUk3SCxLQUFLO1FBQzdCLElBQUksSUFBSSxDQUFDd1ksT0FBTyxFQUFFO1lBQ2hCLElBQUksSUFBSSxDQUFDMEIsZUFBZSxFQUFFO2dCQUN4QmhkLElBQUksSUFBSSxJQUFJLENBQUNxSixLQUFLO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDMlQsZUFBZSxHQUFHO1lBQ3ZCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDMUIsT0FBTyxDQUFDaFksSUFBSSxDQUFDLElBQUksQ0FBQ29ZLE1BQU0sRUFBRTVZO1lBQ2pDLFNBQVU7Z0JBQ1IsSUFBSSxDQUFDa2EsZUFBZSxHQUFHO1lBQ3pCO1FBQ0YsT0FBTztZQUNMaGQsSUFBSSxJQUFJLElBQUksQ0FBQ3FKLEtBQUs7UUFDcEI7SUFDRjtJQUNBVSxPQUFPNFMsZUFBZSxHQUFHLFNBQVNBO1FBQ2hDLHVDQUF1QztRQUN2QyxJQUFJelAsV0FBVyxJQUFJLENBQUNrTSxNQUFNO1FBQzFCLElBQUk2RCxlQUFlLGFBQWEsR0FBRSxJQUFJLENBQUNuQyxrQkFBa0IsS0FBS25SLGtCQUFrQkMsYUFBYTtRQUM3RixJQUFJMUQsV0FBVyxJQUFJLENBQUNzVyxhQUFhLENBQUM7UUFDbEMsSUFBSVUsVUFBVUQsZ0JBQWdCSCxrQkFBa0I1UCxhQUFhNFAsa0JBQWtCNVcsYUFBYSxDQUFDLElBQUksQ0FBQ3lWLE9BQU8sQ0FBQ3pPLFVBQVVoSDtRQUNwSCxJQUFJZ1gsU0FBUztZQUNYLElBQUksQ0FBQzlELE1BQU0sR0FBR2xUO1lBQ2QsSUFBSW5HLEtBQXFDLElBQUltWCxnQkFBZ0I7Z0JBQzNEb0MsVUFBVTtvQkFDUkMsZ0JBQWdCO29CQUNoQkMsaUJBQWlCLElBQUksQ0FBQ25RLEtBQUs7b0JBQzNCMUYsUUFBUSxJQUFJLENBQUMrWCxNQUFNO29CQUNuQmxFLE1BQU07b0JBQ050SyxVQUFVQTtvQkFDVmhILFVBQVVBO2dCQUNaO1lBQ0Y7UUFDRjtRQUNBLE9BQU9nWDtJQUNUO0lBQ0FuVCxPQUFPeVMsYUFBYSxHQUFHLFNBQVNBLGNBQWNXLEtBQUs7UUFDakQsSUFBSSxDQUFDaEIsV0FBVyxHQUFHO1FBQ25CLCtDQUErQztRQUMvQyxJQUFJdkQsT0FBT1osdUJBQXVCO1FBQ2xDLElBQUlwUztRQUNKLElBQUl1WCxPQUFPO1lBQ1R2WCxNQUFNd1gscUJBQXFCLElBQUksRUFBRSxJQUFJLENBQUN4ZCxVQUFVLEVBQUUsSUFBSSxDQUFDOGIsTUFBTTtRQUMvRCxPQUFPO1lBQ0wsSUFBSXZaLFlBQVlrYixzQkFBc0IsS0FBSyxNQUFNO2dCQUMvQ3pYLE1BQU0sSUFBSSxDQUFDaEcsVUFBVSxDQUFDMEQsSUFBSSxDQUFDLElBQUksQ0FBQ29ZLE1BQU07WUFDeEMsT0FBTztnQkFDTCxJQUFJO29CQUNGOVYsTUFBTSxJQUFJLENBQUNoRyxVQUFVLENBQUMwRCxJQUFJLENBQUMsSUFBSSxDQUFDb1ksTUFBTTtnQkFDeEMsRUFBRSxPQUFPbmIsR0FBRztvQkFDVnFGLE1BQU0sSUFBSXdWLGdCQUFnQjdhO2dCQUM1QjtZQUNGO1FBQ0Y7UUFDQWdZLHFCQUFxQks7UUFDckIsSUFBSSxDQUFDdUQsV0FBVyxHQUFHO1FBQ25CLE9BQU92VztJQUNUO0lBQ0FtRSxPQUFPdVQsUUFBUSxHQUFHLFNBQVNBO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUN6QixVQUFVLEVBQUU7WUFDcEIwQixlQUFlLElBQUk7WUFDbkIsSUFBSSxDQUFDbkUsTUFBTSxHQUFHL00sV0FBVyxtQ0FBbUM7WUFDNUQsSUFBSXRNLEtBQXFDLElBQUksSUFBSSxDQUFDd2IsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLEVBQUU7Z0JBQy9FNU4sUUFBUTJQLEdBQUcsQ0FBQyxrQ0FBa0MsSUFBSSxDQUFDblUsS0FBSyxHQUFHO1lBQzdEO1FBQ0Y7SUFDRjtJQUNBVSxPQUFPd1EsUUFBUSxHQUFHLFNBQVNBLFNBQVN0USxRQUFRLEVBQUV1USxlQUFlO1FBQzNELElBQUl4QixRQUFRLElBQUk7UUFDaEIsSUFBSXlFLFlBQVk7UUFDaEIsSUFBSUMsWUFBWXJSO1FBQ2hCLE9BQU9zUixRQUFRO1lBQ2IsK0hBQStIO1lBQy9ILElBQUl6WCxXQUFXOFMsTUFBTXZPLEdBQUc7WUFDeEIsSUFBSSxDQUFDZ1QsYUFBYWpELGlCQUFpQjtnQkFDakMsSUFBSW9ELFFBQVE3RjtnQkFDWjlOLFNBQVM7b0JBQ1BzUCxnQkFBZ0I7b0JBQ2hCQyxpQkFBaUJSLE1BQU0zUCxLQUFLO29CQUM1Qm1PLE1BQU1vQztvQkFDTmpXLFFBQVFxVjtvQkFDUjlTLFVBQVVBO29CQUNWZ0gsVUFBVXdRO2dCQUNaO2dCQUNBakYsYUFBYW1GO1lBQ2Y7WUFDQUgsWUFBWTtZQUNaQyxZQUFZeFg7UUFDZDtJQUNGO0lBQ0E2RCxPQUFPd1MsdUJBQXVCLEdBQUcsU0FBU0E7UUFDeEMsSUFBSSxLQUFzQyxFQUFJLEVBRTdDO1FBQ0QsSUFBSSxJQUFJLENBQUNoQixVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTtZQUN0QzVOLFFBQVEyUCxHQUFHLENBQUMsa0NBQWtDLElBQUksQ0FBQ25VLEtBQUssR0FBRztRQUM3RDtRQUNBLElBQUksT0FBTyxJQUFJLENBQUN1UyxpQkFBaUIsS0FBSyxZQUFZLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUd6WixZQUFZMGIsd0JBQXdCLEVBQUU7WUFDL0doUSxRQUFRQyxJQUFJLENBQUMsNEJBQTRCLElBQUksQ0FBQ3pFLEtBQUssR0FBRztRQUN4RDtJQUNGO0lBQ0FVLE9BQU81SyxRQUFRLEdBQUcsU0FBU0E7UUFDekIsT0FBTyxJQUFJLENBQUNrSyxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUN6SixVQUFVLENBQUNULFFBQVEsS0FBSztJQUN6RDtJQUNBNEssT0FBTzZRLE9BQU8sR0FBRyxTQUFTQTtRQUN4QixPQUFPclYsWUFBWSxJQUFJLENBQUNrRixHQUFHO0lBQzdCO0lBQ0FWLE1BQU0sQ0FBQ25ELE9BQU9yQixXQUFXLENBQUMsR0FBRztRQUMzQixPQUFPLElBQUksQ0FBQ3FWLE9BQU87SUFDckI7SUFDQSxPQUFPbFUsYUFBYThLLGVBQWU7UUFBQztZQUNsQ3RTLEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFa0ksY0FBY3NNLGdCQUFnQjtZQUM1RDtZQUNBblQsS0FBSyxTQUFTQSxJQUFJekUsUUFBUTtnQkFDeEIsSUFBSSxDQUFDb0QsTUFBTSxHQUFHckQsUUFBUSxJQUFJLENBQUNxRCxNQUFNLEVBQUVrSSxjQUFjc00sZ0JBQWdCLEVBQUU1WDtZQUNyRTtRQUNGO1FBQUc7WUFDRGhILEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFa0ksY0FBY3VNLG9CQUFvQjtZQUNoRTtZQUNBcFQsS0FBSyxTQUFTQSxJQUFJekUsUUFBUTtnQkFDeEIsSUFBSSxDQUFDb0QsTUFBTSxHQUFHckQsUUFBUSxJQUFJLENBQUNxRCxNQUFNLEVBQUVrSSxjQUFjdU0sb0JBQW9CLEVBQUU3WDtZQUN6RTtRQUNGO1FBQUc7WUFDRGhILEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFa0ksY0FBYzlHLG9CQUFvQjtZQUNoRTtZQUNBQyxLQUFLLFNBQVNBLElBQUl6RSxRQUFRO2dCQUN4QixJQUFJLENBQUNvRCxNQUFNLEdBQUdyRCxRQUFRLElBQUksQ0FBQ3FELE1BQU0sRUFBRWtJLGNBQWM5RyxvQkFBb0IsRUFBRXhFO1lBQ3pFO1FBQ0Y7UUFBRztZQUNEaEgsS0FBSztZQUNMdUwsS0FBSyxTQUFTQTtnQkFDWixPQUFPM0UsUUFBUSxJQUFJLENBQUN3RCxNQUFNLEVBQUVrSSxjQUFjNUcsMkJBQTJCO1lBQ3ZFO1lBQ0FELEtBQUssU0FBU0EsSUFBSXpFLFFBQVE7Z0JBQ3hCLElBQUksQ0FBQ29ELE1BQU0sR0FBR3JELFFBQVEsSUFBSSxDQUFDcUQsTUFBTSxFQUFFa0ksY0FBYzVHLDJCQUEyQixFQUFFMUU7WUFDaEY7UUFDRjtRQUFHO1lBQ0RoSCxLQUFLO1lBQ0x1TCxLQUFLLFNBQVNBO2dCQUNaLE9BQU8zRSxRQUFRLElBQUksQ0FBQ3dELE1BQU0sRUFBRWtJLGNBQWMzRyxjQUFjLElBQUksSUFBSTtZQUNsRTtZQUNBRixLQUFLLFNBQVNBLElBQUl6RSxRQUFRO2dCQUN4QixJQUFJLENBQUNvRCxNQUFNLEdBQUdyRCxRQUFRLElBQUksQ0FBQ3FELE1BQU0sRUFBRWtJLGNBQWMzRyxjQUFjLEVBQUUzRSxhQUFhLElBQUksT0FBTztZQUMzRjtRQUNGO0tBQUU7QUFDSjtBQUNBc0wsY0FBY3NNLGdCQUFnQixHQUFHO0FBQ2pDdE0sY0FBY3VNLG9CQUFvQixHQUFHO0FBQ3JDdk0sY0FBYzlHLG9CQUFvQixHQUFHO0FBQ3JDOEcsY0FBYzVHLDJCQUEyQixHQUFHO0FBQzVDNEcsY0FBYzNHLGNBQWMsR0FBRztBQUMvQixJQUFJbVQsa0JBQWtCLFdBQVcsR0FBRS9aLDBCQUEwQixpQkFBaUJ1TjtBQUU5RSxJQUFJN0g7QUFDSCxVQUFVQSxpQkFBaUI7SUFDMUIsNkRBQTZEO0lBQzdELHlFQUF5RTtJQUN6RUEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGdCQUFnQixHQUFHLENBQUMsRUFBRSxHQUFHO0lBQzdELHVEQUF1RDtJQUN2RCwrQkFBK0I7SUFDL0IsK0JBQStCO0lBQy9CQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUMxRCw2RUFBNkU7SUFDN0UsOERBQThEO0lBQzlELDZEQUE2RDtJQUM3RCxFQUFFO0lBQ0YsZ0RBQWdEO0lBQ2hELGdGQUFnRjtJQUNoRkEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGtCQUFrQixHQUFHLEVBQUUsR0FBRztJQUM5RCw2RUFBNkU7SUFDN0UsZ0RBQWdEO0lBQ2hEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUN2RCxHQUFHQSxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBQzlDLElBQUk2UjtBQUNILFVBQVVBLFNBQVM7SUFDbEJBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDbkNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDbENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7QUFDdEMsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLElBQUlKLGtCQUFrQixTQUFTQSxnQkFBZ0IyQixLQUFLO0lBQ2xELElBQUksQ0FBQ0EsS0FBSyxHQUFHLEtBQUs7SUFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0FBQ2IsUUFBUTtBQUNWO0FBQ0EsU0FBU0Qsa0JBQWtCdmMsQ0FBQztJQUMxQixPQUFPQSxhQUFhNmE7QUFDdEI7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU2tCLGNBQWMxYyxVQUFVO0lBQy9CLE9BQVFBLFdBQVdrYixrQkFBa0I7UUFDbkMsS0FBS25SLGtCQUFrQnVSLFdBQVc7WUFDaEMsT0FBTztRQUNULEtBQUt2UixrQkFBa0JDLGFBQWE7UUFDcEMsS0FBS0Qsa0JBQWtCc1UsTUFBTTtZQUMzQixPQUFPO1FBQ1QsS0FBS3RVLGtCQUFrQnVVLGVBQWU7WUFDcEM7Z0JBQ0UsdUVBQXVFO2dCQUN2RSxJQUFJQyxzQkFBc0JqRyxxQkFBcUI7Z0JBQy9DLElBQUlrRyxnQkFBZ0JyRyxrQkFBa0IsOEZBQThGO2dCQUNwSSxJQUFJc0csTUFBTXplLFdBQVdtYixVQUFVLEVBQzdCdUQsSUFBSUQsSUFBSWhmLE1BQU07Z0JBQ2hCLElBQUssSUFBSXNJLElBQUksR0FBR0EsSUFBSTJXLEdBQUczVyxJQUFLO29CQUMxQixJQUFJbkUsTUFBTTZhLEdBQUcsQ0FBQzFXLEVBQUU7b0JBQ2hCLElBQUlxVyxnQkFBZ0J4YSxNQUFNO3dCQUN4QixJQUFJckIsWUFBWWtiLHNCQUFzQixFQUFFOzRCQUN0QzdaLElBQUlpSCxHQUFHO3dCQUNULE9BQU87NEJBQ0wsSUFBSTtnQ0FDRmpILElBQUlpSCxHQUFHOzRCQUNULEVBQUUsT0FBT2xLLEdBQUc7Z0NBQ1Ysb0dBQW9HO2dDQUNwR2tZLGFBQWEyRjtnQ0FDYjVGLG1CQUFtQjJGO2dDQUNuQixPQUFPOzRCQUNUO3dCQUNGO3dCQUNBLCtGQUErRjt3QkFDL0YsMkNBQTJDO3dCQUMzQyxxQ0FBcUM7d0JBQ3JDLElBQUl2ZSxXQUFXa2Isa0JBQWtCLEtBQUtuUixrQkFBa0JzVSxNQUFNLEVBQUU7NEJBQzlEeEYsYUFBYTJGOzRCQUNiNUYsbUJBQW1CMkY7NEJBQ25CLE9BQU87d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FJLDJCQUEyQjNlO2dCQUMzQjZZLGFBQWEyRjtnQkFDYjVGLG1CQUFtQjJGO2dCQUNuQixPQUFPO1lBQ1Q7SUFDSjtBQUNGO0FBQ0EsU0FBU0s7SUFDUCxPQUFPcmMsWUFBWXdWLGtCQUFrQixLQUFLLE1BQU0seUNBQXlDO0FBQzNGO0FBQ0EsU0FBU21DLG9DQUFvQzVPLElBQUk7SUFDL0MsSUFBSSxLQUFzQyxFQUFJLEVBRTdDO0lBQ0QsSUFBSXVULGVBQWV2VCxLQUFLM0IsVUFBVSxDQUFDOFMsSUFBSSxHQUFHO0lBQzFDLDhHQUE4RztJQUM5RyxJQUFJLENBQUNsYSxZQUFZMlYsaUJBQWlCLElBQUsyRyxDQUFBQSxnQkFBZ0J0YyxZQUFZdWMsY0FBYyxLQUFLLFFBQU8sR0FBSTtRQUMvRjdRLFFBQVFDLElBQUksQ0FBQyxZQUFhM0wsQ0FBQUEsWUFBWXVjLGNBQWMsR0FBRyxrSUFBa0ksK1JBQThSLElBQUt4VCxLQUFLN0IsS0FBSztJQUN4ZTtBQUNGO0FBQ0EsU0FBU3NWLDRCQUE0QnhTLFVBQVU7SUFDN0MsSUFBSXBNLEtBQXFDLElBQUksQ0FBQ29DLFlBQVl5YyxlQUFlLElBQUl6YyxZQUFZMGMsMEJBQTBCLEVBQUU7UUFDbkhoUixRQUFRQyxJQUFJLENBQUMsd0JBQXdCM0IsV0FBVzlDLEtBQUssR0FBRztJQUMxRDtBQUNGO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVMrVCxxQkFBcUJ4ZCxVQUFVLEVBQUVrZixDQUFDLEVBQUVoVyxPQUFPO0lBQ2xELElBQUlxVixzQkFBc0JqRyxxQkFBcUI7SUFDL0NxRywyQkFBMkIzZTtJQUMzQiwwREFBMEQ7SUFDMURBLFdBQVdvYixhQUFhLEdBQUcsSUFBSTNhLE1BQy9CLDRFQUE0RTtJQUM1RSwrQ0FBK0M7SUFDL0NULFdBQVdxYixNQUFNLEtBQUssSUFBSSxNQUFNcmIsV0FBV21iLFVBQVUsQ0FBQzFiLE1BQU07SUFDNURPLFdBQVd1YixpQkFBaUIsR0FBRztJQUMvQnZiLFdBQVdxYixNQUFNLEdBQUcsRUFBRTlZLFlBQVk0YyxLQUFLO0lBQ3ZDLElBQUlDLGVBQWU3YyxZQUFZd1Ysa0JBQWtCO0lBQ2pEeFYsWUFBWXdWLGtCQUFrQixHQUFHL1g7SUFDakN1QyxZQUFZaWEsT0FBTztJQUNuQixJQUFJUztJQUNKLElBQUkxYSxZQUFZa2Isc0JBQXNCLEtBQUssTUFBTTtRQUMvQ1IsU0FBU2lDLEVBQUV4YixJQUFJLENBQUN3RjtJQUNsQixPQUFPO1FBQ0wsSUFBSTtZQUNGK1QsU0FBU2lDLEVBQUV4YixJQUFJLENBQUN3RjtRQUNsQixFQUFFLE9BQU92SSxHQUFHO1lBQ1ZzYyxTQUFTLElBQUl6QixnQkFBZ0I3YTtRQUMvQjtJQUNGO0lBQ0E0QixZQUFZaWEsT0FBTztJQUNuQmphLFlBQVl3VixrQkFBa0IsR0FBR3FIO0lBQ2pDQyxpQkFBaUJyZjtJQUNqQnNmLHVDQUF1Q3RmO0lBQ3ZDNFksbUJBQW1CMkY7SUFDbkIsT0FBT3RCO0FBQ1Q7QUFDQSxTQUFTcUMsdUNBQXVDdGYsVUFBVTtJQUN4RCxJQUFJLEtBQXNDLEVBQUksRUFFN0M7SUFDRCxJQUFJQSxXQUFXbWIsVUFBVSxDQUFDMWIsTUFBTSxLQUFLLEdBQUc7UUFDdEM7SUFDRjtJQUNBLElBQUksT0FBT08sV0FBV3VmLG1CQUFtQixLQUFLLFlBQVl2ZixXQUFXdWYsbUJBQW1CLEdBQUdoZCxZQUFZaWQsMEJBQTBCLEVBQUU7UUFDakl2UixRQUFRQyxJQUFJLENBQUMsd0JBQXdCbE8sV0FBV3lKLEtBQUssR0FBRztJQUMxRDtBQUNGO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVM0VixpQkFBaUJyZixVQUFVO0lBQ2xDLDRKQUE0SjtJQUM1SixJQUFJeWYsZ0JBQWdCemYsV0FBV21iLFVBQVU7SUFDekMsSUFBSXVFLFlBQVkxZixXQUFXbWIsVUFBVSxHQUFHbmIsV0FBV29iLGFBQWE7SUFDaEUsSUFBSXVFLG9DQUFvQzVWLGtCQUFrQnVSLFdBQVc7SUFDckUsMEZBQTBGO0lBQzFGLGlEQUFpRDtJQUNqRCxpQ0FBaUM7SUFDakMsSUFBSXNFLEtBQUssR0FDUGxCLElBQUkxZSxXQUFXdWIsaUJBQWlCO0lBQ2xDLElBQUssSUFBSXhULElBQUksR0FBR0EsSUFBSTJXLEdBQUczVyxJQUFLO1FBQzFCLElBQUk4WCxNQUFNSCxTQUFTLENBQUMzWCxFQUFFO1FBQ3RCLElBQUk4WCxJQUFJQyxTQUFTLEtBQUssR0FBRztZQUN2QkQsSUFBSUMsU0FBUyxHQUFHO1lBQ2hCLElBQUlGLE9BQU83WCxHQUFHO2dCQUNaMlgsU0FBUyxDQUFDRSxHQUFHLEdBQUdDO1lBQ2xCO1lBQ0FEO1FBQ0Y7UUFDQSwrRkFBK0Y7UUFDL0YsNEJBQTRCO1FBQzVCLElBQUlDLElBQUkzRSxrQkFBa0IsR0FBR3lFLG1DQUFtQztZQUM5REEsb0NBQW9DRSxJQUFJM0Usa0JBQWtCO1FBQzVEO0lBQ0Y7SUFDQXdFLFVBQVVqZ0IsTUFBTSxHQUFHbWdCO0lBQ25CNWYsV0FBV29iLGFBQWEsR0FBRyxNQUFNLDJHQUEyRztJQUM1SSxpR0FBaUc7SUFDakcsaURBQWlEO0lBQ2pELHFFQUFxRTtJQUNyRXNELElBQUllLGNBQWNoZ0IsTUFBTTtJQUN4QixNQUFPaWYsSUFBSztRQUNWLElBQUlxQixPQUFPTixhQUFhLENBQUNmLEVBQUU7UUFDM0IsSUFBSXFCLEtBQUtELFNBQVMsS0FBSyxHQUFHO1lBQ3hCRSxlQUFlRCxNQUFNL2Y7UUFDdkI7UUFDQStmLEtBQUtELFNBQVMsR0FBRztJQUNuQjtJQUNBLGdGQUFnRjtJQUNoRixnRUFBZ0U7SUFDaEUsMkRBQTJEO0lBQzNELE1BQU9GLEtBQU07UUFDWCxJQUFJSyxRQUFRUCxTQUFTLENBQUNFLEdBQUc7UUFDekIsSUFBSUssTUFBTUgsU0FBUyxLQUFLLEdBQUc7WUFDekJHLE1BQU1ILFNBQVMsR0FBRztZQUNsQkksWUFBWUQsT0FBT2pnQjtRQUNyQjtJQUNGO0lBQ0Esb0ZBQW9GO0lBQ3BGLDJEQUEyRDtJQUMzRCxJQUFJMmYsc0NBQXNDNVYsa0JBQWtCdVIsV0FBVyxFQUFFO1FBQ3ZFdGIsV0FBV2tiLGtCQUFrQixHQUFHeUU7UUFDaEMzZixXQUFXcWMsY0FBYztJQUMzQjtBQUNGO0FBQ0EsU0FBU3NCLGVBQWUzZCxVQUFVO0lBQ2hDLDBHQUEwRztJQUMxRyxJQUFJeWUsTUFBTXplLFdBQVdtYixVQUFVO0lBQy9CbmIsV0FBV21iLFVBQVUsR0FBRyxFQUFFO0lBQzFCLElBQUlwVCxJQUFJMFcsSUFBSWhmLE1BQU07SUFDbEIsTUFBT3NJLElBQUs7UUFDVmlZLGVBQWV2QixHQUFHLENBQUMxVyxFQUFFLEVBQUUvSDtJQUN6QjtJQUNBQSxXQUFXa2Isa0JBQWtCLEdBQUduUixrQkFBa0JDLGFBQWE7QUFDakU7QUFDQSxTQUFTbVcsVUFBVUMsTUFBTTtJQUN2QixJQUFJcEgsT0FBT2I7SUFDWCxJQUFJO1FBQ0YsT0FBT2lJO0lBQ1QsU0FBVTtRQUNSdkgsYUFBYUc7SUFDZjtBQUNGO0FBQ0EsU0FBU2I7SUFDUCxJQUFJYSxPQUFPelcsWUFBWXdWLGtCQUFrQjtJQUN6Q3hWLFlBQVl3VixrQkFBa0IsR0FBRztJQUNqQyxPQUFPaUI7QUFDVDtBQUNBLFNBQVNILGFBQWFHLElBQUk7SUFDeEJ6VyxZQUFZd1Ysa0JBQWtCLEdBQUdpQjtBQUNuQztBQUNBLFNBQVNWLHFCQUFxQjBHLGVBQWU7SUFDM0MsSUFBSWhHLE9BQU96VyxZQUFZeWMsZUFBZTtJQUN0Q3pjLFlBQVl5YyxlQUFlLEdBQUdBO0lBQzlCLE9BQU9oRztBQUNUO0FBQ0EsU0FBU0osbUJBQW1CSSxJQUFJO0lBQzlCelcsWUFBWXljLGVBQWUsR0FBR2hHO0FBQ2hDO0FBQ0E7OztDQUdDLEdBQ0QsU0FBUzJGLDJCQUEyQjNlLFVBQVU7SUFDNUMsSUFBSUEsV0FBV2tiLGtCQUFrQixLQUFLblIsa0JBQWtCdVIsV0FBVyxFQUFFO1FBQ25FO0lBQ0Y7SUFDQXRiLFdBQVdrYixrQkFBa0IsR0FBR25SLGtCQUFrQnVSLFdBQVc7SUFDN0QsSUFBSW1ELE1BQU16ZSxXQUFXbWIsVUFBVTtJQUMvQixJQUFJcFQsSUFBSTBXLElBQUloZixNQUFNO0lBQ2xCLE1BQU9zSSxJQUFLO1FBQ1YwVyxHQUFHLENBQUMxVyxFQUFFLENBQUMrQixvQkFBb0IsR0FBR0Msa0JBQWtCdVIsV0FBVztJQUM3RDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxJQUFJK0UsaUJBQWlCO0lBQUM7SUFBWTtJQUFnQjtJQUFrQjtJQUE0QjtJQUE4QjtJQUE4QjtJQUFtQjtJQUEwQjtJQUFTO0lBQWE7Q0FBYTtBQUM1TyxJQUFJQyxjQUFjLFNBQVNBO0lBQ3pCOzs7Ozs7O0dBT0MsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmOztHQUVDLEdBQ0QsSUFBSSxDQUFDeEcsU0FBUyxHQUFHLENBQUM7SUFDbEI7O0dBRUMsR0FDRCxJQUFJLENBQUNoQyxrQkFBa0IsR0FBRztJQUMxQjs7OztHQUlDLEdBQ0QsSUFBSSxDQUFDK0UsZUFBZSxHQUFHO0lBQ3ZCOztHQUVDLEdBQ0QsSUFBSSxDQUFDcUMsS0FBSyxHQUFHO0lBQ2I7O0dBRUMsR0FDRCxJQUFJLENBQUN6YyxRQUFRLEdBQUc7SUFDaEI7O0dBRUMsR0FDRCxJQUFJLENBQUM4WixPQUFPLEdBQUc7SUFDZjs7Ozs7R0FLQyxHQUNELElBQUksQ0FBQ2dFLHFCQUFxQixHQUFHLEVBQUU7SUFDL0I7O0dBRUMsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7SUFDMUI7O0dBRUMsR0FDRCxJQUFJLENBQUNDLGtCQUFrQixHQUFHO0lBQzFCOzs7O0dBSUMsR0FDRCxJQUFJLENBQUN4SSxpQkFBaUIsR0FBRztJQUN6Qjs7O0dBR0MsR0FDRCxJQUFJLENBQUM4RyxlQUFlLEdBQUc7SUFDdkI7O0dBRUMsR0FDRCxJQUFJLENBQUNGLGNBQWMsR0FBRztJQUN0Qjs7R0FFQyxHQUNELElBQUksQ0FBQzZCLFlBQVksR0FBRyxFQUFFO0lBQ3RCOztHQUVDLEdBQ0QsSUFBSSxDQUFDQywyQkFBMkIsR0FBRyxFQUFFO0lBQ3JDOztHQUVDLEdBQ0QsSUFBSSxDQUFDM0Msd0JBQXdCLEdBQUc7SUFDaEM7OztHQUdDLEdBQ0QsSUFBSSxDQUFDdUIsMEJBQTBCLEdBQUc7SUFDbEM7OztHQUdDLEdBQ0QsSUFBSSxDQUFDUCwwQkFBMEIsR0FBRztJQUNsQzs7O0dBR0MsR0FDRCxJQUFJLENBQUN4QixzQkFBc0IsR0FBRztJQUM5Qjs7O0dBR0MsR0FDRCxJQUFJLENBQUMvRSxzQkFBc0IsR0FBRztJQUM5QixJQUFJLENBQUNyRCxVQUFVLEdBQUc7SUFDbEI7O0dBRUMsR0FDRCxJQUFJLENBQUM3UyxhQUFhLEdBQUc7SUFDckI7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ3lOLGVBQWUsR0FBRztBQUN6QjtBQUNBLElBQUk0USxzQkFBc0I7QUFDMUIsSUFBSUMsZ0JBQWdCO0FBQ3BCLElBQUl2ZSxjQUFjLFdBQVcsR0FBRTtJQUM3QixJQUFJbEIsVUFBUyxXQUFXLEdBQUVIO0lBQzFCLElBQUlHLFFBQU8wZixtQkFBbUIsR0FBRyxLQUFLLENBQUMxZixRQUFPMmYsYUFBYSxFQUFFO1FBQzNESCxzQkFBc0I7SUFDeEI7SUFDQSxJQUFJeGYsUUFBTzJmLGFBQWEsSUFBSTNmLFFBQU8yZixhQUFhLENBQUNULE9BQU8sS0FBSyxJQUFJRCxjQUFjQyxPQUFPLEVBQUU7UUFDdEZNLHNCQUFzQjtJQUN4QjtJQUNBLElBQUksQ0FBQ0EscUJBQXFCO1FBQ3hCLHlFQUF5RTtRQUN6RSxtRUFBbUU7UUFDbkVJLFdBQVc7WUFDVCxJQUFJLENBQUNILGVBQWU7Z0JBQ2xCMWdCLElBQUk7WUFDTjtRQUNGLEdBQUc7UUFDSCxPQUFPLElBQUlrZ0I7SUFDYixPQUFPLElBQUlqZixRQUFPMmYsYUFBYSxFQUFFO1FBQy9CM2YsUUFBTzBmLG1CQUFtQixJQUFJO1FBQzlCLElBQUksQ0FBQzFmLFFBQU8yZixhQUFhLENBQUNqSCxTQUFTLEVBQUU7WUFDbkMxWSxRQUFPMmYsYUFBYSxDQUFDakgsU0FBUyxHQUFHLENBQUM7UUFDcEMsRUFBRSxpQ0FBaUM7UUFDbkMsT0FBTzFZLFFBQU8yZixhQUFhO0lBQzdCLE9BQU87UUFDTDNmLFFBQU8wZixtQkFBbUIsR0FBRztRQUM3QixPQUFPMWYsUUFBTzJmLGFBQWEsR0FBRyxXQUFXLEdBQUUsSUFBSVY7SUFDakQ7QUFDRjtBQUNBLFNBQVNZO0lBQ1AsSUFBSTNlLFlBQVlrZSxnQkFBZ0IsQ0FBQ2hoQixNQUFNLElBQUk4QyxZQUFZaWEsT0FBTyxJQUFJamEsWUFBWW1lLGtCQUFrQixFQUFFO1FBQ2hHdGdCLElBQUk7SUFDTjtJQUNBMGdCLGdCQUFnQjtJQUNoQixJQUFJRCxxQkFBcUI7UUFDdkIsSUFBSXhmLFVBQVNIO1FBQ2IsSUFBSSxFQUFFRyxRQUFPMGYsbUJBQW1CLEtBQUssR0FBRztZQUN0QzFmLFFBQU8yZixhQUFhLEdBQUd2VTtRQUN6QjtRQUNBbEssY0FBYyxJQUFJK2Q7SUFDcEI7QUFDRjtBQUNBLFNBQVNhO0lBQ1AsT0FBTzVlO0FBQ1Q7QUFDQTs7O0NBR0MsR0FDRCxTQUFTNmU7SUFDUCxJQUFJQyxpQkFBaUIsSUFBSWY7SUFDekIsSUFBSyxJQUFJaGhCLE9BQU8raEIsZUFBZ0I7UUFDOUIsSUFBSWhCLGVBQWVpQixPQUFPLENBQUNoaUIsU0FBUyxDQUFDLEdBQUc7WUFDdENpRCxXQUFXLENBQUNqRCxJQUFJLEdBQUcraEIsY0FBYyxDQUFDL2hCLElBQUk7UUFDeEM7SUFDRjtJQUNBaUQsWUFBWTJWLGlCQUFpQixHQUFHLENBQUMzVixZQUFZdWMsY0FBYztBQUM3RDtBQUVBLFNBQVNELGFBQWF0UyxVQUFVO0lBQzlCLE9BQU9BLFdBQVc1QyxVQUFVLElBQUk0QyxXQUFXNUMsVUFBVSxDQUFDOFMsSUFBSSxHQUFHO0FBQy9EO0FBQ0EsU0FBUzhFLGFBQWFoVixVQUFVO0lBQzlCLE9BQU9BLFdBQVc1QyxVQUFVO0FBQzlCO0FBQ0EseURBQXlEO0FBQ3pELHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsbUJBQW1CO0FBQ25CLHFIQUFxSDtBQUNySCxtQkFBbUI7QUFDbkIseUhBQXlIO0FBQ3pILFlBQVk7QUFDWixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCLDRFQUE0RTtBQUM1RSxtREFBbUQ7QUFDbkQsUUFBUTtBQUNSLElBQUk7QUFDSixTQUFTdVcsWUFBWTNULFVBQVUsRUFBRWlWLElBQUk7SUFDbkMscUdBQXFHO0lBQ3JHLGtHQUFrRztJQUNsRyxrQ0FBa0M7SUFDbENqVixXQUFXNUMsVUFBVSxDQUFDZ0osR0FBRyxDQUFDNk87SUFDMUIsSUFBSWpWLFdBQVd6QyxvQkFBb0IsR0FBRzBYLEtBQUt0RyxrQkFBa0IsRUFBRTtRQUM3RDNPLFdBQVd6QyxvQkFBb0IsR0FBRzBYLEtBQUt0RyxrQkFBa0I7SUFDM0Q7QUFDQSxrQ0FBa0M7QUFDbEMsMkZBQTJGO0FBQzdGO0FBQ0EsU0FBUzhFLGVBQWV6VCxVQUFVLEVBQUVpVixJQUFJO0lBQ3RDLG1HQUFtRztJQUNuRyx1R0FBdUc7SUFDdkcsa0NBQWtDO0lBQ2xDalYsV0FBVzVDLFVBQVUsQ0FBQyxTQUFTLENBQUM2WDtJQUNoQyxJQUFJalYsV0FBVzVDLFVBQVUsQ0FBQzhTLElBQUksS0FBSyxHQUFHO1FBQ3BDLHlCQUF5QjtRQUN6QmdGLHNCQUFzQmxWO0lBQ3hCO0FBQ0Esa0NBQWtDO0FBQ2xDLHdHQUF3RztBQUMxRztBQUNBLFNBQVNrVixzQkFBc0JsVixVQUFVO0lBQ3ZDLElBQUlBLFdBQVdtVixzQkFBc0IsS0FBSyxPQUFPO1FBQy9DLCtIQUErSDtRQUMvSG5WLFdBQVdtVixzQkFBc0IsR0FBRztRQUNwQ25mLFlBQVlpZSxxQkFBcUIsQ0FBQ21CLElBQUksQ0FBQ3BWO0lBQ3pDO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzdCO0lBQ1BuSSxZQUFZaWEsT0FBTztBQUNyQjtBQUNBLFNBQVM1UjtJQUNQLElBQUksRUFBRXJJLFlBQVlpYSxPQUFPLEtBQUssR0FBRztRQUMvQm9GO1FBQ0EsNkVBQTZFO1FBQzdFLElBQUlDLE9BQU90ZixZQUFZaWUscUJBQXFCO1FBQzVDLElBQUssSUFBSXpZLElBQUksR0FBR0EsSUFBSThaLEtBQUtwaUIsTUFBTSxFQUFFc0ksSUFBSztZQUNwQyxJQUFJd0UsYUFBYXNWLElBQUksQ0FBQzlaLEVBQUU7WUFDeEJ3RSxXQUFXbVYsc0JBQXNCLEdBQUc7WUFDcEMsSUFBSW5WLFdBQVc1QyxVQUFVLENBQUM4UyxJQUFJLEtBQUssR0FBRztnQkFDcEMsSUFBSWxRLFdBQVd1VixlQUFlLEVBQUU7b0JBQzlCLCtEQUErRDtvQkFDL0R2VixXQUFXdVYsZUFBZSxHQUFHO29CQUM3QnZWLFdBQVdqQyxLQUFLO2dCQUNsQjtnQkFDQSxJQUFJaUMsc0JBQXNCcUYsZUFBZTtvQkFDdkMsOEVBQThFO29CQUM5RSxnR0FBZ0c7b0JBQ2hHckYsV0FBV21SLFFBQVE7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUNBbmIsWUFBWWllLHFCQUFxQixHQUFHLEVBQUU7SUFDeEM7QUFDRjtBQUNBLFNBQVNqVyxlQUFlZ0MsVUFBVTtJQUNoQ3dTLDRCQUE0QnhTO0lBQzVCLElBQUl2TSxhQUFhdUMsWUFBWXdWLGtCQUFrQjtJQUMvQyxJQUFJL1gsZUFBZSxNQUFNO1FBQ3ZCOzs7O0tBSUMsR0FDRCxJQUFJQSxXQUFXcWIsTUFBTSxLQUFLOU8sV0FBVzFDLGVBQWUsRUFBRTtZQUNwRDBDLFdBQVcxQyxlQUFlLEdBQUc3SixXQUFXcWIsTUFBTTtZQUM5QyxpR0FBaUc7WUFDakdyYixXQUFXb2IsYUFBYSxDQUFDcGIsV0FBV3ViLGlCQUFpQixHQUFHLEdBQUdoUDtZQUMzRCxJQUFJLENBQUNBLFdBQVd1VixlQUFlLElBQUl2ZixZQUFZdWEsZUFBZSxFQUFFO2dCQUM5RHZRLFdBQVd1VixlQUFlLEdBQUc7Z0JBQzdCdlYsV0FBV25DLElBQUk7WUFDakI7UUFDRjtRQUNBLE9BQU9tQyxXQUFXdVYsZUFBZTtJQUNuQyxPQUFPLElBQUl2VixXQUFXNUMsVUFBVSxDQUFDOFMsSUFBSSxLQUFLLEtBQUtsYSxZQUFZaWEsT0FBTyxHQUFHLEdBQUc7UUFDdEVpRixzQkFBc0JsVjtJQUN4QjtJQUNBLE9BQU87QUFDVDtBQUNBLGdFQUFnRTtBQUNoRSxnR0FBZ0c7QUFDaEcsaUdBQWlHO0FBQ2pHLDhHQUE4RztBQUM5Ryx1QkFBdUI7QUFDdkIsZ0RBQWdEO0FBQ2hELG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0Qiw2Q0FBNkM7QUFDN0MsUUFBUTtBQUNSLElBQUk7QUFDSjs7Ozs7O0NBTUMsR0FDRCx3Q0FBd0M7QUFDeEMsU0FBUzVCLGlCQUFpQjRCLFVBQVU7SUFDbEMsNkNBQTZDO0lBQzdDLElBQUlBLFdBQVd6QyxvQkFBb0IsS0FBS0Msa0JBQWtCc1UsTUFBTSxFQUFFO1FBQ2hFO0lBQ0Y7SUFDQTlSLFdBQVd6QyxvQkFBb0IsR0FBR0Msa0JBQWtCc1UsTUFBTTtJQUMxRCw4RUFBOEU7SUFDOUU5UixXQUFXNUMsVUFBVSxDQUFDMUQsT0FBTyxDQUFDLFNBQVU4YixDQUFDO1FBQ3ZDLElBQUlBLEVBQUU3RyxrQkFBa0IsS0FBS25SLGtCQUFrQnVSLFdBQVcsRUFBRTtZQUMxRCxJQUFJbmIsS0FBcUMsSUFBSTRoQixFQUFFcEcsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLEVBQUU7Z0JBQzVFbUcsYUFBYUQsR0FBR3hWO1lBQ2xCO1lBQ0F3VixFQUFFMUYsY0FBYztRQUNsQjtRQUNBMEYsRUFBRTdHLGtCQUFrQixHQUFHblIsa0JBQWtCc1UsTUFBTTtJQUNqRDtBQUNBLDJDQUEyQztBQUM3QztBQUNBLG9FQUFvRTtBQUNwRSxTQUFTckIseUJBQXlCelEsVUFBVTtJQUMxQywrQ0FBK0M7SUFDL0MsSUFBSUEsV0FBV3pDLG9CQUFvQixLQUFLQyxrQkFBa0JzVSxNQUFNLEVBQUU7UUFDaEU7SUFDRjtJQUNBOVIsV0FBV3pDLG9CQUFvQixHQUFHQyxrQkFBa0JzVSxNQUFNO0lBQzFEOVIsV0FBVzVDLFVBQVUsQ0FBQzFELE9BQU8sQ0FBQyxTQUFVOGIsQ0FBQztRQUN2QyxJQUFJQSxFQUFFN0csa0JBQWtCLEtBQUtuUixrQkFBa0J1VSxlQUFlLEVBQUU7WUFDOUR5RCxFQUFFN0csa0JBQWtCLEdBQUduUixrQkFBa0JzVSxNQUFNO1lBQy9DLElBQUlsZSxLQUFxQyxJQUFJNGhCLEVBQUVwRyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTtnQkFDNUVtRyxhQUFhRCxHQUFHeFY7WUFDbEI7UUFDRixPQUFPLElBQUl3VixFQUFFN0csa0JBQWtCLEtBQUtuUixrQkFBa0J1UixXQUFXLENBQUMsa0ZBQWtGO1VBQ2xKO1lBQ0EvTyxXQUFXekMsb0JBQW9CLEdBQUdDLGtCQUFrQnVSLFdBQVc7UUFDakU7SUFDRjtBQUNBLDZDQUE2QztBQUMvQztBQUNBLDZGQUE2RjtBQUM3RixTQUFTZ0Isc0JBQXNCL1AsVUFBVTtJQUN2QywyQ0FBMkM7SUFDM0MsSUFBSUEsV0FBV3pDLG9CQUFvQixLQUFLQyxrQkFBa0J1UixXQUFXLEVBQUU7UUFDckU7SUFDRjtJQUNBL08sV0FBV3pDLG9CQUFvQixHQUFHQyxrQkFBa0J1VSxlQUFlO0lBQ25FL1IsV0FBVzVDLFVBQVUsQ0FBQzFELE9BQU8sQ0FBQyxTQUFVOGIsQ0FBQztRQUN2QyxJQUFJQSxFQUFFN0csa0JBQWtCLEtBQUtuUixrQkFBa0J1UixXQUFXLEVBQUU7WUFDMUR5RyxFQUFFN0csa0JBQWtCLEdBQUduUixrQkFBa0J1VSxlQUFlO1lBQ3hEeUQsRUFBRTFGLGNBQWM7UUFDbEI7SUFDRjtBQUNBLHlDQUF5QztBQUMzQztBQUNBLFNBQVMyRixhQUFhaGlCLFVBQVUsRUFBRXVNLFVBQVU7SUFDMUMwQixRQUFRMlAsR0FBRyxDQUFDLG1CQUFtQjVkLFdBQVd5SixLQUFLLEdBQUcsMkNBQTJDOEMsV0FBVzlDLEtBQUssR0FBRztJQUNoSCxJQUFJekosV0FBVzJiLFVBQVUsS0FBS0MsVUFBVXFHLEtBQUssRUFBRTtRQUM3QyxJQUFJQyxRQUFRLEVBQUU7UUFDZEMsYUFBYUMsa0JBQWtCcGlCLGFBQWFraUIsT0FBTztRQUNuRCxrQkFBa0I7UUFDbEIsSUFBSUcsU0FBUyw2QkFBNkJyaUIsV0FBV3lKLEtBQUssR0FBRyxnRUFBZ0V6SixXQUFXeUosS0FBSyxHQUFHLDRCQUE0QjhDLFdBQVc5QyxLQUFLLEdBQUcsNE9BQTZPekosQ0FBQUEsc0JBQXNCNFIsZ0JBQWdCNVIsV0FBV0EsVUFBVSxDQUFDVCxRQUFRLEdBQUcraUIsT0FBTyxDQUFDLFVBQVUsT0FBTyxFQUFDLElBQUssc0RBQXNESixNQUFNbGhCLElBQUksQ0FBQyxRQUFRO0lBQzdsQjtBQUNGO0FBQ0EsU0FBU21oQixhQUFhSSxJQUFJLEVBQUVMLEtBQUssRUFBRU0sS0FBSztJQUN0QyxJQUFJTixNQUFNemlCLE1BQU0sSUFBSSxNQUFNO1FBQ3hCeWlCLE1BQU1QLElBQUksQ0FBQztRQUNYO0lBQ0Y7SUFDQU8sTUFBTVAsSUFBSSxDQUFDLEtBQUssSUFBS2MsTUFBTSxDQUFDRCxRQUFRLEtBQUtELEtBQUszaUIsSUFBSTtJQUNsRCxJQUFJMmlCLEtBQUtHLFlBQVksRUFBRTtRQUNyQkgsS0FBS0csWUFBWSxDQUFDemMsT0FBTyxDQUFDLFNBQVUwYyxLQUFLO1lBQ3ZDLE9BQU9SLGFBQWFRLE9BQU9ULE9BQU9NLFFBQVE7UUFDNUM7SUFDRjtBQUNGO0FBRUEsSUFBSUksV0FBVyxXQUFXLEdBQUU7SUFDMUIsU0FBU0EsU0FBU25aLEtBQUssRUFBRW9aLGFBQWEsRUFBRUMsYUFBYSxFQUFFdkQsbUJBQW1CO1FBQ3hFLElBQUk5VixVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUXRKLEtBQXFDLEdBQUcsY0FBY3NDLGNBQWMsQ0FBVTtRQUN4RjtRQUNBLElBQUksQ0FBQ2dILEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ29aLGFBQWEsR0FBRyxLQUFLO1FBQzFCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLEtBQUs7UUFDMUIsSUFBSSxDQUFDdkQsbUJBQW1CLEdBQUcsS0FBSztRQUNoQyxJQUFJLENBQUNwRSxVQUFVLEdBQUcsRUFBRTtRQUNwQiw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNGLGtCQUFrQixHQUFHblIsa0JBQWtCQyxhQUFhO1FBQ3pELElBQUksQ0FBQ3FSLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDN1IsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDaVMsVUFBVSxHQUFHQyxVQUFVQyxJQUFJO1FBQ2hDLElBQUksQ0FBQ3BTLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNvWixhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUN2RCxtQkFBbUIsR0FBR0E7SUFDN0I7SUFDQSxJQUFJcFYsU0FBU3lZLFNBQVMvZ0IsU0FBUztJQUMvQnNJLE9BQU9rUyxjQUFjLEdBQUcsU0FBU0E7UUFDL0IsSUFBSSxDQUFDMEcsU0FBUztJQUNoQjtJQUNBNVksT0FBTzRZLFNBQVMsR0FBRyxTQUFTQTtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDQyxXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUc7WUFDbkJ6Z0IsWUFBWWtlLGdCQUFnQixDQUFDa0IsSUFBSSxDQUFDLElBQUk7WUFDdENDO1FBQ0Y7SUFDRixFQUNBOztHQUVDO0lBQ0R6WCxPQUFPOFksWUFBWSxHQUFHLFNBQVNBO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUNDLFVBQVUsRUFBRTtZQUNwQnhZO1lBQ0EsSUFBSSxDQUFDc1ksV0FBVyxHQUFHO1lBQ25CLElBQUloSyxPQUFPelcsWUFBWXVhLGVBQWU7WUFDdEN2YSxZQUFZdWEsZUFBZSxHQUFHLElBQUk7WUFDbEMsSUFBSUosY0FBYyxJQUFJLEdBQUc7Z0JBQ3ZCLElBQUksQ0FBQ3lHLGNBQWMsR0FBRztnQkFDdEIsSUFBSTtvQkFDRixJQUFJLENBQUNOLGFBQWE7b0JBQ2xCLElBQUkxaUIsS0FBcUMsSUFBSSxJQUFJLENBQUNnakIsY0FBYyxJQUFJN0wsZ0JBQWdCO3dCQUNsRixpREFBaUQ7d0JBQ2pEb0MsVUFBVTs0QkFDUjlaLE1BQU0sSUFBSSxDQUFDNkosS0FBSzs0QkFDaEJtTyxNQUFNO3dCQUNSO29CQUNGO2dCQUNGLEVBQUUsT0FBT2pYLEdBQUc7b0JBQ1YsSUFBSSxDQUFDeWlCLDRCQUE0QixDQUFDemlCO2dCQUNwQztZQUNGO1lBQ0E0QixZQUFZdWEsZUFBZSxHQUFHOUQ7WUFDOUJwTztRQUNGO0lBQ0Y7SUFDQVQsT0FBT29ULEtBQUssR0FBRyxTQUFTQSxNQUFNdmEsRUFBRTtRQUM5QixJQUFJLElBQUksQ0FBQ2tnQixVQUFVLEVBQUU7WUFDbkI7UUFDQSw0RkFBNEY7UUFDOUY7UUFDQXhZO1FBQ0EsSUFBSTJZLFNBQVMvTDtRQUNiLElBQUlnTTtRQUNKLElBQUluakIsS0FBcUMsSUFBSWtqQixRQUFRO1lBQ25EQyxZQUFZOUwsS0FBS0MsR0FBRztZQUNwQkUsZUFBZTtnQkFDYi9YLE1BQU0sSUFBSSxDQUFDNkosS0FBSztnQkFDaEJtTyxNQUFNO1lBQ1I7UUFDRjtRQUNBLElBQUksQ0FBQzJMLFNBQVMsR0FBRztRQUNqQixJQUFJQyxlQUFlamhCLFlBQVl1YSxlQUFlLEVBQUUsc0NBQXNDO1FBQ3RGdmEsWUFBWXVhLGVBQWUsR0FBRyxJQUFJO1FBQ2xDLElBQUlHLFNBQVNPLHFCQUFxQixJQUFJLEVBQUV4YSxJQUFJeUo7UUFDNUNsSyxZQUFZdWEsZUFBZSxHQUFHMEc7UUFDOUIsSUFBSSxDQUFDRCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDSixjQUFjLEdBQUc7UUFDdEIsSUFBSSxJQUFJLENBQUNELFVBQVUsRUFBRTtZQUNuQix1RkFBdUY7WUFDdkZ2RixlQUFlLElBQUk7UUFDckI7UUFDQSxJQUFJVCxrQkFBa0JELFNBQVM7WUFDN0IsSUFBSSxDQUFDbUcsNEJBQTRCLENBQUNuRyxPQUFPRSxLQUFLO1FBQ2hEO1FBQ0EsSUFBSWhkLEtBQXFDLElBQUlrakIsUUFBUTtZQUNuRHZLLGFBQWE7Z0JBQ1hDLE1BQU12QixLQUFLQyxHQUFHLEtBQUs2TDtZQUNyQjtRQUNGO1FBQ0ExWTtJQUNGO0lBQ0FULE9BQU9pWiw0QkFBNEIsR0FBRyxTQUFTQSw2QkFBNkIvaUIsS0FBSztRQUMvRSxJQUFJK1ksUUFBUSxJQUFJO1FBQ2hCLElBQUksSUFBSSxDQUFDMEosYUFBYSxFQUFFO1lBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDemlCLE9BQU8sSUFBSTtZQUM5QjtRQUNGO1FBQ0EsSUFBSWtDLFlBQVlrYixzQkFBc0IsRUFBRTtZQUN0QyxNQUFNcGQ7UUFDUjtRQUNBLElBQUlvakIsVUFBVXRqQixLQUFxQyxHQUFHLHdHQUF3RyxJQUFJLEdBQUcsTUFBTSxDQUF5QztRQUNwTixJQUFJLENBQUNvQyxZQUFZbVcsc0JBQXNCLEVBQUU7WUFDdkN6SyxRQUFRNU4sS0FBSyxDQUFDb2pCLFNBQVNwakI7UUFDdkIsNEVBQTRFLEdBQzlFLE9BQU8sSUFBSUYsSUFBcUMsRUFBRTtZQUNoRDhOLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBSSxDQUFDekUsS0FBSyxHQUFHO1FBQzVELEVBQUUsa0JBQWtCO1FBQ3BCLElBQUl0SixLQUFxQyxJQUFJbVgsZ0JBQWdCO1lBQzNEb0MsVUFBVTtnQkFDUjlCLE1BQU07Z0JBQ05oWSxNQUFNLElBQUksQ0FBQzZKLEtBQUs7Z0JBQ2hCZ2EsU0FBU0E7Z0JBQ1RwakIsT0FBTyxLQUFLQTtZQUNkO1FBQ0Y7UUFDQWtDLFlBQVlxZSwyQkFBMkIsQ0FBQzNhLE9BQU8sQ0FBQyxTQUFVaVosQ0FBQztZQUN6RCxPQUFPQSxFQUFFN2UsT0FBTytZO1FBQ2xCO0lBQ0Y7SUFDQWpQLE9BQU91WixPQUFPLEdBQUcsU0FBU0E7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ1IsVUFBVSxFQUFFO1lBQ3BCLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUNLLFNBQVMsRUFBRTtnQkFDbkIsOEVBQThFO2dCQUM5RTdZO2dCQUNBaVQsZUFBZSxJQUFJO2dCQUNuQi9TO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FULE9BQU93WixZQUFZLEdBQUcsU0FBU0EsYUFBYUMsV0FBVztRQUNyRCxJQUFJQyxTQUFTLElBQUk7UUFDakIsSUFBSUgsVUFBVSxTQUFTQTtZQUNyQkcsT0FBT0gsT0FBTztZQUNkRSxlQUFlLFFBQVFBLFlBQVlFLG1CQUFtQixJQUFJLFFBQVFGLFlBQVlFLG1CQUFtQixDQUFDLFNBQVNKO1FBQzdHO1FBQ0FFLGVBQWUsUUFBUUEsWUFBWUcsZ0JBQWdCLElBQUksUUFBUUgsWUFBWUcsZ0JBQWdCLENBQUMsU0FBU0w7UUFDckdBLE9BQU8sQ0FBQ25hLE1BQU0sR0FBRyxJQUFJO1FBQ3JCLE9BQU9tYTtJQUNUO0lBQ0F2WixPQUFPNUssUUFBUSxHQUFHLFNBQVNBO1FBQ3pCLE9BQU8sY0FBYyxJQUFJLENBQUNrSyxLQUFLLEdBQUc7SUFDcEM7SUFDQVUsT0FBTzZaLEtBQUssR0FBRyxTQUFTQyxRQUFRQyxlQUFlO1FBQzdDLElBQUlBLG9CQUFvQixLQUFLLEdBQUc7WUFDOUJBLGtCQUFrQjtRQUNwQjtRQUNBRixNQUFNLElBQUksRUFBRUU7SUFDZDtJQUNBLE9BQU9wZCxhQUFhOGIsVUFBVTtRQUFDO1lBQzdCdGpCLEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTzNFLFFBQVEsSUFBSSxDQUFDd0QsTUFBTSxFQUFFa1osU0FBU3VCLGVBQWU7WUFDdEQ7WUFDQXBaLEtBQUssU0FBU0EsSUFBSXpFLFFBQVE7Z0JBQ3hCLElBQUksQ0FBQ29ELE1BQU0sR0FBR3JELFFBQVEsSUFBSSxDQUFDcUQsTUFBTSxFQUFFa1osU0FBU3VCLGVBQWUsRUFBRTdkO1lBQy9EO1FBQ0Y7UUFBRztZQUNEaEgsS0FBSztZQUNMdUwsS0FBSyxTQUFTQTtnQkFDWixPQUFPM0UsUUFBUSxJQUFJLENBQUN3RCxNQUFNLEVBQUVrWixTQUFTd0IsZ0JBQWdCO1lBQ3ZEO1lBQ0FyWixLQUFLLFNBQVNBLElBQUl6RSxRQUFRO2dCQUN4QixJQUFJLENBQUNvRCxNQUFNLEdBQUdyRCxRQUFRLElBQUksQ0FBQ3FELE1BQU0sRUFBRWtaLFNBQVN3QixnQkFBZ0IsRUFBRTlkO1lBQ2hFO1FBQ0Y7UUFBRztZQUNEaEgsS0FBSztZQUNMdUwsS0FBSyxTQUFTQTtnQkFDWixPQUFPM0UsUUFBUSxJQUFJLENBQUN3RCxNQUFNLEVBQUVrWixTQUFTeUIsbUJBQW1CO1lBQzFEO1lBQ0F0WixLQUFLLFNBQVNBLElBQUl6RSxRQUFRO2dCQUN4QixJQUFJLENBQUNvRCxNQUFNLEdBQUdyRCxRQUFRLElBQUksQ0FBQ3FELE1BQU0sRUFBRWtaLFNBQVN5QixtQkFBbUIsRUFBRS9kO1lBQ25FO1FBQ0Y7UUFBRztZQUNEaEgsS0FBSztZQUNMdUwsS0FBSyxTQUFTQTtnQkFDWixPQUFPM0UsUUFBUSxJQUFJLENBQUN3RCxNQUFNLEVBQUVrWixTQUFTMEIsY0FBYztZQUNyRDtZQUNBdlosS0FBSyxTQUFTQSxJQUFJekUsUUFBUTtnQkFDeEIsSUFBSSxDQUFDb0QsTUFBTSxHQUFHckQsUUFBUSxJQUFJLENBQUNxRCxNQUFNLEVBQUVrWixTQUFTMEIsY0FBYyxFQUFFaGU7WUFDOUQ7UUFDRjtRQUFHO1lBQ0RoSCxLQUFLO1lBQ0x1TCxLQUFLLFNBQVNBO2dCQUNaLE9BQU8zRSxRQUFRLElBQUksQ0FBQ3dELE1BQU0sRUFBRWtaLFNBQVMzWCxjQUFjLElBQUksSUFBSTtZQUM3RDtZQUNBRixLQUFLLFNBQVNBLElBQUl6RSxRQUFRO2dCQUN4QixJQUFJLENBQUNvRCxNQUFNLEdBQUdyRCxRQUFRLElBQUksQ0FBQ3FELE1BQU0sRUFBRWtaLFNBQVMzWCxjQUFjLEVBQUUzRSxhQUFhLElBQUksT0FBTztZQUN0RjtRQUNGO0tBQUU7QUFDSjtBQUNBc2MsU0FBU3VCLGVBQWUsR0FBRztBQUMzQnZCLFNBQVN3QixnQkFBZ0IsR0FBRztBQUM1QnhCLFNBQVN5QixtQkFBbUIsR0FBRztBQUMvQnpCLFNBQVMwQixjQUFjLEdBQUc7QUFDMUIxQixTQUFTM1gsY0FBYyxHQUFHO0FBQzFCLFNBQVNzWixnQkFBZ0I5SixPQUFPO0lBQzlCbFksWUFBWXFlLDJCQUEyQixDQUFDZSxJQUFJLENBQUNsSDtJQUM3QyxPQUFPO1FBQ0wsSUFBSStKLE1BQU1qaUIsWUFBWXFlLDJCQUEyQixDQUFDVSxPQUFPLENBQUM3RztRQUMxRCxJQUFJK0osT0FBTyxHQUFHO1lBQ1pqaUIsWUFBWXFlLDJCQUEyQixDQUFDNkQsTUFBTSxDQUFDRCxLQUFLO1FBQ3REO0lBQ0Y7QUFDRjtBQUNBOzs7O0NBSUMsR0FDRCxJQUFJRSwwQkFBMEI7QUFDOUIsSUFBSUMsb0JBQW9CLFNBQVNBLGtCQUFrQnpGLENBQUM7SUFDbEQsT0FBT0E7QUFDVDtBQUNBLFNBQVMwQztJQUNQLHFGQUFxRjtJQUNyRixJQUFJcmYsWUFBWWlhLE9BQU8sR0FBRyxLQUFLamEsWUFBWW1lLGtCQUFrQixFQUFFO1FBQzdEO0lBQ0Y7SUFDQWlFLGtCQUFrQkM7QUFDcEI7QUFDQSxTQUFTQTtJQUNQcmlCLFlBQVltZSxrQkFBa0IsR0FBRztJQUNqQyxJQUFJbUUsZUFBZXRpQixZQUFZa2UsZ0JBQWdCO0lBQy9DLElBQUlxRSxhQUFhO0lBQ2pCLDZEQUE2RDtJQUM3RCxxREFBcUQ7SUFDckQsdURBQXVEO0lBQ3ZELE1BQU9ELGFBQWFwbEIsTUFBTSxHQUFHLEVBQUc7UUFDOUIsSUFBSSxFQUFFcWxCLGVBQWVKLHlCQUF5QjtZQUM1Q3pXLFFBQVE1TixLQUFLLENBQUNGLEtBQXFDLEdBQUcsdURBQXVEdWtCLDBCQUEwQixpQkFBa0IsMkRBQTBERyxZQUFZLENBQUMsRUFBRSxJQUFJLENBQThDO1lBQ3BSQSxhQUFhSixNQUFNLENBQUMsSUFBSSxrQkFBa0I7UUFDNUM7UUFDQSxJQUFJTSxxQkFBcUJGLGFBQWFKLE1BQU0sQ0FBQztRQUM3QyxJQUFLLElBQUkxYyxJQUFJLEdBQUcyVyxJQUFJcUcsbUJBQW1CdGxCLE1BQU0sRUFBRXNJLElBQUkyVyxHQUFHM1csSUFBSztZQUN6RGdkLGtCQUFrQixDQUFDaGQsRUFBRSxDQUFDa2IsWUFBWTtRQUNwQztJQUNGO0lBQ0ExZ0IsWUFBWW1lLGtCQUFrQixHQUFHO0FBQ25DO0FBQ0EsSUFBSXNFLGFBQWEsV0FBVyxHQUFFM2dCLDBCQUEwQixZQUFZdWU7QUFDcEUsU0FBU3FDLHFCQUFxQmppQixFQUFFO0lBQzlCLElBQUlraUIsZ0JBQWdCUDtJQUNwQkEsb0JBQW9CLFNBQVNBLGtCQUFrQnpGLENBQUM7UUFDOUMsT0FBT2xjLEdBQUc7WUFDUixPQUFPa2lCLGNBQWNoRztRQUN2QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTNUg7SUFDUCxPQUFPblgsS0FBcUMsSUFBSSxDQUFDLENBQUNvQyxZQUFZb2UsWUFBWSxDQUFDbGhCLE1BQU07QUFDbkY7QUFDQSxTQUFTaWEsVUFBVXlMLEtBQUs7SUFDdEIsSUFBSSxLQUFzQyxFQUFJLEVBRTdDLENBQUMsd0NBQXdDO0lBQzFDLElBQUksQ0FBQzVpQixZQUFZb2UsWUFBWSxDQUFDbGhCLE1BQU0sRUFBRTtRQUNwQztJQUNGO0lBQ0EsSUFBSTJsQixZQUFZN2lCLFlBQVlvZSxZQUFZO0lBQ3hDLElBQUssSUFBSTVZLElBQUksR0FBRzJXLElBQUkwRyxVQUFVM2xCLE1BQU0sRUFBRXNJLElBQUkyVyxHQUFHM1csSUFBSztRQUNoRHFkLFNBQVMsQ0FBQ3JkLEVBQUUsQ0FBQ29kO0lBQ2Y7QUFDRjtBQUNBLFNBQVN4TixlQUFld04sS0FBSztJQUMzQixJQUFJLEtBQXNDLEVBQUksRUFFN0M7SUFDRCxJQUFJL0ssU0FBUzVTLFNBQVMsQ0FBQyxHQUFHMmQsT0FBTztRQUMvQnhOLGdCQUFnQjtJQUNsQjtJQUNBK0IsVUFBVVU7QUFDWjtBQUNBLElBQUlpTCxZQUFZO0lBQ2R6TixNQUFNO0lBQ05rQixjQUFjO0FBQ2hCO0FBQ0EsU0FBU0EsYUFBYXNCLE1BQU07SUFDMUIsSUFBSSxLQUFzQyxFQUFJLEVBRTdDO0lBQ0QsSUFBSUEsUUFBUTtRQUNWVixVQUFVbFMsU0FBUyxDQUFDLEdBQUc0UyxRQUFRO1lBQzdCeEMsTUFBTTtZQUNOa0IsY0FBYztRQUNoQjtJQUNGLE9BQU87UUFDTFksVUFBVTJMO0lBQ1o7QUFDRjtBQUNBLFNBQVNDLElBQUlqYixRQUFRO0lBQ25CLElBQUksS0FBc0MsRUFBSSxFQUc3QyxNQUFNO1FBQ0w5SCxZQUFZb2UsWUFBWSxDQUFDZ0IsSUFBSSxDQUFDdFg7UUFDOUIsT0FBTzFILEtBQUs7WUFDVkosWUFBWW9lLFlBQVksR0FBR3BlLFlBQVlvZSxZQUFZLENBQUN2YixNQUFNLENBQUMsU0FBVXNaLENBQUM7Z0JBQ3BFLE9BQU9BLE1BQU1yVTtZQUNmO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSXdOLFNBQVM7QUFDYixJQUFJME4sZUFBZTtBQUNuQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLG1CQUFtQjtBQUN2QixJQUFJQyxzQkFBc0I7QUFDMUIsSUFBSWpTLG1CQUFtQixXQUFXLEdBQUV0Rix1QkFBdUIwSjtBQUMzRCxJQUFJOE4sd0JBQXdCLFdBQVcsR0FBRXhYLHVCQUF1Qm9YLGNBQWM7SUFDNUU1VyxPQUFPO0FBQ1Q7QUFDQSxJQUFJaVgsdUJBQXVCLFdBQVcsR0FBRXpYLHVCQUF1QnFYLFlBQVk7SUFDekUzWSxZQUFZO0FBQ2Q7QUFDQSxJQUFJZ1osNEJBQTRCLFdBQVcsR0FBRTFYLHVCQUF1QnNYLGtCQUFrQjtJQUNwRjVZLFlBQVk7SUFDWjhCLE9BQU87QUFDVDtBQUNBLFNBQVNtWCxvQkFBb0JqWixVQUFVO0lBQ3JDLElBQUk3RyxNQUFNLFNBQVNvYSxPQUFPaEssSUFBSSxFQUFFckIsSUFBSTtRQUNsQyxrQkFBa0I7UUFDbEIsSUFBSWhTLFdBQVdxVCxPQUFPO1lBQ3BCLE9BQU8zRyxhQUFhMkcsS0FBS3hXLElBQUksSUFBSThsQixxQkFBcUJ0UCxNQUFNdko7UUFDOUQ7UUFDQSwwQkFBMEI7UUFDMUIsSUFBSTlKLFdBQVdnUyxPQUFPO1lBQ3BCLE9BQU90RixhQUFhMkcsTUFBTXJCLE1BQU1sSTtRQUNsQztRQUNBLDhCQUE4QjtRQUM5QixJQUFJckUsaUJBQWlCdU0sT0FBTztZQUMxQixPQUFPLENBQUNsSSxhQUFhK1ksdUJBQXVCblMsZ0JBQWUsRUFBR2hMLGVBQWUsQ0FBQzJOLE1BQU1yQjtRQUN0RjtRQUNBLFVBQVU7UUFDVixJQUFJOVIsWUFBWThSLE9BQU87WUFDckIsT0FBT3JNLGdCQUFnQjBOLE1BQU1yQixNQUFNbEksYUFBYStZLHVCQUF1Qm5TO1FBQ3pFO1FBQ0EsbUNBQW1DO1FBQ25DLElBQUl4USxZQUFZbVQsT0FBTztZQUNyQixPQUFPL04sMEJBQTBCOEYsdUJBQXVCdEIsYUFBYTJZLGFBQWEzTixRQUFRO2dCQUN4RmpZLE1BQU13VztnQkFDTnZKLFlBQVlBO1lBQ2Q7UUFDRjtRQUNBLElBQUkxTSxJQUFxQyxFQUFFO1lBQ3pDQyxJQUFJO1FBQ047SUFDRjtJQUNBLE9BQU80RjtBQUNUO0FBQ0EsSUFBSW9hLFNBQVMsV0FBVyxHQUFFMEYsb0JBQW9CO0FBQzlDdGtCLE9BQU9ELE1BQU0sQ0FBQzZlLFFBQVEzTTtBQUN0QixJQUFJNUcsYUFBYSxXQUFXLEdBQUVpWixvQkFBb0I7QUFDbER0a0IsT0FBT0QsTUFBTSxDQUFDc0wsWUFBWStZO0FBQzFCeEYsT0FBT3pSLEtBQUssR0FBRyxXQUFXLEdBQUV0RywwQkFBMEJzZDtBQUN0RDlZLFdBQVc4QixLQUFLLEdBQUcsV0FBVyxHQUFFdEcsMEJBQTBCd2Q7QUFDMUQsU0FBU0UsWUFBWS9pQixFQUFFO0lBQ3JCLE9BQU82VCxjQUFjN1QsR0FBR3BELElBQUksSUFBSThsQixxQkFBcUIsT0FBTzFpQixJQUFJLElBQUksRUFBRXlKO0FBQ3hFO0FBQ0EsU0FBU0MsU0FBUzVNLEtBQUs7SUFDckIsT0FBT2lELFdBQVdqRCxVQUFVQSxNQUFNOFAsWUFBWSxLQUFLO0FBQ3JEO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTbU8sUUFBUWlJLElBQUksRUFBRTNQLElBQUk7SUFDekIsSUFBSTRQLFlBQVlDLE9BQU9DLFFBQVFDO0lBQy9CLElBQUkvUCxTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBT3JVO0lBQ1Q7SUFDQSxJQUFJN0IsSUFBcUMsRUFBRTtRQUN6QyxJQUFJLENBQUM0QyxXQUFXaWpCLE9BQU87WUFDckI1bEIsSUFBSTtRQUNOO1FBQ0EsSUFBSXNNLFNBQVNzWixPQUFPO1lBQ2xCNWxCLElBQUk7UUFDTjtJQUNGO0lBQ0EsSUFBSVIsT0FBTyxDQUFDcW1CLGFBQWEsQ0FBQ0MsUUFBUTdQLElBQUcsS0FBTSxPQUFPLEtBQUssSUFBSTZQLE1BQU10bUIsSUFBSSxLQUFLLE9BQU9xbUIsYUFBYTlsQixLQUFxQyxHQUFHNmxCLEtBQUtwbUIsSUFBSSxJQUFJLGFBQWE2QyxjQUFjLENBQVM7SUFDdkwsSUFBSTRqQixVQUFVLENBQUNoUSxLQUFLaVEsU0FBUyxJQUFJLENBQUNqUSxLQUFLa1EsS0FBSztJQUM1QyxJQUFJQztJQUNKLElBQUlILFNBQVM7UUFDWCxpQkFBaUI7UUFDakJHLFdBQVcsSUFBSTVELFNBQVNoakIsTUFBTTtZQUM1QixJQUFJLENBQUMyZCxLQUFLLENBQUNrSjtRQUNiLEdBQUdwUSxLQUFLcVEsT0FBTyxFQUFFclEsS0FBS3NRLGtCQUFrQjtJQUMxQyxPQUFPO1FBQ0wsSUFBSUwsWUFBWU0sMkJBQTJCdlE7UUFDM0Msb0JBQW9CO1FBQ3BCLElBQUkyTSxjQUFjO1FBQ2xCd0QsV0FBVyxJQUFJNUQsU0FBU2hqQixNQUFNO1lBQzVCLElBQUksQ0FBQ29qQixhQUFhO2dCQUNoQkEsY0FBYztnQkFDZHNELFVBQVU7b0JBQ1J0RCxjQUFjO29CQUNkLElBQUksQ0FBQ3dELFNBQVN0RCxVQUFVLEVBQUU7d0JBQ3hCc0QsU0FBU2pKLEtBQUssQ0FBQ2tKO29CQUNqQjtnQkFDRjtZQUNGO1FBQ0YsR0FBR3BRLEtBQUtxUSxPQUFPLEVBQUVyUSxLQUFLc1Esa0JBQWtCO0lBQzFDO0lBQ0EsU0FBU0Y7UUFDUFQsS0FBS1E7SUFDUDtJQUNBLElBQUksQ0FBRSxFQUFDTCxTQUFTOVAsSUFBRyxLQUFNLFFBQVEsQ0FBQzhQLFNBQVNBLE9BQU9VLE1BQU0sS0FBSyxRQUFRVixPQUFPVyxPQUFPLEdBQUc7UUFDcEZOLFNBQVN6RCxTQUFTO0lBQ3BCO0lBQ0EsT0FBT3lELFNBQVM3QyxZQUFZLENBQUMsQ0FBQ3lDLFNBQVMvUCxJQUFHLEtBQU0sT0FBTyxLQUFLLElBQUkrUCxPQUFPUyxNQUFNO0FBQy9FO0FBQ0EsSUFBSUUsTUFBTSxTQUFTQSxJQUFJN0gsQ0FBQztJQUN0QixPQUFPQTtBQUNUO0FBQ0EsU0FBUzBILDJCQUEyQnZRLElBQUk7SUFDdEMsT0FBT0EsS0FBS2lRLFNBQVMsR0FBR2pRLEtBQUtpUSxTQUFTLEdBQUdqUSxLQUFLa1EsS0FBSyxHQUFHLFNBQVVySCxDQUFDO1FBQy9ELE9BQU8rQixXQUFXL0IsR0FBRzdJLEtBQUtrUSxLQUFLO0lBQ2pDLElBQUlRO0FBQ047QUFDQSxTQUFTUCxTQUFTUSxVQUFVLEVBQUVDLE1BQU0sRUFBRTVRLElBQUk7SUFDeEMsSUFBSTZRLGFBQWFDLFFBQVFDO0lBQ3pCLElBQUkvUSxTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBT3JVO0lBQ1Q7SUFDQSxJQUFJN0IsSUFBcUMsRUFBRTtRQUN6QyxJQUFJLENBQUM0QyxXQUFXaWtCLGVBQWUsQ0FBQ2prQixXQUFXa2tCLFNBQVM7WUFDbEQ3bUIsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDaUQsY0FBY2dULE9BQU87WUFDeEJqVyxJQUFJO1FBQ047SUFDRjtJQUNBLElBQUlSLE9BQU8sQ0FBQ3NuQixjQUFjN1EsS0FBS3pXLElBQUksS0FBSyxPQUFPc25CLGNBQWMvbUIsS0FBcUMsR0FBRyxjQUFjc0MsY0FBYyxDQUFVO0lBQzNJLElBQUk0a0IsZUFBZWpILE9BQU94Z0IsTUFBTXlXLEtBQUtxUSxPQUFPLEdBQUdZLGlCQUFpQmpSLEtBQUtxUSxPQUFPLEVBQUVPLFVBQVVBO0lBQ3hGLElBQUlaLFVBQVUsQ0FBQ2hRLEtBQUtpUSxTQUFTLElBQUksQ0FBQ2pRLEtBQUtrUSxLQUFLO0lBQzVDLElBQUlELFlBQVlNLDJCQUEyQnZRO0lBQzNDLElBQUl3SCxZQUFZO0lBQ2hCLElBQUltRixjQUFjO0lBQ2xCLElBQUk5ZjtJQUNKLElBQUlpUyxTQUFTa0IsS0FBSzZGLGlCQUFpQixHQUFHbFEsU0FBU0UsVUFBVSxHQUFHbUssS0FBS2xCLE1BQU0sSUFBSW5KLFFBQVEsQ0FBQyxVQUFVO0lBQzlGLElBQUl4RixJQUFJLElBQUlvYyxTQUFTaGpCLE1BQU07UUFDekIsSUFBSWllLGFBQWF3SSxTQUFTO1lBQ3hCSTtRQUNGLE9BQU8sSUFBSSxDQUFDekQsYUFBYTtZQUN2QkEsY0FBYztZQUNkc0QsVUFBVUc7UUFDWjtJQUNGLEdBQUdwUSxLQUFLcVEsT0FBTyxFQUFFclEsS0FBS3NRLGtCQUFrQjtJQUN4QyxTQUFTRjtRQUNQekQsY0FBYztRQUNkLElBQUl4YyxFQUFFMGMsVUFBVSxFQUFFO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJNUYsVUFBVTtRQUNkLElBQUloUSxXQUFXcEs7UUFDZnNELEVBQUUrVyxLQUFLLENBQUM7WUFDTixJQUFJZ0ssWUFBWXJQLGtCQUFrQixPQUFPO2dCQUN2QyxPQUFPOE8sV0FBV3hnQjtZQUNwQjtZQUNBOFcsVUFBVU8sYUFBYSxDQUFDMUksT0FBT2pTLE9BQU9xa0I7WUFDdENya0IsUUFBUXFrQjtRQUNWO1FBQ0EsSUFBSTFKLGFBQWF4SCxLQUFLdUUsZUFBZSxFQUFFO1lBQ3JDeU0sYUFBYW5rQixPQUFPb0ssVUFBVTlHO1FBQ2hDLE9BQU8sSUFBSSxDQUFDcVgsYUFBYVAsU0FBUztZQUNoQytKLGFBQWFua0IsT0FBT29LLFVBQVU5RztRQUNoQztRQUNBcVgsWUFBWTtJQUNkO0lBQ0EsSUFBSSxDQUFFLEVBQUNzSixTQUFTOVEsSUFBRyxLQUFNLFFBQVEsQ0FBQzhRLFNBQVNBLE9BQU9OLE1BQU0sS0FBSyxRQUFRTSxPQUFPTCxPQUFPLEdBQUc7UUFDcEZ0Z0IsRUFBRXVjLFNBQVM7SUFDYjtJQUNBLE9BQU92YyxFQUFFbWQsWUFBWSxDQUFDLENBQUN5RCxTQUFTL1EsSUFBRyxLQUFNLE9BQU8sS0FBSyxJQUFJK1EsT0FBT1AsTUFBTTtBQUN4RTtBQUNBLFNBQVNTLGlCQUFpQkUsWUFBWSxFQUFFQyxNQUFNO0lBQzVDLE9BQU87UUFDTCxJQUFJO1lBQ0YsT0FBT0EsT0FBTzdtQixLQUFLLENBQUMsSUFBSSxFQUFFTDtRQUM1QixFQUFFLE9BQU9JLEdBQUc7WUFDVjZtQixhQUFhOWpCLElBQUksQ0FBQyxJQUFJLEVBQUUvQztRQUMxQjtJQUNGO0FBQ0Y7QUFFQSxJQUFJK21CLHFCQUFxQjtBQUN6QixJQUFJQyx1QkFBdUI7QUFDM0IsU0FBU3BjLGlCQUFpQnpMLEtBQUssRUFBRWlWLElBQUksRUFBRUMsSUFBSTtJQUN6QyxPQUFPNFMsY0FBY0Ysb0JBQW9CNW5CLE9BQU9pVixNQUFNQztBQUN4RDtBQUNBLFNBQVN4SixtQkFBbUIxTCxLQUFLLEVBQUVpVixJQUFJLEVBQUVDLElBQUk7SUFDM0MsT0FBTzRTLGNBQWNELHNCQUFzQjduQixPQUFPaVYsTUFBTUM7QUFDMUQ7QUFDQSxTQUFTNFMsY0FBY0MsSUFBSSxFQUFFL25CLEtBQUssRUFBRWlWLElBQUksRUFBRUMsSUFBSTtJQUM1QyxJQUFJMUosT0FBTyxPQUFPMEosU0FBUyxhQUFhOFMsUUFBUWhvQixPQUFPaVYsUUFBUStTLFFBQVFob0I7SUFDdkUsSUFBSWlvQixLQUFLaGxCLFdBQVdpUyxRQUFRQSxPQUFPRDtJQUNuQyxJQUFJaVQsZUFBZUgsT0FBTztJQUMxQixJQUFJdmMsSUFBSSxDQUFDMGMsYUFBYSxFQUFFO1FBQ3RCMWMsSUFBSSxDQUFDMGMsYUFBYSxDQUFDclYsR0FBRyxDQUFDb1Y7SUFDekIsT0FBTztRQUNMemMsSUFBSSxDQUFDMGMsYUFBYSxHQUFHLElBQUlwZSxJQUFJO1lBQUNtZTtTQUFHO0lBQ25DO0lBQ0EsT0FBTztRQUNMLElBQUlFLGdCQUFnQjNjLElBQUksQ0FBQzBjLGFBQWE7UUFDdEMsSUFBSUMsZUFBZTtZQUNqQkEsYUFBYSxDQUFDLFNBQVMsQ0FBQ0Y7WUFDeEIsSUFBSUUsY0FBY3hMLElBQUksS0FBSyxHQUFHO2dCQUM1QixPQUFPblIsSUFBSSxDQUFDMGMsYUFBYTtZQUMzQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLFFBQVE7QUFDWixJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsV0FBVztBQUNmLHFDQUFxQztBQUNyQyxTQUFTQyxVQUFVamEsT0FBTztJQUN4QixJQUFJQSxRQUFROFMsa0JBQWtCLEtBQUssTUFBTTtRQUN2Q0E7SUFDRjtJQUNBLElBQUk3TCxhQUFhakgsUUFBUWlILFVBQVUsRUFDakN5SixpQkFBaUIxUSxRQUFRMFEsY0FBYztJQUN6QyxJQUFJekosZUFBZTVJLFdBQVc7UUFDNUJsSyxZQUFZOFMsVUFBVSxHQUFHQSxlQUFlOFMsU0FBUyxPQUFPOVMsZUFBZTZTLFFBQVEsUUFBUSxPQUFPaG1CLFVBQVU7SUFDMUc7SUFDQSxJQUFJbVQsZUFBZSxlQUFlO1FBQ2hDOVMsWUFBWUMsYUFBYSxHQUFHO0lBQzlCO0lBQ0EsSUFBSXNjLG1CQUFtQnJTLFdBQVc7UUFDaEMsSUFBSTZiLEtBQUt4SixtQkFBbUJxSixTQUFTQSxTQUFTckosbUJBQW1Cc0o7UUFDakU3bEIsWUFBWXVjLGNBQWMsR0FBR3dKO1FBQzdCL2xCLFlBQVkyVixpQkFBaUIsR0FBR29RLE9BQU8sUUFBUUEsT0FBT0gsU0FBUyxRQUFRO0lBQ3pFO0lBQ0E7UUFBQztRQUE0QjtRQUE4QjtRQUE4QjtRQUEwQjtLQUFrQixDQUFDbGlCLE9BQU8sQ0FBQyxTQUFVM0csR0FBRztRQUN6SixJQUFJQSxPQUFPOE8sU0FBUztZQUNsQjdMLFdBQVcsQ0FBQ2pELElBQUksR0FBRyxDQUFDLENBQUM4TyxPQUFPLENBQUM5TyxJQUFJO1FBQ25DO0lBQ0Y7SUFDQWlELFlBQVl5YyxlQUFlLEdBQUcsQ0FBQ3pjLFlBQVkwYywwQkFBMEI7SUFDckUsSUFBSTllLEtBQXFDLElBQUlvQyxZQUFZa2Isc0JBQXNCLEtBQUssTUFBTTtRQUN4RnhQLFFBQVFDLElBQUksQ0FBQztJQUNmO0lBQ0EsSUFBSUUsUUFBUXVXLGlCQUFpQixFQUFFO1FBQzdCTSxxQkFBcUI3VyxRQUFRdVcsaUJBQWlCO0lBQ2hEO0FBQ0Y7QUFFQSxTQUFTOU8saUJBQWlCaFEsTUFBTSxFQUFFMGlCLFVBQVUsRUFBRUMsV0FBVyxFQUFFcGEsT0FBTztJQUNoRSxJQUFJak8sSUFBcUMsRUFBRTtRQUN6QyxJQUFJSSxVQUFVZCxNQUFNLEdBQUcsR0FBRztZQUN4QlcsSUFBSTtRQUNOO1FBQ0EsSUFBSSxPQUFPeUYsV0FBVyxVQUFVO1lBQzlCekYsSUFBSTtRQUNOO1FBQ0EsSUFBSTZNLGdCQUFnQnBILFNBQVM7WUFDM0J6RixJQUFJO1FBQ047UUFDQSxJQUFJLENBQUNpRCxjQUFja2xCLGFBQWE7WUFDOUJub0IsSUFBSTtRQUNOO1FBQ0EsSUFBSWtNLGFBQWFpYyxlQUFlamMsYUFBYWtjLGNBQWM7WUFDekRwb0IsSUFBSTtRQUNOO0lBQ0Y7SUFDQSw4RkFBOEY7SUFDOUYsSUFBSXFvQixjQUFjMWlCLDBCQUEwQndpQjtJQUM1QzNTLGVBQWU7UUFDYixJQUFJakksTUFBTStELG1CQUFtQjdMLFFBQVF1SSxRQUFRLENBQUM3RSxNQUFNO1FBQ3BEaEUsUUFBUWtqQixhQUFheGlCLE9BQU8sQ0FBQyxTQUFVM0csR0FBRztZQUN4Q3FPLElBQUlELE9BQU8sQ0FBQ3BPLEtBQUttcEIsV0FBVyxDQUFDbnBCLElBQUksRUFDakMsK0NBQStDO1lBQy9DLENBQUNrcEIsY0FBYyxPQUFPbHBCLE9BQU9rcEIsY0FBY0EsV0FBVyxDQUFDbHBCLElBQUksR0FBRztRQUNoRTtJQUNGO0lBQ0EsT0FBT3VHO0FBQ1Q7QUFFQSxTQUFTdWMsa0JBQWtCdGlCLEtBQUssRUFBRUMsUUFBUTtJQUN4QyxPQUFPMm9CLHFCQUFxQlosUUFBUWhvQixPQUFPQztBQUM3QztBQUNBLFNBQVMyb0IscUJBQXFCbEgsSUFBSTtJQUNoQyxJQUFJdkUsU0FBUztRQUNYcmQsTUFBTTRoQixLQUFLL1gsS0FBSztJQUNsQjtJQUNBLElBQUkrWCxLQUFLckcsVUFBVSxJQUFJcUcsS0FBS3JHLFVBQVUsQ0FBQzFiLE1BQU0sR0FBRyxHQUFHO1FBQ2pEd2QsT0FBT3lGLFlBQVksR0FBR2lHLE9BQU9uSCxLQUFLckcsVUFBVSxFQUFFcmEsR0FBRyxDQUFDNG5CO0lBQ3BEO0lBQ0EsT0FBT3pMO0FBQ1Q7QUFDQSxTQUFTMkwsZ0JBQWdCOW9CLEtBQUssRUFBRUMsUUFBUTtJQUN0QyxPQUFPOG9CLG1CQUFtQmYsUUFBUWhvQixPQUFPQztBQUMzQztBQUNBLFNBQVM4b0IsbUJBQW1CckgsSUFBSTtJQUM5QixJQUFJdkUsU0FBUztRQUNYcmQsTUFBTTRoQixLQUFLL1gsS0FBSztJQUNsQjtJQUNBLElBQUlvVixhQUFhMkMsT0FBTztRQUN0QnZFLE9BQU82TCxTQUFTLEdBQUdyb0IsTUFBTXlILElBQUksQ0FBQ3FaLGFBQWFDLE9BQU8xZ0IsR0FBRyxDQUFDK25CO0lBQ3hEO0lBQ0EsT0FBTzVMO0FBQ1Q7QUFDQSxTQUFTMEwsT0FBTzlHLElBQUk7SUFDbEIsT0FBT3BoQixNQUFNeUgsSUFBSSxDQUFDLElBQUkwQixJQUFJaVk7QUFDNUI7QUFFQSxJQUFJa0gsY0FBYztBQUNsQixTQUFTQztJQUNQLElBQUksQ0FBQ3ZGLE9BQU8sR0FBRztBQUNqQjtBQUNBdUYsc0JBQXNCbm5CLFNBQVMsR0FBRyxXQUFXLEdBQUVMLE9BQU9rRyxNQUFNLENBQUM3RyxNQUFNZ0IsU0FBUztBQUM1RSxTQUFTb25CLHdCQUF3QjVvQixLQUFLO0lBQ3BDLE9BQU9BLGlCQUFpQjJvQjtBQUMxQjtBQUNBLElBQUl6VixpQkFBaUIsV0FBVyxHQUFFNUMscUJBQXFCO0FBQ3ZELElBQUl1WSxzQkFBc0IsV0FBVyxHQUFFdlkscUJBQXFCLGNBQWM7SUFDeEVoQyxPQUFPO0FBQ1Q7QUFDQSxJQUFJL0IsT0FBTyxXQUFXLEdBQUVwTCxPQUFPRCxNQUFNLENBQUMsU0FBU3FMLEtBQUt3SixJQUFJLEVBQUVyQixJQUFJO0lBQzVELDRCQUE0QjtJQUM1QixJQUFJdk0saUJBQWlCdU0sT0FBTztRQUMxQixPQUFPeEIsZUFBZTlLLGVBQWUsQ0FBQzJOLE1BQU1yQjtJQUM5QztJQUNBLFFBQVE7SUFDUixJQUFJOVIsWUFBWThSLE9BQU87UUFDckIsT0FBT3JNLGdCQUFnQjBOLE1BQU1yQixNQUFNeEI7SUFDckM7SUFDQSxXQUFXO0lBQ1gsSUFBSXBULEtBQXFDLElBQUlJLFVBQVVkLE1BQU0sS0FBSyxHQUFHO1FBQ25FVyxJQUFJO0lBQ047SUFDQSxJQUFJK29CLFlBQVkvUztJQUNoQixJQUFJeFcsT0FBT3VwQixVQUFVdnBCLElBQUksSUFBSTtJQUM3Qix3RUFBd0U7SUFDeEUsSUFBSW9HLE1BQU0sU0FBU0E7UUFDakIsSUFBSW9qQixNQUFNLElBQUk7UUFDZCxJQUFJNW9CLE9BQU9EO1FBQ1gsSUFBSTRlLFFBQVEsRUFBRTRKO1FBQ2QsSUFBSU0sTUFBTWpKLE9BQU94Z0IsT0FBTyxlQUFldWYsUUFBUSxXQUFXZ0ssV0FBV3ZvQixLQUFLLENBQUN3b0IsS0FBSzVvQjtRQUNoRixJQUFJOG9CO1FBQ0osSUFBSUMsaUJBQWlCOWM7UUFDckIsSUFBSStjLFVBQVUsSUFBSUMsUUFBUSxTQUFVQyxPQUFPLEVBQUVDLE1BQU07WUFDakQsSUFBSUMsU0FBUztZQUNiTixXQUFXSztZQUNYLFNBQVNFLFlBQVk3akIsR0FBRztnQkFDdEJ1akIsaUJBQWlCOWM7Z0JBQ2pCLElBQUlxZDtnQkFDSixJQUFJO29CQUNGQSxNQUFNMUosT0FBT3hnQixPQUFPLGVBQWV1ZixRQUFRLGNBQWN5SyxVQUFVUCxJQUFJbmlCLElBQUksRUFBRXhELElBQUksQ0FBQzJsQixLQUFLcmpCO2dCQUN6RixFQUFFLE9BQU9yRixHQUFHO29CQUNWLE9BQU9ncEIsT0FBT2hwQjtnQkFDaEI7Z0JBQ0F1RyxLQUFLNGlCO1lBQ1A7WUFDQSxTQUFTQyxXQUFXN1MsR0FBRztnQkFDckJxUyxpQkFBaUI5YztnQkFDakIsSUFBSXFkO2dCQUNKLElBQUk7b0JBQ0ZBLE1BQU0xSixPQUFPeGdCLE9BQU8sZUFBZXVmLFFBQVEsY0FBY3lLLFVBQVVQLEdBQUcsQ0FBQyxRQUFRLEVBQUUzbEIsSUFBSSxDQUFDMmxCLEtBQUtuUztnQkFDN0YsRUFBRSxPQUFPdlcsR0FBRztvQkFDVixPQUFPZ3BCLE9BQU9ocEI7Z0JBQ2hCO2dCQUNBdUcsS0FBSzRpQjtZQUNQO1lBQ0EsU0FBUzVpQixLQUFLNGlCLEdBQUc7Z0JBQ2YsSUFBSS9tQixXQUFXK21CLE9BQU8sT0FBTyxLQUFLLElBQUlBLElBQUlFLElBQUksR0FBRztvQkFDL0Msb0JBQW9CO29CQUNwQkYsSUFBSUUsSUFBSSxDQUFDOWlCLE1BQU15aUI7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0EsSUFBSUcsSUFBSXhpQixJQUFJLEVBQUU7b0JBQ1osT0FBT29pQixRQUFRSSxJQUFJNW1CLEtBQUs7Z0JBQzFCO2dCQUNBcW1CLGlCQUFpQkUsUUFBUUMsT0FBTyxDQUFDSSxJQUFJNW1CLEtBQUs7Z0JBQzFDLE9BQU9xbUIsZUFBZVMsSUFBSSxDQUFDSCxhQUFhRTtZQUMxQztZQUNBRixZQUFZcGQsWUFBWSx1QkFBdUI7UUFDakQ7UUFDQStjLFFBQVFTLE1BQU0sR0FBRzdKLE9BQU94Z0IsT0FBTyxlQUFldWYsUUFBUSxhQUFhO1lBQ2pFLElBQUk7Z0JBQ0YsSUFBSW9LLGdCQUFnQjtvQkFDbEJXLGNBQWNYO2dCQUNoQjtnQkFDQSw4Q0FBOEM7Z0JBQzlDLElBQUlZLE9BQU9kLEdBQUcsQ0FBQyxTQUFTLENBQUM1YztnQkFDekIsc0RBQXNEO2dCQUN0RCxJQUFJMmQsaUJBQWlCWCxRQUFRQyxPQUFPLENBQUNTLEtBQUtqbkIsS0FBSztnQkFDL0NrbkIsZUFBZUosSUFBSSxDQUFDbG5CLE1BQU1BO2dCQUMxQm9uQixjQUFjRSxpQkFBaUIsK0JBQStCO2dCQUM5RCw4QkFBOEI7Z0JBQzlCZCxTQUFTLElBQUlOO1lBQ2YsRUFBRSxPQUFPcm9CLEdBQUc7Z0JBQ1Yyb0IsU0FBUzNvQixJQUFJLDBDQUEwQztZQUN6RDtRQUNGO1FBQ0EsT0FBTzZvQjtJQUNUO0lBQ0F4akIsSUFBSWtMLFVBQVUsR0FBRztJQUNqQixPQUFPbEw7QUFDVCxHQUFHdU47QUFDSDNHLEtBQUsrQixLQUFLLEdBQUcsV0FBVyxHQUFFdEcsMEJBQTBCNmdCO0FBQ3BELFNBQVNnQixjQUFjVixPQUFPO0lBQzVCLElBQUl6bUIsV0FBV3ltQixRQUFRUyxNQUFNLEdBQUc7UUFDOUJULFFBQVFTLE1BQU07SUFDaEI7QUFDRjtBQUNBLFNBQVNJLFdBQVdwTixNQUFNO0lBQ3hCLE9BQU9BLFFBQVEsOEJBQThCO0FBQy9DO0FBQ0EsU0FBU3RRLE9BQU8zSixFQUFFO0lBQ2hCLE9BQU8sQ0FBQ0EsTUFBTSxPQUFPLEtBQUssSUFBSUEsR0FBR2tPLFVBQVUsTUFBTTtBQUNuRDtBQUVBLFNBQVNvWixlQUFleHFCLEtBQUssRUFBRXlxQixhQUFhLEVBQUU5UCxPQUFPO0lBQ25ELElBQUk1VTtJQUNKLElBQUlvSCxnQkFBZ0JuTixVQUFVa04sa0JBQWtCbE4sVUFBVW1iLGtCQUFrQm5iLFFBQVE7UUFDbEYrRixTQUFTMmtCLGtCQUFrQjFxQjtJQUM3QixPQUFPLElBQUlpTixtQkFBbUJqTixRQUFRO1FBQ3BDLElBQUlLLEtBQXFDLElBQUksQ0FBQzhDLFlBQVlzbkIsZ0JBQWdCO1lBQ3hFLE9BQU9ucUIsSUFBSTtRQUNiO1FBQ0F5RixTQUFTMmtCLGtCQUFrQjFxQixPQUFPeXFCO0lBQ3BDLE9BQU8sSUFBSXBxQixJQUFxQyxFQUFFO1FBQ2hELE9BQU9DLElBQUk7SUFDYjtJQUNBLElBQUlELEtBQXFDLElBQUkwRixPQUFPNFQsUUFBUSxLQUFLaE4sV0FBVztRQUMxRSxPQUFPck0sSUFBSTtJQUNiO0lBQ0F5RixPQUFPNFQsUUFBUSxHQUFHLE9BQU84USxrQkFBa0IsYUFBYUEsZ0JBQWdCOVA7SUFDeEUsT0FBTztRQUNMNVUsT0FBTzRULFFBQVEsR0FBR2hOO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTZ2UsVUFBVTNxQixLQUFLLEVBQUV5cUIsYUFBYSxFQUFFOVAsT0FBTztJQUM5QyxJQUFJMVgsV0FBVzBYLFVBQVU7UUFDdkIsT0FBT2lRLGtCQUFrQjVxQixPQUFPeXFCLGVBQWU5UDtJQUNqRCxPQUFPO1FBQ0wsT0FBT2tRLHVCQUF1QjdxQixPQUFPeXFCO0lBQ3ZDO0FBQ0Y7QUFDQSxTQUFTSSx1QkFBdUI3cUIsS0FBSyxFQUFFMmEsT0FBTztJQUM1QyxPQUFPK1Asa0JBQWtCMXFCLE9BQU8wYSxVQUFVLENBQUNDO0FBQzdDO0FBQ0EsU0FBU2lRLGtCQUFrQjVxQixLQUFLLEVBQUVDLFFBQVEsRUFBRTBhLE9BQU87SUFDakQsT0FBTytQLGtCQUFrQjFxQixPQUFPQyxVQUFVeWEsVUFBVSxDQUFDQztBQUN2RDtBQUVBLFNBQVNtUSxZQUFZMW5CLEtBQUssRUFBRW5ELFFBQVE7SUFDbEMsSUFBSUEsYUFBYTBNLFdBQVc7UUFDMUIsT0FBTzJSLGdCQUFnQmxiO0lBQ3pCO0lBQ0EsSUFBSTZKLG1CQUFtQjdKLFdBQVcsT0FBTztRQUN2QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNBLEtBQUssQ0FBQ3FHLE1BQU0sQ0FBQ29JLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBQzdTLFdBQVc7UUFDdkMsT0FBTztJQUNUO0lBQ0EsSUFBSXVMLE9BQU93YyxRQUFRNWtCLE9BQU9uRDtJQUMxQixPQUFPcWUsZ0JBQWdCOVM7QUFDekI7QUFDQSxTQUFTdWYsV0FBVzNuQixLQUFLO0lBQ3ZCLElBQUkvQyxLQUFxQyxJQUFJSSxVQUFVZCxNQUFNLEdBQUcsR0FBRztRQUNqRSxPQUFPVyxJQUFJO0lBQ2I7SUFDQSxPQUFPd3FCLFlBQVkxbkI7QUFDckI7QUFDQSxTQUFTNG5CLGVBQWU1bkIsS0FBSyxFQUFFYyxRQUFRO0lBQ3JDLElBQUk3RCxLQUFxQyxJQUFJLENBQUM4QyxZQUFZZSxXQUFXO1FBQ25FLE9BQU81RCxJQUFJO0lBQ2I7SUFDQSxPQUFPd3FCLFlBQVkxbkIsT0FBT2M7QUFDNUI7QUFFQSxTQUFTK21CLGNBQWM3bkIsS0FBSyxFQUFFbkQsUUFBUTtJQUNwQyxJQUFJLENBQUNtRCxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsSUFBSW5ELGFBQWEwTSxXQUFXO1FBQzFCLElBQUl0TSxLQUFxQyxJQUFLOE0sQ0FBQUEsZ0JBQWdCL0osVUFBVThKLGtCQUFrQjlKLE1BQUssR0FBSTtZQUNqRyxPQUFPOUMsSUFBSTtRQUNiO1FBQ0EsSUFBSTJNLG1CQUFtQjdKLFFBQVE7WUFDN0IsT0FBT0EsS0FBSyxDQUFDcUcsTUFBTSxDQUFDb0ksT0FBTyxDQUFDaUIsR0FBRyxDQUFDN1M7UUFDbEM7UUFDQSxPQUFPO0lBQ1Q7SUFDQSw0QkFBNEI7SUFDNUIsT0FBT2dOLG1CQUFtQjdKLFVBQVUsQ0FBQyxDQUFDQSxLQUFLLENBQUNxRyxNQUFNLElBQUkyQixPQUFPaEksVUFBVThoQixXQUFXOWhCLFVBQVVrYixnQkFBZ0JsYjtBQUM5RztBQUNBLFNBQVNvSixhQUFhcEosS0FBSztJQUN6QixJQUFJL0MsS0FBcUMsSUFBSUksVUFBVWQsTUFBTSxLQUFLLEdBQUc7UUFDbkVXLElBQUk7SUFDTjtJQUNBLE9BQU8ycUIsY0FBYzduQjtBQUN2QjtBQUNBLFNBQVM4bkIsaUJBQWlCOW5CLEtBQUssRUFBRWMsUUFBUTtJQUN2QyxJQUFJN0QsS0FBcUMsSUFBSSxDQUFDOEMsWUFBWWUsV0FBVztRQUNuRSxPQUFPNUQsSUFBSTtJQUNiO0lBQ0EsT0FBTzJxQixjQUFjN25CLE9BQU9jO0FBQzlCO0FBRUEsU0FBU2lCLEtBQUtyQixHQUFHO0lBQ2YsSUFBSW1KLG1CQUFtQm5KLE1BQU07UUFDM0IsT0FBT0EsR0FBRyxDQUFDMkYsTUFBTSxDQUFDMGhCLEtBQUs7SUFDekI7SUFDQSxJQUFJaGUsZ0JBQWdCckosUUFBUXNKLGdCQUFnQnRKLE1BQU07UUFDaEQsT0FBT25ELE1BQU15SCxJQUFJLENBQUN0RSxJQUFJcUIsSUFBSTtJQUM1QjtJQUNBLElBQUkrSCxrQkFBa0JwSixNQUFNO1FBQzFCLE9BQU9BLElBQUk5QyxHQUFHLENBQUMsU0FBVTFCLENBQUMsRUFBRUksS0FBSztZQUMvQixPQUFPQTtRQUNUO0lBQ0Y7SUFDQVksSUFBSTtBQUNOO0FBQ0EsU0FBUzhxQixPQUFPdG5CLEdBQUc7SUFDakIsSUFBSW1KLG1CQUFtQm5KLE1BQU07UUFDM0IsT0FBT3FCLEtBQUtyQixLQUFLOUMsR0FBRyxDQUFDLFNBQVV4QixHQUFHO1lBQ2hDLE9BQU9zRSxHQUFHLENBQUN0RSxJQUFJO1FBQ2pCO0lBQ0Y7SUFDQSxJQUFJMk4sZ0JBQWdCckosTUFBTTtRQUN4QixPQUFPcUIsS0FBS3JCLEtBQUs5QyxHQUFHLENBQUMsU0FBVXhCLEdBQUc7WUFDaEMsT0FBT3NFLElBQUlpSCxHQUFHLENBQUN2TDtRQUNqQjtJQUNGO0lBQ0EsSUFBSTROLGdCQUFnQnRKLE1BQU07UUFDeEIsT0FBT25ELE1BQU15SCxJQUFJLENBQUN0RSxJQUFJc25CLE1BQU07SUFDOUI7SUFDQSxJQUFJbGUsa0JBQWtCcEosTUFBTTtRQUMxQixPQUFPQSxJQUFJcUUsS0FBSztJQUNsQjtJQUNBN0gsSUFBSTtBQUNOO0FBQ0EsU0FBUytxQixRQUFRdm5CLEdBQUc7SUFDbEIsSUFBSW1KLG1CQUFtQm5KLE1BQU07UUFDM0IsT0FBT3FCLEtBQUtyQixLQUFLOUMsR0FBRyxDQUFDLFNBQVV4QixHQUFHO1lBQ2hDLE9BQU87Z0JBQUNBO2dCQUFLc0UsR0FBRyxDQUFDdEUsSUFBSTthQUFDO1FBQ3hCO0lBQ0Y7SUFDQSxJQUFJMk4sZ0JBQWdCckosTUFBTTtRQUN4QixPQUFPcUIsS0FBS3JCLEtBQUs5QyxHQUFHLENBQUMsU0FBVXhCLEdBQUc7WUFDaEMsT0FBTztnQkFBQ0E7Z0JBQUtzRSxJQUFJaUgsR0FBRyxDQUFDdkw7YUFBSztRQUM1QjtJQUNGO0lBQ0EsSUFBSTROLGdCQUFnQnRKLE1BQU07UUFDeEIsT0FBT25ELE1BQU15SCxJQUFJLENBQUN0RSxJQUFJdW5CLE9BQU87SUFDL0I7SUFDQSxJQUFJbmUsa0JBQWtCcEosTUFBTTtRQUMxQixPQUFPQSxJQUFJOUMsR0FBRyxDQUFDLFNBQVV4QixHQUFHLEVBQUVFLEtBQUs7WUFDakMsT0FBTztnQkFBQ0E7Z0JBQU9GO2FBQUk7UUFDckI7SUFDRjtJQUNBYyxJQUFJO0FBQ047QUFDQSxTQUFTMkssSUFBSW5ILEdBQUcsRUFBRXRFLEdBQUcsRUFBRTRELEtBQUs7SUFDMUIsSUFBSTNDLFVBQVVkLE1BQU0sS0FBSyxLQUFLLENBQUN5TixnQkFBZ0J0SixNQUFNO1FBQ25EOEc7UUFDQSxJQUFJMGdCLFVBQVU5ckI7UUFDZCxJQUFJO1lBQ0YsSUFBSyxJQUFJb0IsUUFBUTBxQixRQUFTO2dCQUN4QnJnQixJQUFJbkgsS0FBS2xELE1BQU0wcUIsT0FBTyxDQUFDMXFCLEtBQUs7WUFDOUI7UUFDRixTQUFVO1lBQ1JrSztRQUNGO1FBQ0E7SUFDRjtJQUNBLElBQUltQyxtQkFBbUJuSixNQUFNO1FBQzNCQSxHQUFHLENBQUMyRixNQUFNLENBQUM4aEIsSUFBSSxDQUFDL3JCLEtBQUs0RDtJQUN2QixPQUFPLElBQUkrSixnQkFBZ0JySixNQUFNO1FBQy9CQSxJQUFJbUgsR0FBRyxDQUFDekwsS0FBSzREO0lBQ2YsT0FBTyxJQUFJZ0ssZ0JBQWdCdEosTUFBTTtRQUMvQkEsSUFBSStPLEdBQUcsQ0FBQ3JUO0lBQ1YsT0FBTyxJQUFJME4sa0JBQWtCcEosTUFBTTtRQUNqQyxJQUFJLE9BQU90RSxRQUFRLFVBQVU7WUFDM0JBLE1BQU1nc0IsU0FBU2hzQixLQUFLO1FBQ3RCO1FBQ0EsSUFBSUEsTUFBTSxHQUFHO1lBQ1hjLElBQUkscUJBQXFCZCxNQUFNO1FBQ2pDO1FBQ0FvTDtRQUNBLElBQUlwTCxPQUFPc0UsSUFBSW5FLE1BQU0sRUFBRTtZQUNyQm1FLElBQUluRSxNQUFNLEdBQUdILE1BQU07UUFDckI7UUFDQXNFLEdBQUcsQ0FBQ3RFLElBQUksR0FBRzREO1FBQ1gwSDtJQUNGLE9BQU87UUFDTHhLLElBQUk7SUFDTjtBQUNGO0FBQ0EsU0FBU21yQixPQUFPM25CLEdBQUcsRUFBRXRFLEdBQUc7SUFDdEIsSUFBSXlOLG1CQUFtQm5KLE1BQU07UUFDM0JBLEdBQUcsQ0FBQzJGLE1BQU0sQ0FBQ2lpQixPQUFPLENBQUNsc0I7SUFDckIsT0FBTyxJQUFJMk4sZ0JBQWdCckosTUFBTTtRQUMvQkEsR0FBRyxDQUFDLFNBQVMsQ0FBQ3RFO0lBQ2hCLE9BQU8sSUFBSTROLGdCQUFnQnRKLE1BQU07UUFDL0JBLEdBQUcsQ0FBQyxTQUFTLENBQUN0RTtJQUNoQixPQUFPLElBQUkwTixrQkFBa0JwSixNQUFNO1FBQ2pDLElBQUksT0FBT3RFLFFBQVEsVUFBVTtZQUMzQkEsTUFBTWdzQixTQUFTaHNCLEtBQUs7UUFDdEI7UUFDQXNFLElBQUk2Z0IsTUFBTSxDQUFDbmxCLEtBQUs7SUFDbEIsT0FBTztRQUNMYyxJQUFJO0lBQ047QUFDRjtBQUNBLFNBQVN3UyxJQUFJaFAsR0FBRyxFQUFFdEUsR0FBRztJQUNuQixJQUFJeU4sbUJBQW1CbkosTUFBTTtRQUMzQixPQUFPQSxHQUFHLENBQUMyRixNQUFNLENBQUNraUIsSUFBSSxDQUFDbnNCO0lBQ3pCLE9BQU8sSUFBSTJOLGdCQUFnQnJKLE1BQU07UUFDL0IsT0FBT0EsSUFBSWdQLEdBQUcsQ0FBQ3RUO0lBQ2pCLE9BQU8sSUFBSTROLGdCQUFnQnRKLE1BQU07UUFDL0IsT0FBT0EsSUFBSWdQLEdBQUcsQ0FBQ3RUO0lBQ2pCLE9BQU8sSUFBSTBOLGtCQUFrQnBKLE1BQU07UUFDakMsT0FBT3RFLE9BQU8sS0FBS0EsTUFBTXNFLElBQUluRSxNQUFNO0lBQ3JDO0lBQ0FXLElBQUk7QUFDTjtBQUNBLFNBQVN5SyxJQUFJakgsR0FBRyxFQUFFdEUsR0FBRztJQUNuQixJQUFJLENBQUNzVCxJQUFJaFAsS0FBS3RFLE1BQU07UUFDbEIsT0FBT21OO0lBQ1Q7SUFDQSxJQUFJTSxtQkFBbUJuSixNQUFNO1FBQzNCLE9BQU9BLEdBQUcsQ0FBQzJGLE1BQU0sQ0FBQ21pQixJQUFJLENBQUNwc0I7SUFDekIsT0FBTyxJQUFJMk4sZ0JBQWdCckosTUFBTTtRQUMvQixPQUFPQSxJQUFJaUgsR0FBRyxDQUFDdkw7SUFDakIsT0FBTyxJQUFJME4sa0JBQWtCcEosTUFBTTtRQUNqQyxPQUFPQSxHQUFHLENBQUN0RSxJQUFJO0lBQ2pCO0lBQ0FjLElBQUk7QUFDTjtBQUNBLFNBQVN1ckIsa0JBQWtCL25CLEdBQUcsRUFBRXRFLEdBQUcsRUFBRXdPLFVBQVU7SUFDN0MsSUFBSWYsbUJBQW1CbkosTUFBTTtRQUMzQixPQUFPQSxHQUFHLENBQUMyRixNQUFNLENBQUN3RixlQUFlLENBQUN6UCxLQUFLd087SUFDekM7SUFDQTFOLElBQUk7QUFDTjtBQUNBLFNBQVN3ckIsV0FBV2hvQixHQUFHO0lBQ3JCLElBQUltSixtQkFBbUJuSixNQUFNO1FBQzNCLE9BQU9BLEdBQUcsQ0FBQzJGLE1BQU0sQ0FBQ3NpQixRQUFRO0lBQzVCO0lBQ0F6ckIsSUFBSTtBQUNOO0FBRUEsU0FBUzByQixRQUFRaHNCLEtBQUssRUFBRWlzQixRQUFRLEVBQUVDLFFBQVEsRUFBRXBSLGVBQWU7SUFDekQsSUFBSTdYLFdBQVdpcEIsV0FBVztRQUN4QixPQUFPQywwQkFBMEJuc0IsT0FBT2lzQixVQUFVQyxVQUFVcFI7SUFDOUQsT0FBTztRQUNMLE9BQU9zUixrQkFBa0Jwc0IsT0FBT2lzQixVQUFVQztJQUM1QztBQUNGO0FBQ0EsU0FBU0Usa0JBQWtCcHNCLEtBQUssRUFBRXVLLFFBQVEsRUFBRXVRLGVBQWU7SUFDekQsT0FBTzRQLGtCQUFrQjFxQixPQUFPNmEsUUFBUSxDQUFDdFEsVUFBVXVRO0FBQ3JEO0FBQ0EsU0FBU3FSLDBCQUEwQm5zQixLQUFLLEVBQUVDLFFBQVEsRUFBRXNLLFFBQVEsRUFBRXVRLGVBQWU7SUFDM0UsT0FBTzRQLGtCQUFrQjFxQixPQUFPQyxVQUFVNGEsUUFBUSxDQUFDdFEsVUFBVXVRO0FBQy9EO0FBRUEsU0FBU3VSLE1BQU1yckIsR0FBRyxFQUFFeEIsR0FBRyxFQUFFNEQsS0FBSztJQUM1QnBDLElBQUlpSyxHQUFHLENBQUN6TCxLQUFLNEQ7SUFDYixPQUFPQTtBQUNUO0FBQ0EsU0FBU2twQixXQUFXM2QsTUFBTSxFQUFFNGQsYUFBYTtJQUN2QyxJQUFJNWQsVUFBVSxRQUFRLE9BQU9BLFdBQVcsWUFBWUEsa0JBQWtCK0ksUUFBUSxDQUFDbEwsYUFBYW1DLFNBQVM7UUFDbkcsT0FBT0E7SUFDVDtJQUNBLElBQUl3TSxrQkFBa0J4TSxXQUFXMlAsZ0JBQWdCM1AsU0FBUztRQUN4RCxPQUFPMmQsV0FBVzNkLE9BQU81RCxHQUFHLElBQUl3aEI7SUFDbEM7SUFDQSxJQUFJQSxjQUFjelosR0FBRyxDQUFDbkUsU0FBUztRQUM3QixPQUFPNGQsY0FBY3hoQixHQUFHLENBQUM0RDtJQUMzQjtJQUNBLElBQUl6QixrQkFBa0J5QixTQUFTO1FBQzdCLElBQUl6SSxNQUFNbW1CLE1BQU1FLGVBQWU1ZCxRQUFRLElBQUloTyxNQUFNZ08sT0FBT2hQLE1BQU07UUFDOURnUCxPQUFPeEksT0FBTyxDQUFDLFNBQVUvQyxLQUFLLEVBQUVzaEIsR0FBRztZQUNqQ3hlLEdBQUcsQ0FBQ3dlLElBQUksR0FBRzRILFdBQVdscEIsT0FBT21wQjtRQUMvQjtRQUNBLE9BQU9ybUI7SUFDVDtJQUNBLElBQUlrSCxnQkFBZ0J1QixTQUFTO1FBQzNCLElBQUkwYixPQUFPZ0MsTUFBTUUsZUFBZTVkLFFBQVEsSUFBSTdFO1FBQzVDNkUsT0FBT3hJLE9BQU8sQ0FBQyxTQUFVL0MsS0FBSztZQUM1QmluQixLQUFLeFgsR0FBRyxDQUFDeVosV0FBV2xwQixPQUFPbXBCO1FBQzdCO1FBQ0EsT0FBT2xDO0lBQ1Q7SUFDQSxJQUFJbGQsZ0JBQWdCd0IsU0FBUztRQUMzQixJQUFJNmQsUUFBUUgsTUFBTUUsZUFBZTVkLFFBQVEsSUFBSThkO1FBQzdDOWQsT0FBT3hJLE9BQU8sQ0FBQyxTQUFVL0MsS0FBSyxFQUFFNUQsR0FBRztZQUNqQ2d0QixNQUFNdmhCLEdBQUcsQ0FBQ3pMLEtBQUs4c0IsV0FBV2xwQixPQUFPbXBCO1FBQ25DO1FBQ0EsT0FBT0M7SUFDVCxPQUFPO1FBQ0wsNEJBQTRCO1FBQzVCLElBQUlFLFFBQVFMLE1BQU1FLGVBQWU1ZCxRQUFRLENBQUM7UUFDMUNtZCxXQUFXbmQsUUFBUXhJLE9BQU8sQ0FBQyxTQUFVM0csR0FBRztZQUN0QyxJQUFJc0MsZ0JBQWdCMEQsb0JBQW9CLENBQUM1QixJQUFJLENBQUMrSyxRQUFRblAsTUFBTTtnQkFDMURrdEIsS0FBSyxDQUFDbHRCLElBQUksR0FBRzhzQixXQUFXM2QsTUFBTSxDQUFDblAsSUFBSSxFQUFFK3NCO1lBQ3ZDO1FBQ0Y7UUFDQSxPQUFPRztJQUNUO0FBQ0Y7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLEtBQUtoZSxNQUFNLEVBQUVMLE9BQU87SUFDM0IsSUFBSWpPLEtBQXFDLElBQUlpTyxTQUFTO1FBQ3BEaE8sSUFBSTtJQUNOO0lBQ0EsT0FBT2dzQixXQUFXM2QsUUFBUSxJQUFJOGQ7QUFDaEM7QUFFQSxTQUFTdkk7SUFDUCxJQUFJLEtBQXNDLEVBQUksRUFFN0M7SUFDRCxJQUFJRSxrQkFBa0I7SUFDdEIsSUFBSyxJQUFJNWpCLE9BQU9DLFVBQVVkLE1BQU0sRUFBRWUsT0FBTyxJQUFJQyxNQUFNSCxPQUFPSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQVE7UUFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSCxTQUFTLENBQUNHLEtBQUs7SUFDOUI7SUFDQSxJQUFJLE9BQU9GLElBQUksQ0FBQ0EsS0FBS2YsTUFBTSxHQUFHLEVBQUUsS0FBSyxXQUFXO1FBQzlDeWtCLGtCQUFrQjFqQixLQUFLa3NCLEdBQUc7SUFDNUI7SUFDQSxJQUFJMXNCLGFBQWEyc0IsZ0JBQWdCbnNCO0lBQ2pDLElBQUksQ0FBQ1IsWUFBWTtRQUNmLE9BQU9JLElBQUk7SUFDYjtJQUNBLElBQUlKLFdBQVcyYixVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRTtRQUM1QzVOLFFBQVEyUCxHQUFHLENBQUMsbUJBQW1CNWQsV0FBV3lKLEtBQUssR0FBRztJQUNwRDtJQUNBekosV0FBVzJiLFVBQVUsR0FBR3VJLGtCQUFrQnRJLFVBQVVxRyxLQUFLLEdBQUdyRyxVQUFVZ1IsR0FBRztBQUMzRTtBQUNBLFNBQVNELGdCQUFnQm5zQixJQUFJO0lBQzNCLE9BQVFBLEtBQUtmLE1BQU07UUFDakIsS0FBSztZQUNILE9BQU84QyxZQUFZd1Ysa0JBQWtCO1FBQ3ZDLEtBQUs7WUFDSCxPQUFPK1AsUUFBUXRuQixJQUFJLENBQUMsRUFBRTtRQUN4QixLQUFLO1lBQ0gsT0FBT3NuQixRQUFRdG5CLElBQUksQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxFQUFFO0lBQ25DO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTcXNCLFlBQVl6TSxNQUFNLEVBQUUwTSxPQUFPO0lBQ2xDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVcmdCO0lBQ1o7SUFDQS9CO0lBQ0EsSUFBSTtRQUNGLE9BQU8wVixPQUFPeGYsS0FBSyxDQUFDa3NCO0lBQ3RCLFNBQVU7UUFDUmxpQjtJQUNGO0FBQ0Y7QUFFQSxTQUFTbWlCLEtBQUtDLFNBQVMsRUFBRTVXLElBQUksRUFBRXJCLElBQUk7SUFDakMsSUFBSXhVLFVBQVVkLE1BQU0sS0FBSyxLQUFLMlcsUUFBUSxPQUFPQSxTQUFTLFVBQVU7UUFDOUQsT0FBTzZXLFlBQVlELFdBQVc1VztJQUNoQztJQUNBLE9BQU84VyxNQUFNRixXQUFXNVcsTUFBTXJCLFFBQVEsQ0FBQztBQUN6QztBQUNBLFNBQVNtWSxNQUFNRixTQUFTLEVBQUUvRixNQUFNLEVBQUU1USxJQUFJO0lBQ3BDLElBQUk4VztJQUNKLElBQUksT0FBTzlXLEtBQUsrVyxPQUFPLEtBQUssVUFBVTtRQUNwQyxJQUFJL3NCLFFBQVEsSUFBSVEsTUFBTTtRQUN0QnNzQixnQkFBZ0JsTSxXQUFXO1lBQ3pCLElBQUksQ0FBQ29NLFFBQVEsQ0FBQzlqQixNQUFNLENBQUMyWixVQUFVLEVBQUU7Z0JBQy9CbUs7Z0JBQ0EsSUFBSWhYLEtBQUtxUSxPQUFPLEVBQUU7b0JBQ2hCclEsS0FBS3FRLE9BQU8sQ0FBQ3JtQjtnQkFDZixPQUFPO29CQUNMLE1BQU1BO2dCQUNSO1lBQ0Y7UUFDRixHQUFHZ1csS0FBSytXLE9BQU87SUFDakI7SUFDQS9XLEtBQUt6VyxJQUFJLEdBQUdPLEtBQXFDLEdBQUdrVyxLQUFLelcsSUFBSSxJQUFJLFVBQVU2QyxjQUFjLENBQU07SUFDL0YsSUFBSTRrQixlQUFlNVgsYUFBYXRQLEtBQXFDLEdBQUdrVyxLQUFLelcsSUFBSSxHQUFHLFlBQVksQ0FBYSxFQUFFcW5CO0lBQy9HLDJCQUEyQjtJQUMzQixJQUFJb0csV0FBV3RQLFFBQVEsU0FBVXZYLENBQUM7UUFDaEMsb0NBQW9DO1FBQ3BDLElBQUk4bUIsT0FBT3BWLGtCQUFrQixPQUFPOFU7UUFDcEMsSUFBSU0sTUFBTTtZQUNSOW1CLEVBQUVrZCxPQUFPO1lBQ1QsSUFBSXlKLGVBQWU7Z0JBQ2pCSSxhQUFhSjtZQUNmO1lBQ0E5RjtRQUNGO0lBQ0YsR0FBR2hSO0lBQ0gsT0FBT2dYO0FBQ1Q7QUFDQSxTQUFTSixZQUFZRCxTQUFTLEVBQUUzVyxJQUFJO0lBQ2xDLElBQUltWDtJQUNKLElBQUlydEIsS0FBcUMsSUFBSWtXLFFBQVFBLEtBQUtxUSxPQUFPLEVBQUU7UUFDakUsT0FBT3RtQixJQUFJO0lBQ2I7SUFDQSxJQUFJaVcsUUFBUSxRQUFRLENBQUNtWCxlQUFlblgsS0FBS3dRLE1BQU0sS0FBSyxRQUFRMkcsYUFBYTFHLE9BQU8sRUFBRTtRQUNoRixPQUFPdGxCLE9BQU9ELE1BQU0sQ0FBQ2tvQixRQUFRRSxNQUFNLENBQUMsSUFBSTlvQixNQUFNLGtCQUFrQjtZQUM5RG9wQixRQUFRLFNBQVNBO2dCQUNmLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQSxJQUFJQTtJQUNKLElBQUl3RDtJQUNKLElBQUl6bkIsTUFBTSxJQUFJeWpCLFFBQVEsU0FBVUMsT0FBTyxFQUFFQyxNQUFNO1FBQzdDLElBQUkrRDtRQUNKLElBQUlMLFdBQVdILE1BQU1GLFdBQVd0RCxTQUFTbGlCLFNBQVMsQ0FBQyxHQUFHNk8sTUFBTTtZQUMxRHFRLFNBQVNpRDtRQUNYO1FBQ0FNLFNBQVMsU0FBU0E7WUFDaEJvRDtZQUNBMUQsT0FBTyxJQUFJOW9CLE1BQU07UUFDbkI7UUFDQTRzQixRQUFRLFNBQVNBO1lBQ2ZKO1lBQ0ExRCxPQUFPLElBQUk5b0IsTUFBTTtRQUNuQjtRQUNBd1YsUUFBUSxRQUFRLENBQUNxWCxnQkFBZ0JyWCxLQUFLd1EsTUFBTSxLQUFLLFFBQVE2RyxjQUFjM0osZ0JBQWdCLElBQUksUUFBUTJKLGNBQWMzSixnQkFBZ0IsQ0FBQyxTQUFTMEo7SUFDN0ksRUFBRSxDQUFDLFVBQVUsQ0FBQztRQUNaLElBQUlFO1FBQ0osT0FBT3RYLFFBQVEsUUFBUSxDQUFDc1gsZ0JBQWdCdFgsS0FBS3dRLE1BQU0sS0FBSyxRQUFROEcsY0FBYzdKLG1CQUFtQixJQUFJLE9BQU8sS0FBSyxJQUFJNkosY0FBYzdKLG1CQUFtQixDQUFDLFNBQVMySjtJQUNsSztJQUNBem5CLElBQUlpa0IsTUFBTSxHQUFHQTtJQUNiLE9BQU9qa0I7QUFDVDtBQUVBLFNBQVM0bkIsT0FBTy9uQixNQUFNO0lBQ3BCLE9BQU9BLE1BQU0sQ0FBQzBELE1BQU07QUFDdEI7QUFDQSw2SEFBNkg7QUFDN0gsNkZBQTZGO0FBQzdGLElBQUlza0IsbUJBQW1CO0lBQ3JCamIsS0FBSyxTQUFTQSxJQUFJL00sTUFBTSxFQUFFakcsSUFBSTtRQUM1QixJQUFJTyxLQUFxQyxJQUFJb0MsWUFBWXdWLGtCQUFrQixFQUFFO1lBQzNFMVYsMEJBQTBCO1FBQzVCO1FBQ0EsT0FBT3VyQixPQUFPL25CLFFBQVE0bEIsSUFBSSxDQUFDN3JCO0lBQzdCO0lBQ0FpTCxLQUFLLFNBQVNBLElBQUloRixNQUFNLEVBQUVqRyxJQUFJO1FBQzVCLE9BQU9ndUIsT0FBTy9uQixRQUFRNmxCLElBQUksQ0FBQzlyQjtJQUM3QjtJQUNBbUwsS0FBSyxTQUFTQSxJQUFJbEYsTUFBTSxFQUFFakcsSUFBSSxFQUFFc0QsS0FBSztRQUNuQyxJQUFJNHFCO1FBQ0osSUFBSSxDQUFDN3FCLFlBQVlyRCxPQUFPO1lBQ3RCLE9BQU87UUFDVDtRQUNBLElBQUlPLEtBQXFDLElBQUksQ0FBQ3l0QixPQUFPL25CLFFBQVE4TCxPQUFPLENBQUNpQixHQUFHLENBQUNoVCxPQUFPO1lBQzlFeUMsMEJBQTBCO1FBQzVCO1FBQ0EsdUNBQXVDO1FBQ3ZDLE9BQU8sQ0FBQ3lyQixlQUFlRixPQUFPL25CLFFBQVF3bEIsSUFBSSxDQUFDenJCLE1BQU1zRCxPQUFPLEtBQUksS0FBTSxPQUFPNHFCLGVBQWU7SUFDMUY7SUFDQUMsZ0JBQWdCLFNBQVNBLGVBQWVsb0IsTUFBTSxFQUFFakcsSUFBSTtRQUNsRCxJQUFJb3VCO1FBQ0osSUFBSTd0QixJQUFxQyxFQUFFO1lBQ3pDa0MsMEJBQTBCO1FBQzVCO1FBQ0EsSUFBSSxDQUFDWSxZQUFZckQsT0FBTztZQUN0QixPQUFPO1FBQ1Q7UUFDQSx1Q0FBdUM7UUFDdkMsT0FBTyxDQUFDb3VCLGtCQUFrQkosT0FBTy9uQixRQUFRMmxCLE9BQU8sQ0FBQzVyQixNQUFNLEtBQUksS0FBTSxPQUFPb3VCLGtCQUFrQjtJQUM1RjtJQUNBcnNCLGdCQUFnQixTQUFTQSxlQUFla0UsTUFBTSxFQUFFakcsSUFBSSxFQUFFa08sVUFBVTtRQUM5RCxJQUFJbWdCO1FBQ0osSUFBSTl0QixJQUFxQyxFQUFFO1lBQ3pDa0MsMEJBQTBCO1FBQzVCO1FBQ0EsdUNBQXVDO1FBQ3ZDLE9BQU8sQ0FBQzRyQix3QkFBd0JMLE9BQU8vbkIsUUFBUWtKLGVBQWUsQ0FBQ25QLE1BQU1rTyxXQUFVLEtBQU0sT0FBT21nQix3QkFBd0I7SUFDdEg7SUFDQTFvQixTQUFTLFNBQVNBLFFBQVFNLE1BQU07UUFDOUIsSUFBSTFGLEtBQXFDLElBQUlvQyxZQUFZd1Ysa0JBQWtCLEVBQUU7WUFDM0UxViwwQkFBMEI7UUFDNUI7UUFDQSxPQUFPdXJCLE9BQU8vbkIsUUFBUWdtQixRQUFRO0lBQ2hDO0lBQ0FxQyxtQkFBbUIsU0FBU0Esa0JBQWtCcm9CLE1BQU07UUFDbER6RixJQUFJO0lBQ047QUFDRjtBQUNBLFNBQVMwViwwQkFBMEJqUSxNQUFNLEVBQUV1SSxPQUFPO0lBQ2hELElBQUkrZixlQUFlQztJQUNuQmhzQjtJQUNBeUQsU0FBUzZMLG1CQUFtQjdMLFFBQVF1STtJQUNwQyxPQUFPLENBQUNnZ0IsdUJBQXVCLENBQUNELGdCQUFnQnRvQixNQUFNLENBQUMwRCxNQUFNLEVBQUVtSCxNQUFNLEtBQUssT0FBTzBkLHVCQUF1QkQsY0FBY3pkLE1BQU0sR0FBRyxJQUFJeE8sTUFBTTJELFFBQVFnb0I7QUFDbko7QUFFQSxTQUFTMVQsZ0JBQWdCa1UsYUFBYTtJQUNwQyxPQUFPQSxjQUFjL1UsYUFBYSxLQUFLN00sYUFBYTRoQixjQUFjL1UsYUFBYSxDQUFDN1osTUFBTSxHQUFHO0FBQzNGO0FBQ0EsU0FBU2liLG9CQUFvQjJULGFBQWEsRUFBRTVULE9BQU87SUFDakQsSUFBSTZULGVBQWVELGNBQWMvVSxhQUFhLElBQUsrVSxDQUFBQSxjQUFjL1UsYUFBYSxHQUFHLEVBQUU7SUFDbkZnVixhQUFhM00sSUFBSSxDQUFDbEg7SUFDbEIsT0FBTzlYLEtBQUs7UUFDVixJQUFJNmhCLE1BQU04SixhQUFhaE4sT0FBTyxDQUFDN0c7UUFDL0IsSUFBSStKLFFBQVEsQ0FBQyxHQUFHO1lBQ2Q4SixhQUFhN0osTUFBTSxDQUFDRCxLQUFLO1FBQzNCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNuSyxnQkFBZ0JnVSxhQUFhLEVBQUVqVSxNQUFNO0lBQzVDLElBQUk0RCxRQUFRN0Y7SUFDWixJQUFJO1FBQ0Ysd0ZBQXdGO1FBQ3hGLElBQUltVyxlQUFlLEVBQUUsQ0FBQ25wQixNQUFNLENBQUNrcEIsY0FBYy9VLGFBQWEsSUFBSSxFQUFFO1FBQzlELElBQUssSUFBSXZSLElBQUksR0FBRzJXLElBQUk0UCxhQUFhN3VCLE1BQU0sRUFBRXNJLElBQUkyVyxHQUFHM1csSUFBSztZQUNuRHFTLFNBQVNrVSxZQUFZLENBQUN2bUIsRUFBRSxDQUFDcVM7WUFDekIsSUFBSUEsVUFBVSxDQUFDQSxPQUFPeEMsSUFBSSxFQUFFO2dCQUMxQnhYLElBQUk7WUFDTjtZQUNBLElBQUksQ0FBQ2dhLFFBQVE7Z0JBQ1g7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVCxTQUFVO1FBQ1J2QixhQUFhbUY7SUFDZjtBQUNGO0FBRUEsU0FBUzFELGFBQWFpVSxVQUFVO0lBQzlCLE9BQU9BLFdBQVdoVixnQkFBZ0IsS0FBSzlNLGFBQWE4aEIsV0FBV2hWLGdCQUFnQixDQUFDOVosTUFBTSxHQUFHO0FBQzNGO0FBQ0EsU0FBU29iLGlCQUFpQjBULFVBQVUsRUFBRTlULE9BQU87SUFDM0MsSUFBSTJLLFlBQVltSixXQUFXaFYsZ0JBQWdCLElBQUtnVixDQUFBQSxXQUFXaFYsZ0JBQWdCLEdBQUcsRUFBRTtJQUNoRjZMLFVBQVV6RCxJQUFJLENBQUNsSDtJQUNmLE9BQU85WCxLQUFLO1FBQ1YsSUFBSTZoQixNQUFNWSxVQUFVOUQsT0FBTyxDQUFDN0c7UUFDNUIsSUFBSStKLFFBQVEsQ0FBQyxHQUFHO1lBQ2RZLFVBQVVYLE1BQU0sQ0FBQ0QsS0FBSztRQUN4QjtJQUNGO0FBQ0Y7QUFDQSxTQUFTakssZ0JBQWdCZ1UsVUFBVSxFQUFFblUsTUFBTTtJQUN6QyxJQUFJNEQsUUFBUTdGO0lBQ1osSUFBSWlOLFlBQVltSixXQUFXaFYsZ0JBQWdCO0lBQzNDLElBQUksQ0FBQzZMLFdBQVc7UUFDZDtJQUNGO0lBQ0FBLFlBQVlBLFVBQVVuZCxLQUFLO0lBQzNCLElBQUssSUFBSUYsSUFBSSxHQUFHMlcsSUFBSTBHLFVBQVUzbEIsTUFBTSxFQUFFc0ksSUFBSTJXLEdBQUczVyxJQUFLO1FBQ2hEcWQsU0FBUyxDQUFDcmQsRUFBRSxDQUFDcVM7SUFDZjtJQUNBdkIsYUFBYW1GO0FBQ2Y7QUFFQSxTQUFTd1EsZUFBZTNvQixNQUFNLEVBQUUyaUIsV0FBVyxFQUFFcGEsT0FBTztJQUNsRHdILGVBQWU7UUFDYixJQUFJNlk7UUFDSixJQUFJOWdCLE1BQU0rRCxtQkFBbUI3TCxRQUFRdUksUUFBUSxDQUFDN0UsTUFBTTtRQUNwRCxJQUFJcEosS0FBcUMsSUFBSXFvQixlQUFlM2lCLE1BQU0sQ0FBQ3VDLHdCQUF3QixFQUFFO1lBQzNGaEksSUFBSTtRQUNOO1FBQ0Esd0JBQXdCO1FBQ3ZCcXVCLENBQUFBLGVBQWVqRyxXQUFVLEtBQU0sT0FBT2lHLGVBQWVqRyxjQUFjdmYseUJBQXlCcEQ7UUFDN0YsV0FBVztRQUNYTixRQUFRaWpCLGFBQWF2aUIsT0FBTyxDQUFDLFNBQVUzRyxHQUFHO1lBQ3hDLE9BQU9xTyxJQUFJRixLQUFLLENBQUNuTyxLQUFLa3BCLFdBQVcsQ0FBQ2xwQixJQUFJO1FBQ3hDO0lBQ0Y7SUFDQSxPQUFPdUc7QUFDVDtBQUNBLDZDQUE2QztBQUM3QyxJQUFJNm9CLGFBQWEsV0FBVyxHQUFFMW5CLE9BQU87QUFDckMsU0FBUzJuQixtQkFBbUI5b0IsTUFBTSxFQUFFK29CLFNBQVMsRUFBRXhnQixPQUFPO0lBQ3BELElBQUlqTyxJQUFxQyxFQUFFO1FBQ3pDLElBQUksQ0FBQ2tELGNBQWN3QyxXQUFXLENBQUN4QyxjQUFjN0IsT0FBTytCLGNBQWMsQ0FBQ3NDLFVBQVU7WUFDM0V6RixJQUFJO1FBQ047UUFDQSxJQUFJMk0sbUJBQW1CbEgsU0FBUztZQUM5QnpGLElBQUk7UUFDTjtJQUNGO0lBQ0Esc0NBQXNDO0lBQ3RDLDBFQUEwRTtJQUMxRSxJQUFJaUQsY0FBY3dDLFNBQVM7UUFDekIsT0FBT2dRLGlCQUFpQmhRLFFBQVFBLFFBQVErb0IsV0FBV3hnQjtJQUNyRDtJQUNBd0gsZUFBZTtRQUNiLElBQUlqSSxNQUFNK0QsbUJBQW1CN0wsUUFBUXVJLFFBQVEsQ0FBQzdFLE1BQU07UUFDcEQsb0NBQW9DO1FBQ3BDLDhGQUE4RjtRQUM5RixJQUFJLENBQUMxRCxNQUFNLENBQUM2b0IsV0FBVyxFQUFFO1lBQ3ZCLElBQUlwckIsUUFBUTlCLE9BQU8rQixjQUFjLENBQUNzQztZQUNsQyxJQUFJWixPQUFPLElBQUkyRSxJQUFJLEVBQUUsQ0FBQ3pFLE1BQU0sQ0FBQ0ksUUFBUU0sU0FBU04sUUFBUWpDO1lBQ3REMkIsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNmQSxJQUFJLENBQUMsU0FBUyxDQUFDc0U7WUFDZnpGLGNBQWNSLE9BQU9vckIsWUFBWXpwQjtRQUNuQztRQUNBWSxNQUFNLENBQUM2b0IsV0FBVyxDQUFDem9CLE9BQU8sQ0FBQyxTQUFVM0csR0FBRztZQUN0QyxPQUFPcU8sSUFBSUYsS0FBSyxDQUFDbk8sS0FDakIsK0NBQStDO1lBQy9DLENBQUNzdkIsWUFBWSxPQUFPdHZCLE9BQU9zdkIsWUFBWUEsU0FBUyxDQUFDdHZCLElBQUksR0FBRztRQUMxRDtJQUNGO0lBQ0EsT0FBT3VHO0FBQ1Q7QUFFQSxJQUFJZ3BCLFNBQVM7QUFDYixJQUFJN1UsU0FBUztBQUNiLElBQUk4VSxrQkFBa0IsT0FBTyxxREFBcUQ7QUFDbEYsSUFBSUMsYUFBYTtJQUNmbGtCLEtBQUssU0FBU0EsSUFBSWhGLE1BQU0sRUFBRWpHLElBQUk7UUFDNUIsSUFBSStOLE1BQU05SCxNQUFNLENBQUMwRCxNQUFNO1FBQ3ZCLElBQUkzSixTQUFTMkosT0FBTztZQUNsQixPQUFPb0U7UUFDVDtRQUNBLElBQUkvTixTQUFTLFVBQVU7WUFDckIsT0FBTytOLElBQUlxaEIsZUFBZTtRQUM1QjtRQUNBLElBQUksT0FBT3B2QixTQUFTLFlBQVksQ0FBQ3F2QixNQUFNcnZCLE9BQU87WUFDNUMsT0FBTytOLElBQUkrZCxJQUFJLENBQUNKLFNBQVMxckI7UUFDM0I7UUFDQSxJQUFJZ0csUUFBUXNwQixpQkFBaUJ0dkIsT0FBTztZQUNsQyxPQUFPc3ZCLGVBQWUsQ0FBQ3R2QixLQUFLO1FBQzlCO1FBQ0EsT0FBT2lHLE1BQU0sQ0FBQ2pHLEtBQUs7SUFDckI7SUFDQW1MLEtBQUssU0FBU0EsSUFBSWxGLE1BQU0sRUFBRWpHLElBQUksRUFBRXNELEtBQUs7UUFDbkMsSUFBSXlLLE1BQU05SCxNQUFNLENBQUMwRCxNQUFNO1FBQ3ZCLElBQUkzSixTQUFTLFVBQVU7WUFDckIrTixJQUFJd2hCLGVBQWUsQ0FBQ2pzQjtRQUN0QjtRQUNBLElBQUksT0FBT3RELFNBQVMsWUFBWXF2QixNQUFNcnZCLE9BQU87WUFDM0NpRyxNQUFNLENBQUNqRyxLQUFLLEdBQUdzRDtRQUNqQixPQUFPO1lBQ0wsaUJBQWlCO1lBQ2pCeUssSUFBSTBkLElBQUksQ0FBQ0MsU0FBUzFyQixPQUFPc0Q7UUFDM0I7UUFDQSxPQUFPO0lBQ1Q7SUFDQWdyQixtQkFBbUIsU0FBU0E7UUFDMUI5dEIsSUFBSTtJQUNOO0FBQ0Y7QUFDQSxJQUFJZ3ZCLGdDQUFnQyxXQUFXLEdBQUU7SUFDL0MsU0FBU0EsOEJBQThCeHZCLElBQUksRUFBRXlTLFFBQVEsRUFBRWdkLE1BQU0sRUFBRUMsV0FBVztRQUN4RSxJQUFJMXZCLFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPTyxLQUFxQyxHQUFHLHFCQUFxQnNDLGNBQWMsQ0FBaUI7UUFDckc7UUFDQSxJQUFJLENBQUM0c0IsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsS0FBSztRQUN4QixJQUFJLENBQUNDLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQzVkLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLDJEQUEyRDtRQUMzRCxJQUFJLENBQUMySCxhQUFhLEdBQUcsS0FBSztRQUMxQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEtBQUs7UUFDN0IsSUFBSSxDQUFDaVcsU0FBUyxHQUFHLEtBQUs7UUFDdEIsSUFBSSxDQUFDL1YsUUFBUSxHQUFHLEtBQUs7UUFDckIsSUFBSSxDQUFDL0ksTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDK2UsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDSixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUkvbEIsS0FBSzVKO1FBQ3RCLElBQUksQ0FBQzR2QixTQUFTLEdBQUcsU0FBVUUsSUFBSSxFQUFFQyxJQUFJO1lBQ25DLE9BQU90ZCxTQUFTcWQsTUFBTUMsTUFBTXh2QixLQUFxQyxHQUFHUCxPQUFPLFNBQVMsQ0FBcUI7UUFDM0c7SUFDRjtJQUNBLElBQUl1SyxTQUFTaWxCLDhCQUE4QnZ0QixTQUFTO0lBQ3BEc0ksT0FBT3lsQixhQUFhLEdBQUcsU0FBU0EsY0FBYzFzQixLQUFLO1FBQ2pELElBQUksSUFBSSxDQUFDdVcsUUFBUSxLQUFLaE4sV0FBVztZQUMvQixPQUFPLElBQUksQ0FBQ2dOLFFBQVEsQ0FBQ3ZXO1FBQ3ZCO1FBQ0EsT0FBT0E7SUFDVDtJQUNBaUgsT0FBTzBsQixjQUFjLEdBQUcsU0FBU0EsZUFBZTNFLE1BQU07UUFDcEQsSUFBSSxJQUFJLENBQUN6UixRQUFRLEtBQUtoTixhQUFheWUsT0FBT3pyQixNQUFNLEdBQUcsR0FBRztZQUNwRCxPQUFPeXJCLE9BQU9wcUIsR0FBRyxDQUFDLElBQUksQ0FBQzJZLFFBQVE7UUFDakM7UUFDQSxPQUFPeVI7SUFDVDtJQUNBL2dCLE9BQU9xUSxVQUFVLEdBQUcsU0FBU0EsV0FBV0MsT0FBTztRQUM3QyxPQUFPQyxvQkFBb0IsSUFBSSxFQUFFRDtJQUNuQztJQUNBdFEsT0FBT3dRLFFBQVEsR0FBRyxTQUFTQSxTQUFTdFEsUUFBUSxFQUFFdVEsZUFBZTtRQUMzRCxJQUFJQSxvQkFBb0IsS0FBSyxHQUFHO1lBQzlCQSxrQkFBa0I7UUFDcEI7UUFDQSxJQUFJQSxpQkFBaUI7WUFDbkJ2USxTQUFTO2dCQUNQc1AsZ0JBQWdCO2dCQUNoQjVWLFFBQVEsSUFBSSxDQUFDMk0sTUFBTTtnQkFDbkJrSixpQkFBaUIsSUFBSSxDQUFDMlYsS0FBSyxDQUFDOWxCLEtBQUs7Z0JBQ2pDbU8sTUFBTTtnQkFDTnBZLE9BQU87Z0JBQ1Bzd0IsT0FBTyxJQUFJLENBQUNuZSxPQUFPLENBQUMxSixLQUFLO2dCQUN6QjhuQixZQUFZLElBQUksQ0FBQ3BlLE9BQU8sQ0FBQ2xTLE1BQU07Z0JBQy9CdXdCLFNBQVMsRUFBRTtnQkFDWEMsY0FBYztZQUNoQjtRQUNGO1FBQ0EsT0FBT3BWLGlCQUFpQixJQUFJLEVBQUV4UTtJQUNoQztJQUNBRixPQUFPNmtCLGVBQWUsR0FBRyxTQUFTQTtRQUNoQyxJQUFJLENBQUNPLEtBQUssQ0FBQ2hsQixjQUFjO1FBQ3pCLE9BQU8sSUFBSSxDQUFDb0gsT0FBTyxDQUFDbFMsTUFBTTtJQUM1QjtJQUNBMEssT0FBT2dsQixlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCZSxTQUFTO1FBQ3pELElBQUksT0FBT0EsY0FBYyxZQUFZakIsTUFBTWlCLGNBQWNBLFlBQVksR0FBRztZQUN0RTl2QixJQUFJLG1CQUFtQjh2QjtRQUN6QjtRQUNBLElBQUlDLGdCQUFnQixJQUFJLENBQUN4ZSxPQUFPLENBQUNsUyxNQUFNO1FBQ3ZDLElBQUl5d0IsY0FBY0MsZUFBZTtZQUMvQjtRQUNGLE9BQU8sSUFBSUQsWUFBWUMsZUFBZTtZQUNwQyxJQUFJQyxXQUFXLElBQUkzdkIsTUFBTXl2QixZQUFZQztZQUNyQyxJQUFLLElBQUlwb0IsSUFBSSxHQUFHQSxJQUFJbW9CLFlBQVlDLGVBQWVwb0IsSUFBSztnQkFDbERxb0IsUUFBUSxDQUFDcm9CLEVBQUUsR0FBRzBFO1lBQ2hCLEVBQUUsOEJBQThCO1lBQ2hDLElBQUksQ0FBQzRqQixnQkFBZ0IsQ0FBQ0YsZUFBZSxHQUFHQztRQUMxQyxPQUFPO1lBQ0wsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0gsV0FBV0MsZ0JBQWdCRDtRQUNuRDtJQUNGO0lBQ0EvbEIsT0FBT21tQixrQkFBa0IsR0FBRyxTQUFTQSxtQkFBbUJDLFNBQVMsRUFBRUMsS0FBSztRQUN0RSxJQUFJRCxjQUFjLElBQUksQ0FBQ2QsZ0JBQWdCLEVBQUU7WUFDdkNydkIsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDcXZCLGdCQUFnQixJQUFJZTtRQUN6QixJQUFJLElBQUksQ0FBQ2xCLFdBQVcsSUFBSWtCLFFBQVEsR0FBRztZQUNqQ0MsbUJBQW1CRixZQUFZQyxRQUFRO1FBQ3pDO0lBQ0Y7SUFDQXJtQixPQUFPa21CLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFpQjd3QixLQUFLLEVBQUVreEIsV0FBVyxFQUFFTixRQUFRO1FBQzlFLElBQUloWCxRQUFRLElBQUk7UUFDaEJjLG9DQUFvQyxJQUFJLENBQUNxVixLQUFLO1FBQzlDLElBQUk5dkIsU0FBUyxJQUFJLENBQUNrUyxPQUFPLENBQUNsUyxNQUFNO1FBQ2hDLElBQUlELFVBQVVpTixXQUFXO1lBQ3ZCak4sUUFBUTtRQUNWLE9BQU8sSUFBSUEsUUFBUUMsUUFBUTtZQUN6QkQsUUFBUUM7UUFDVixPQUFPLElBQUlELFFBQVEsR0FBRztZQUNwQkEsUUFBUW14QixLQUFLQyxHQUFHLENBQUMsR0FBR254QixTQUFTRDtRQUMvQjtRQUNBLElBQUllLFVBQVVkLE1BQU0sS0FBSyxHQUFHO1lBQzFCaXhCLGNBQWNqeEIsU0FBU0Q7UUFDekIsT0FBTyxJQUFJa3hCLGdCQUFnQmprQixhQUFhaWtCLGdCQUFnQixNQUFNO1lBQzVEQSxjQUFjO1FBQ2hCLE9BQU87WUFDTEEsY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ0gsYUFBYWp4QixTQUFTRDtRQUMzRDtRQUNBLElBQUk0d0IsYUFBYTNqQixXQUFXO1lBQzFCMmpCLFdBQVd0dUI7UUFDYjtRQUNBLElBQUlxWSxnQkFBZ0IsSUFBSSxHQUFHO1lBQ3pCLElBQUlDLFNBQVNDLGdCQUFnQixJQUFJLEVBQUU7Z0JBQ2pDdFcsUUFBUSxJQUFJLENBQUMyTSxNQUFNO2dCQUNuQmtILE1BQU1pWDtnQkFDTnJ2QixPQUFPQTtnQkFDUHl3QixjQUFjUztnQkFDZFosT0FBT007WUFDVDtZQUNBLElBQUksQ0FBQ2hXLFFBQVE7Z0JBQ1gsT0FBT3RZO1lBQ1Q7WUFDQTR1QixjQUFjdFcsT0FBTzZWLFlBQVk7WUFDakNHLFdBQVdoVyxPQUFPMFYsS0FBSztRQUN6QjtRQUNBTSxXQUFXQSxTQUFTM3dCLE1BQU0sS0FBSyxJQUFJMndCLFdBQVdBLFNBQVN0dkIsR0FBRyxDQUFDLFNBQVV1TCxDQUFDO1lBQ3BFLE9BQU8rTSxNQUFNb1csU0FBUyxDQUFDbmpCLEdBQUdJO1FBQzVCO1FBQ0EsSUFBSSxJQUFJLENBQUM2aUIsV0FBVyxJQUFJbnZCLGtCQUF5QixjQUFjO1lBQzdELElBQUkyd0IsY0FBY1YsU0FBUzN3QixNQUFNLEdBQUdpeEI7WUFDcEMsSUFBSSxDQUFDSixrQkFBa0IsQ0FBQzd3QixRQUFRcXhCLGNBQWMsMkNBQTJDO1FBQzNGO1FBQ0EsSUFBSTlxQixNQUFNLElBQUksQ0FBQytxQixzQkFBc0IsQ0FBQ3Z4QixPQUFPa3hCLGFBQWFOO1FBQzFELElBQUlNLGdCQUFnQixLQUFLTixTQUFTM3dCLE1BQU0sS0FBSyxHQUFHO1lBQzlDLElBQUksQ0FBQ3V4QixrQkFBa0IsQ0FBQ3h4QixPQUFPNHdCLFVBQVVwcUI7UUFDM0M7UUFDQSxPQUFPLElBQUksQ0FBQzZwQixjQUFjLENBQUM3cEI7SUFDN0I7SUFDQW1FLE9BQU80bUIsc0JBQXNCLEdBQUcsU0FBU0EsdUJBQXVCdnhCLEtBQUssRUFBRWt4QixXQUFXLEVBQUVOLFFBQVE7UUFDMUYsSUFBSUEsU0FBUzN3QixNQUFNLEdBQUdxdkIsaUJBQWlCO1lBQ3JDLElBQUltQztZQUNKLE9BQU8sQ0FBQ0EsZ0JBQWdCLElBQUksQ0FBQ3RmLE9BQU8sRUFBRThTLE1BQU0sQ0FBQzdqQixLQUFLLENBQUNxd0IsZUFBZTtnQkFBQ3p4QjtnQkFBT2t4QjthQUFZLENBQUN2ckIsTUFBTSxDQUFDaXJCO1FBQ2hHLE9BQU87WUFDTCxrQ0FBa0M7WUFDbEMsSUFBSXBxQixNQUFNLElBQUksQ0FBQzJMLE9BQU8sQ0FBQzFKLEtBQUssQ0FBQ3pJLE9BQU9BLFFBQVFreEI7WUFDNUMsNERBQTREO1lBQzVELElBQUlRLFdBQVcsSUFBSSxDQUFDdmYsT0FBTyxDQUFDMUosS0FBSyxDQUFDekksUUFBUWt4QjtZQUMxQyxzRUFBc0U7WUFDdEUsSUFBSSxDQUFDL2UsT0FBTyxDQUFDbFMsTUFBTSxJQUFJMndCLFNBQVMzd0IsTUFBTSxHQUFHaXhCO1lBQ3pDLElBQUssSUFBSTNvQixJQUFJLEdBQUdBLElBQUlxb0IsU0FBUzN3QixNQUFNLEVBQUVzSSxJQUFLO2dCQUN4QyxJQUFJLENBQUM0SixPQUFPLENBQUNuUyxRQUFRdUksRUFBRSxHQUFHcW9CLFFBQVEsQ0FBQ3JvQixFQUFFO1lBQ3ZDO1lBQ0EsSUFBSyxJQUFJb3BCLEtBQUssR0FBR0EsS0FBS0QsU0FBU3p4QixNQUFNLEVBQUUweEIsS0FBTTtnQkFDM0MsSUFBSSxDQUFDeGYsT0FBTyxDQUFDblMsUUFBUTR3QixTQUFTM3dCLE1BQU0sR0FBRzB4QixHQUFHLEdBQUdELFFBQVEsQ0FBQ0MsR0FBRztZQUMzRDtZQUNBLE9BQU9uckI7UUFDVDtJQUNGO0lBQ0FtRSxPQUFPaW5CLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF3QjV4QixLQUFLLEVBQUU4RyxRQUFRLEVBQUVnSCxRQUFRO1FBQ3pGLElBQUk2TCxZQUFZLENBQUMsSUFBSSxDQUFDa1csTUFBTSxJQUFJL1g7UUFDaEMsSUFBSStMLFNBQVMvSSxhQUFhLElBQUk7UUFDOUIsSUFBSUYsU0FBU2lKLFVBQVVsSyxZQUFZO1lBQ2pDUSxnQkFBZ0I7WUFDaEI1VixRQUFRLElBQUksQ0FBQzJNLE1BQU07WUFDbkJrSCxNQUFNb0M7WUFDTkosaUJBQWlCLElBQUksQ0FBQzJWLEtBQUssQ0FBQzlsQixLQUFLO1lBQ2pDakssT0FBT0E7WUFDUDhHLFVBQVVBO1lBQ1ZnSCxVQUFVQTtRQUNaLElBQUk7UUFDSixzSEFBc0g7UUFDdEgsZ0dBQWdHO1FBQ2hHLElBQUluTixLQUFxQyxJQUFJZ1osV0FBVztZQUN0RHhCLGVBQWV5QztRQUNqQjtRQUNBLElBQUksQ0FBQ21WLEtBQUssQ0FBQzlrQixhQUFhO1FBQ3hCLElBQUk0WSxRQUFRO1lBQ1Y5SSxnQkFBZ0IsSUFBSSxFQUFFSDtRQUN4QjtRQUNBLElBQUlqYSxLQUFxQyxJQUFJZ1osV0FBVztZQUN0REw7UUFDRjtJQUNGO0lBQ0EzTyxPQUFPNm1CLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFtQnh4QixLQUFLLEVBQUVzd0IsS0FBSyxFQUFFRSxPQUFPO1FBQzNFLElBQUk3VyxZQUFZLENBQUMsSUFBSSxDQUFDa1csTUFBTSxJQUFJL1g7UUFDaEMsSUFBSStMLFNBQVMvSSxhQUFhLElBQUk7UUFDOUIsSUFBSUYsU0FBU2lKLFVBQVVsSyxZQUFZO1lBQ2pDUSxnQkFBZ0I7WUFDaEI1VixRQUFRLElBQUksQ0FBQzJNLE1BQU07WUFDbkJrSixpQkFBaUIsSUFBSSxDQUFDMlYsS0FBSyxDQUFDOWxCLEtBQUs7WUFDakNtTyxNQUFNaVg7WUFDTnJ2QixPQUFPQTtZQUNQd3dCLFNBQVNBO1lBQ1RGLE9BQU9BO1lBQ1BHLGNBQWNELFFBQVF2d0IsTUFBTTtZQUM1QnN3QixZQUFZRCxNQUFNcndCLE1BQU07UUFDMUIsSUFBSTtRQUNKLElBQUlVLEtBQXFDLElBQUlnWixXQUFXO1lBQ3REeEIsZUFBZXlDO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDbVYsS0FBSyxDQUFDOWtCLGFBQWE7UUFDeEIsMEdBQTBHO1FBQzFHLElBQUk0WSxRQUFRO1lBQ1Y5SSxnQkFBZ0IsSUFBSSxFQUFFSDtRQUN4QjtRQUNBLElBQUlqYSxLQUFxQyxJQUFJZ1osV0FBVztZQUN0REw7UUFDRjtJQUNGO0lBQ0EzTyxPQUFPdWhCLElBQUksR0FBRyxTQUFTQSxLQUFLbHNCLEtBQUs7UUFDL0IsSUFBSSxJQUFJLENBQUM4dkIsV0FBVyxJQUFJOXZCLFNBQVMsSUFBSSxDQUFDbVMsT0FBTyxDQUFDbFMsTUFBTSxFQUFFO1lBQ3BEd08sUUFBUUMsSUFBSSxDQUFDL04sS0FBcUMsR0FBRyxrREFBa0RYLFFBQVEsOEJBQThCLElBQUksQ0FBQ21TLE9BQU8sQ0FBQ2xTLE1BQU0sR0FBRyxtRkFBbUYsQ0FBcUNEO1lBQzNSLE9BQU9pTjtRQUNUO1FBQ0EsSUFBSSxDQUFDOGlCLEtBQUssQ0FBQ2hsQixjQUFjO1FBQ3pCLE9BQU8sSUFBSSxDQUFDcWxCLGFBQWEsQ0FBQyxJQUFJLENBQUNqZSxPQUFPLENBQUNuUyxNQUFNO0lBQy9DO0lBQ0EySyxPQUFPa2hCLElBQUksR0FBRyxTQUFTQSxLQUFLN3JCLEtBQUssRUFBRThHLFFBQVE7UUFDekMsSUFBSTRrQixTQUFTLElBQUksQ0FBQ3ZaLE9BQU87UUFDekIsSUFBSSxJQUFJLENBQUMyZCxXQUFXLElBQUk5dkIsUUFBUTByQixPQUFPenJCLE1BQU0sRUFBRTtZQUM3QyxnQkFBZ0I7WUFDaEJXLElBQUksSUFBSVosT0FBTzByQixPQUFPenJCLE1BQU07UUFDOUI7UUFDQSxJQUFJRCxRQUFRMHJCLE9BQU96ckIsTUFBTSxFQUFFO1lBQ3pCLDJCQUEyQjtZQUMzQnlhLG9DQUFvQyxJQUFJLENBQUNxVixLQUFLO1lBQzlDLElBQUlqaUIsV0FBVzRkLE1BQU0sQ0FBQzFyQixNQUFNO1lBQzVCLElBQUkyYSxnQkFBZ0IsSUFBSSxHQUFHO2dCQUN6QixJQUFJQyxTQUFTQyxnQkFBZ0IsSUFBSSxFQUFFO29CQUNqQ3pDLE1BQU1vQztvQkFDTmpXLFFBQVEsSUFBSSxDQUFDMk0sTUFBTTtvQkFDbkIsMkRBQTJEO29CQUMzRGxSLE9BQU9BO29CQUNQOEcsVUFBVUE7Z0JBQ1o7Z0JBQ0EsSUFBSSxDQUFDOFQsUUFBUTtvQkFDWDtnQkFDRjtnQkFDQTlULFdBQVc4VCxPQUFPOVQsUUFBUTtZQUM1QjtZQUNBQSxXQUFXLElBQUksQ0FBQ2twQixTQUFTLENBQUNscEIsVUFBVWdIO1lBQ3BDLElBQUlnUSxVQUFVaFgsYUFBYWdIO1lBQzNCLElBQUlnUSxTQUFTO2dCQUNYNE4sTUFBTSxDQUFDMXJCLE1BQU0sR0FBRzhHO2dCQUNoQixJQUFJLENBQUM4cUIsdUJBQXVCLENBQUM1eEIsT0FBTzhHLFVBQVVnSDtZQUNoRDtRQUNGLE9BQU87WUFDTCxrRUFBa0U7WUFDbEUsc0VBQXNFO1lBQ3RFLGtDQUFrQztZQUNsQyxJQUFJOGlCLFdBQVcsSUFBSTN2QixNQUFNakIsUUFBUSxJQUFJMHJCLE9BQU96ckIsTUFBTTtZQUNsRCxJQUFLLElBQUlzSSxJQUFJLEdBQUdBLElBQUlxb0IsU0FBUzN3QixNQUFNLEdBQUcsR0FBR3NJLElBQUs7Z0JBQzVDcW9CLFFBQVEsQ0FBQ3JvQixFQUFFLEdBQUcwRTtZQUNoQixFQUFFLDhCQUE4QjtZQUNoQzJqQixRQUFRLENBQUNBLFNBQVMzd0IsTUFBTSxHQUFHLEVBQUUsR0FBRzZHO1lBQ2hDLElBQUksQ0FBQytwQixnQkFBZ0IsQ0FBQ25GLE9BQU96ckIsTUFBTSxFQUFFLEdBQUcyd0I7UUFDMUM7SUFDRjtJQUNBLE9BQU9oQjtBQUNUO0FBQ0EsU0FBUzdaLHNCQUFzQkgsYUFBYSxFQUFFL0MsUUFBUSxFQUFFelMsSUFBSSxFQUFFeXhCLEtBQUs7SUFDakUsSUFBSXp4QixTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBT08sS0FBcUMsR0FBRyxxQkFBcUJzQyxjQUFjLENBQWlCO0lBQ3JHO0lBQ0EsSUFBSTR1QixVQUFVLEtBQUssR0FBRztRQUNwQkEsUUFBUTtJQUNWO0lBQ0FqdkI7SUFDQSxPQUFPd1QsZUFBZTtRQUNwQixJQUFJakksTUFBTSxJQUFJeWhCLDhCQUE4Qnh2QixNQUFNeVMsVUFBVWdmLE9BQU87UUFDbkVqdEIsbUJBQW1CdUosSUFBSWdFLE9BQU8sRUFBRXBJLE9BQU9vRTtRQUN2QyxJQUFJeUcsUUFBUSxJQUFJbFMsTUFBTXlMLElBQUlnRSxPQUFPLEVBQUVvZDtRQUNuQ3BoQixJQUFJK0MsTUFBTSxHQUFHMEQ7UUFDYixJQUFJZ0IsaUJBQWlCQSxjQUFjM1YsTUFBTSxFQUFFO1lBQ3pDa08sSUFBSTBpQixnQkFBZ0IsQ0FBQyxHQUFHLEdBQUdqYjtRQUM3QjtRQUNBLE9BQU9oQjtJQUNUO0FBQ0Y7QUFDQSwyQkFBMkI7QUFDM0IsSUFBSThhLGtCQUFrQjtJQUNwQm9DLE9BQU8sU0FBU0E7UUFDZCxPQUFPLElBQUksQ0FBQzdNLE1BQU0sQ0FBQztJQUNyQjtJQUNBbkMsU0FBUyxTQUFTQSxRQUFROE4sUUFBUTtRQUNoQyxJQUFJemlCLE1BQU0sSUFBSSxDQUFDcEUsTUFBTTtRQUNyQixPQUFPb0UsSUFBSTBpQixnQkFBZ0IsQ0FBQyxHQUFHMWlCLElBQUlnRSxPQUFPLENBQUNsUyxNQUFNLEVBQUUyd0I7SUFDckQ7SUFDQSx5QkFBeUI7SUFDekJyVixRQUFRLFNBQVNBO1FBQ2YsT0FBTyxJQUFJLENBQUM5UyxLQUFLO0lBQ25CO0lBQ0E7Ozs7O0dBS0MsR0FDRHdjLFFBQVEsU0FBU0EsT0FBT2psQixLQUFLLEVBQUVreEIsV0FBVztRQUN4QyxJQUFLLElBQUlwd0IsT0FBT0MsVUFBVWQsTUFBTSxFQUFFMndCLFdBQVcsSUFBSTN2QixNQUFNSCxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQVE7WUFDOUcwdkIsUUFBUSxDQUFDMXZCLE9BQU8sRUFBRSxHQUFHSCxTQUFTLENBQUNHLEtBQUs7UUFDdEM7UUFDQSxJQUFJaU4sTUFBTSxJQUFJLENBQUNwRSxNQUFNO1FBQ3JCLE9BQVFoSixVQUFVZCxNQUFNO1lBQ3RCLEtBQUs7Z0JBQ0gsT0FBTyxFQUFFO1lBQ1gsS0FBSztnQkFDSCxPQUFPa08sSUFBSTBpQixnQkFBZ0IsQ0FBQzd3QjtZQUM5QixLQUFLO2dCQUNILE9BQU9tTyxJQUFJMGlCLGdCQUFnQixDQUFDN3dCLE9BQU9reEI7UUFDdkM7UUFDQSxPQUFPL2lCLElBQUkwaUIsZ0JBQWdCLENBQUM3d0IsT0FBT2t4QixhQUFhTjtJQUNsRDtJQUNBbUIsaUJBQWlCLFNBQVNBLGdCQUFnQi94QixLQUFLLEVBQUVreEIsV0FBVyxFQUFFTixRQUFRO1FBQ3BFLE9BQU8sSUFBSSxDQUFDN21CLE1BQU0sQ0FBQzhtQixnQkFBZ0IsQ0FBQzd3QixPQUFPa3hCLGFBQWFOO0lBQzFEO0lBQ0F6TyxNQUFNLFNBQVNBO1FBQ2IsSUFBSWhVLE1BQU0sSUFBSSxDQUFDcEUsTUFBTTtRQUNyQixJQUFLLElBQUlpb0IsUUFBUWp4QixVQUFVZCxNQUFNLEVBQUVneUIsUUFBUSxJQUFJaHhCLE1BQU0rd0IsUUFBUUUsUUFBUSxHQUFHQSxRQUFRRixPQUFPRSxRQUFTO1lBQzlGRCxLQUFLLENBQUNDLE1BQU0sR0FBR254QixTQUFTLENBQUNteEIsTUFBTTtRQUNqQztRQUNBL2pCLElBQUkwaUIsZ0JBQWdCLENBQUMxaUIsSUFBSWdFLE9BQU8sQ0FBQ2xTLE1BQU0sRUFBRSxHQUFHZ3lCO1FBQzVDLE9BQU85akIsSUFBSWdFLE9BQU8sQ0FBQ2xTLE1BQU07SUFDM0I7SUFDQWl0QixLQUFLLFNBQVNBO1FBQ1osT0FBTyxJQUFJLENBQUNqSSxNQUFNLENBQUNrTSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDcm5CLE1BQU0sQ0FBQ29JLE9BQU8sQ0FBQ2xTLE1BQU0sR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUU7SUFDdkU7SUFDQWt5QixPQUFPLFNBQVNBO1FBQ2QsT0FBTyxJQUFJLENBQUNsTixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRTtJQUM3QjtJQUNBbU4sU0FBUyxTQUFTQTtRQUNoQixJQUFJamtCLE1BQU0sSUFBSSxDQUFDcEUsTUFBTTtRQUNyQixJQUFLLElBQUlzb0IsUUFBUXR4QixVQUFVZCxNQUFNLEVBQUVneUIsUUFBUSxJQUFJaHhCLE1BQU1veEIsUUFBUUMsUUFBUSxHQUFHQSxRQUFRRCxPQUFPQyxRQUFTO1lBQzlGTCxLQUFLLENBQUNLLE1BQU0sR0FBR3Z4QixTQUFTLENBQUN1eEIsTUFBTTtRQUNqQztRQUNBbmtCLElBQUkwaUIsZ0JBQWdCLENBQUMsR0FBRyxHQUFHb0I7UUFDM0IsT0FBTzlqQixJQUFJZ0UsT0FBTyxDQUFDbFMsTUFBTTtJQUMzQjtJQUNBc3lCLFNBQVMsU0FBU0E7UUFDaEIsa0VBQWtFO1FBQ2xFLHVEQUF1RDtRQUN2RCxJQUFJeHZCLFlBQVl3VixrQkFBa0IsRUFBRTtZQUNsQzNYLElBQUksSUFBSTtRQUNWO1FBQ0EsSUFBSSxDQUFDa2lCLE9BQU8sQ0FBQyxJQUFJLENBQUNyYSxLQUFLLEdBQUc4cEIsT0FBTztRQUNqQyxPQUFPLElBQUk7SUFDYjtJQUNBQyxNQUFNLFNBQVNBO1FBQ2IsK0RBQStEO1FBQy9ELDhFQUE4RTtRQUM5RSxJQUFJenZCLFlBQVl3VixrQkFBa0IsRUFBRTtZQUNsQzNYLElBQUksSUFBSTtRQUNWO1FBQ0EsSUFBSTZ4QixPQUFPLElBQUksQ0FBQ2hxQixLQUFLO1FBQ3JCZ3FCLEtBQUtELElBQUksQ0FBQ3B4QixLQUFLLENBQUNxeEIsTUFBTTF4QjtRQUN0QixJQUFJLENBQUMraEIsT0FBTyxDQUFDMlA7UUFDYixPQUFPLElBQUk7SUFDYjtJQUNBMUcsUUFBUSxTQUFTQSxPQUFPcm9CLEtBQUs7UUFDM0IsSUFBSXlLLE1BQU0sSUFBSSxDQUFDcEUsTUFBTTtRQUNyQixJQUFJaWIsTUFBTTdXLElBQUlraUIsY0FBYyxDQUFDbGlCLElBQUlnRSxPQUFPLEVBQUUyUCxPQUFPLENBQUNwZTtRQUNsRCxJQUFJc2hCLE1BQU0sQ0FBQyxHQUFHO1lBQ1osSUFBSSxDQUFDQyxNQUFNLENBQUNELEtBQUs7WUFDakIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ0QwTixrQkFBa0IsTUFBTUM7QUFDeEJELGtCQUFrQixVQUFVQztBQUM1QkQsa0JBQWtCLFFBQVFDO0FBQzFCRCxrQkFBa0IsWUFBWUM7QUFDOUJELGtCQUFrQixXQUFXQztBQUM3QkQsa0JBQWtCLFFBQVFDO0FBQzFCRCxrQkFBa0IsZUFBZUM7QUFDakNELGtCQUFrQixTQUFTQztBQUMzQkQsa0JBQWtCLFlBQVlDO0FBQzlCRCxrQkFBa0Isa0JBQWtCQztBQUNwQ0Qsa0JBQWtCLFlBQVlDO0FBQzlCRCxrQkFBa0IsYUFBYUM7QUFDL0JELGtCQUFrQixRQUFRQztBQUMxQixNQUFNO0FBQ05ELGtCQUFrQixTQUFTRTtBQUMzQkYsa0JBQWtCLFVBQVVFO0FBQzVCRixrQkFBa0IsUUFBUUU7QUFDMUJGLGtCQUFrQixhQUFhRTtBQUMvQkYsa0JBQWtCLFlBQVlFO0FBQzlCRixrQkFBa0IsaUJBQWlCRTtBQUNuQ0Ysa0JBQWtCLFdBQVdFO0FBQzdCRixrQkFBa0IsV0FBV0U7QUFDN0JGLGtCQUFrQixPQUFPRTtBQUN6QkYsa0JBQWtCLFFBQVFFO0FBQzFCRixrQkFBa0IsY0FBY0U7QUFDaEMsU0FBUztBQUNURixrQkFBa0IsVUFBVUc7QUFDNUJILGtCQUFrQixlQUFlRztBQUNqQyxTQUFTSCxrQkFBa0JJLFFBQVEsRUFBRUMsV0FBVztJQUM5QyxJQUFJLE9BQU85eEIsTUFBTW9CLFNBQVMsQ0FBQ3l3QixTQUFTLEtBQUssWUFBWTtRQUNuRHBELGVBQWUsQ0FBQ29ELFNBQVMsR0FBR0MsWUFBWUQ7SUFDMUM7QUFDRjtBQUNBLHdDQUF3QztBQUN4QyxTQUFTSCxXQUFXRyxRQUFRO0lBQzFCLE9BQU87UUFDTCxJQUFJM2tCLE1BQU0sSUFBSSxDQUFDcEUsTUFBTTtRQUNyQm9FLElBQUk0aEIsS0FBSyxDQUFDaGxCLGNBQWM7UUFDeEIsSUFBSWlvQixpQkFBaUI3a0IsSUFBSWtpQixjQUFjLENBQUNsaUIsSUFBSWdFLE9BQU87UUFDbkQsT0FBTzZnQixjQUFjLENBQUNGLFNBQVMsQ0FBQzF4QixLQUFLLENBQUM0eEIsZ0JBQWdCanlCO0lBQ3hEO0FBQ0Y7QUFDQSxzREFBc0Q7QUFDdEQsU0FBUzZ4QixZQUFZRSxRQUFRO0lBQzNCLE9BQU8sU0FBVUcsUUFBUSxFQUFFM0YsT0FBTztRQUNoQyxJQUFJakosU0FBUyxJQUFJO1FBQ2pCLElBQUlsVyxNQUFNLElBQUksQ0FBQ3BFLE1BQU07UUFDckJvRSxJQUFJNGhCLEtBQUssQ0FBQ2hsQixjQUFjO1FBQ3hCLElBQUlpb0IsaUJBQWlCN2tCLElBQUlraUIsY0FBYyxDQUFDbGlCLElBQUlnRSxPQUFPO1FBQ25ELE9BQU82Z0IsY0FBYyxDQUFDRixTQUFTLENBQUMsU0FBVUksT0FBTyxFQUFFbHpCLEtBQUs7WUFDdEQsT0FBT2l6QixTQUFTL3VCLElBQUksQ0FBQ29wQixTQUFTNEYsU0FBU2x6QixPQUFPcWtCO1FBQ2hEO0lBQ0Y7QUFDRjtBQUNBLHNEQUFzRDtBQUN0RCxTQUFTd08sZUFBZUMsUUFBUTtJQUM5QixPQUFPO1FBQ0wsSUFBSUssU0FBUyxJQUFJO1FBQ2pCLElBQUlobEIsTUFBTSxJQUFJLENBQUNwRSxNQUFNO1FBQ3JCb0UsSUFBSTRoQixLQUFLLENBQUNobEIsY0FBYztRQUN4QixJQUFJaW9CLGlCQUFpQjdrQixJQUFJa2lCLGNBQWMsQ0FBQ2xpQixJQUFJZ0UsT0FBTztRQUNuRCxzREFBc0Q7UUFDdEQsSUFBSThnQixXQUFXbHlCLFNBQVMsQ0FBQyxFQUFFO1FBQzNCQSxTQUFTLENBQUMsRUFBRSxHQUFHLFNBQVVxeUIsV0FBVyxFQUFFQyxZQUFZLEVBQUVyekIsS0FBSztZQUN2RCxPQUFPaXpCLFNBQVNHLGFBQWFDLGNBQWNyekIsT0FBT216QjtRQUNwRDtRQUNBLE9BQU9ILGNBQWMsQ0FBQ0YsU0FBUyxDQUFDMXhCLEtBQUssQ0FBQzR4QixnQkFBZ0JqeUI7SUFDeEQ7QUFDRjtBQUNBLElBQUl1eUIsa0NBQWtDLFdBQVcsR0FBRXp1QiwwQkFBMEIsaUNBQWlDK3FCO0FBQzlHLFNBQVNwaUIsa0JBQWtCbE4sS0FBSztJQUM5QixPQUFPc0QsU0FBU3RELFVBQVVnekIsZ0NBQWdDaHpCLEtBQUssQ0FBQ3lKLE1BQU07QUFDeEU7QUFFQSxJQUFJd3BCLHNCQUFzQixDQUFDO0FBQzNCLElBQUlDLE1BQU07QUFDVixJQUFJQyxTQUFTO0FBQ2IsK0ZBQStGO0FBQy9GLGtEQUFrRDtBQUNsRCxJQUFJemQsZ0JBQWdCLFdBQVcsR0FBRTtJQUMvQixTQUFTQSxjQUFjMGQsV0FBVyxFQUFFMUQsU0FBUyxFQUFFL2xCLEtBQUs7UUFDbEQsSUFBSTJQLFFBQVEsSUFBSTtRQUNoQixJQUFJb1csY0FBYyxLQUFLLEdBQUc7WUFDeEJBLFlBQVlwakI7UUFDZDtRQUNBLElBQUkzQyxVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUXRKLEtBQXFDLEdBQUcsbUJBQW1Cc0MsY0FBYyxDQUFlO1FBQ2xHO1FBQ0EsSUFBSSxDQUFDK3NCLFNBQVMsR0FBRyxLQUFLO1FBQ3RCLElBQUksQ0FBQy9sQixLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNGLE1BQU0sR0FBR3dwQjtRQUNkLElBQUksQ0FBQ0ksS0FBSyxHQUFHLEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsS0FBSztRQUNwQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDQyxTQUFTLEdBQUcsS0FBSztRQUN0QixJQUFJLENBQUMvWixhQUFhLEdBQUcsS0FBSztRQUMxQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEtBQUs7UUFDN0IsSUFBSSxDQUFDRSxRQUFRLEdBQUcsS0FBSztRQUNyQixJQUFJLENBQUMrVixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQy9sQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMUcsV0FBV3dwQixNQUFNO1lBQ3BCbnNCLElBQUk7UUFDTjtRQUNBd1YsZUFBZTtZQUNid0QsTUFBTWlhLFNBQVMsR0FBR2xvQixXQUFXaEwsS0FBcUMsR0FBR2laLE1BQU0zUCxLQUFLLEdBQUcsWUFBWSxDQUFzQjtZQUNySDJQLE1BQU0rWixLQUFLLEdBQUcsSUFBSTVHO1lBQ2xCblQsTUFBTWdhLE9BQU8sR0FBRyxJQUFJN0c7WUFDcEIsSUFBSTJHLGFBQWE7Z0JBQ2Y5WixNQUFNa2EsS0FBSyxDQUFDSjtZQUNkO1FBQ0Y7SUFDRjtJQUNBLElBQUkvb0IsU0FBU3FMLGNBQWMzVCxTQUFTO0lBQ3BDc0ksT0FBT3NoQixJQUFJLEdBQUcsU0FBU0EsS0FBS25zQixHQUFHO1FBQzdCLE9BQU8sSUFBSSxDQUFDNnpCLEtBQUssQ0FBQ3ZnQixHQUFHLENBQUN0VDtJQUN4QjtJQUNBNkssT0FBT3lJLEdBQUcsR0FBRyxTQUFTQSxJQUFJdFQsR0FBRztRQUMzQixJQUFJdWtCLFNBQVMsSUFBSTtRQUNqQixJQUFJLENBQUN0aEIsWUFBWXdWLGtCQUFrQixFQUFFO1lBQ25DLE9BQU8sSUFBSSxDQUFDMFQsSUFBSSxDQUFDbnNCO1FBQ25CO1FBQ0EsSUFBSWkwQixRQUFRLElBQUksQ0FBQ0gsT0FBTyxDQUFDdm9CLEdBQUcsQ0FBQ3ZMO1FBQzdCLElBQUksQ0FBQ2kwQixPQUFPO1lBQ1YsSUFBSUMsV0FBV0QsUUFBUSxJQUFJN2dCLGdCQUFnQixJQUFJLENBQUMrWSxJQUFJLENBQUNuc0IsTUFBTThOLG1CQUFtQmpOLEtBQXFDLEdBQUcsSUFBSSxDQUFDc0osS0FBSyxHQUFHLE1BQU0vRCxhQUFhcEcsT0FBTyxNQUFNLENBQW9CLEVBQUU7WUFDekwsSUFBSSxDQUFDOHpCLE9BQU8sQ0FBQ3JvQixHQUFHLENBQUN6TCxLQUFLazBCO1lBQ3RCaG9CLG1CQUFtQmdvQixVQUFVO2dCQUMzQixPQUFPM1AsT0FBT3VQLE9BQU8sQ0FBQyxTQUFTLENBQUM5ekI7WUFDbEM7UUFDRjtRQUNBLE9BQU9pMEIsTUFBTTFvQixHQUFHO0lBQ2xCO0lBQ0FWLE9BQU9ZLEdBQUcsR0FBRyxTQUFTQSxJQUFJekwsR0FBRyxFQUFFNEQsS0FBSztRQUNsQyxJQUFJdXdCLFNBQVMsSUFBSSxDQUFDaEksSUFBSSxDQUFDbnNCO1FBQ3ZCLElBQUk2YSxnQkFBZ0IsSUFBSSxHQUFHO1lBQ3pCLElBQUlDLFNBQVNDLGdCQUFnQixJQUFJLEVBQUU7Z0JBQ2pDekMsTUFBTTZiLFNBQVN6WixTQUFTZ1o7Z0JBQ3hCanZCLFFBQVEsSUFBSTtnQkFDWnVDLFVBQVVwRDtnQkFDVnRELE1BQU1OO1lBQ1I7WUFDQSxJQUFJLENBQUM4YSxRQUFRO2dCQUNYLE9BQU8sSUFBSTtZQUNiO1lBQ0FsWCxRQUFRa1gsT0FBTzlULFFBQVE7UUFDekI7UUFDQSxJQUFJbXRCLFFBQVE7WUFDVixJQUFJLENBQUNDLFlBQVksQ0FBQ3AwQixLQUFLNEQ7UUFDekIsT0FBTztZQUNMLElBQUksQ0FBQ3l3QixTQUFTLENBQUNyMEIsS0FBSzREO1FBQ3RCO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQWlILE1BQU0sQ0FBQyxTQUFTLEdBQUcsU0FBU3lwQixRQUFRdDBCLEdBQUc7UUFDckMsSUFBSXF6QixTQUFTLElBQUk7UUFDakJ6WSxvQ0FBb0MsSUFBSSxDQUFDbVosU0FBUztRQUNsRCxJQUFJbFosZ0JBQWdCLElBQUksR0FBRztZQUN6QixJQUFJQyxTQUFTQyxnQkFBZ0IsSUFBSSxFQUFFO2dCQUNqQ3pDLE1BQU1xYjtnQkFDTmx2QixRQUFRLElBQUk7Z0JBQ1puRSxNQUFNTjtZQUNSO1lBQ0EsSUFBSSxDQUFDOGEsUUFBUTtnQkFDWCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDcVIsSUFBSSxDQUFDbnNCLE1BQU07WUFDbEIsSUFBSTZaLFlBQVk3QjtZQUNoQixJQUFJK0wsU0FBUy9JLGFBQWEsSUFBSTtZQUM5QixJQUFJdVosVUFBVXhRLFVBQVVsSyxZQUFZO2dCQUNsQ1EsZ0JBQWdCO2dCQUNoQkMsaUJBQWlCLElBQUksQ0FBQ25RLEtBQUs7Z0JBQzNCbU8sTUFBTXFiO2dCQUNObHZCLFFBQVEsSUFBSTtnQkFDWnVKLFVBQVUsSUFBSSxDQUFDNmxCLEtBQUssQ0FBQ3RvQixHQUFHLENBQUN2TCxLQUFLa2EsTUFBTTtnQkFDcEM1WixNQUFNTjtZQUNSLElBQUk7WUFDSixJQUFJYSxLQUFxQyxJQUFJZ1osV0FBVztnQkFDdER4QixlQUFla2M7WUFDakIsRUFBRSxnQkFBZ0I7WUFDbEJoSCxZQUFZO2dCQUNWLElBQUlpSDtnQkFDSm5CLE9BQU9VLFNBQVMsQ0FBQzVvQixhQUFhO2dCQUM3QnFwQixDQUFBQSxxQkFBcUJuQixPQUFPUyxPQUFPLENBQUN2b0IsR0FBRyxDQUFDdkwsSUFBRyxLQUFNLFFBQVF3MEIsbUJBQW1CN1osWUFBWSxDQUFDO2dCQUMxRixJQUFJMU4sYUFBYW9tQixPQUFPUSxLQUFLLENBQUN0b0IsR0FBRyxDQUFDdkw7Z0JBQ2xDaU4sV0FBVzBOLFlBQVksQ0FBQ3hOO2dCQUN4QmttQixPQUFPUSxLQUFLLENBQUMsU0FBUyxDQUFDN3pCO1lBQ3pCO1lBQ0EsSUFBSStqQixRQUFRO2dCQUNWOUksZ0JBQWdCLElBQUksRUFBRXNaO1lBQ3hCO1lBQ0EsSUFBSTF6QixLQUFxQyxJQUFJZ1osV0FBVztnQkFDdERMO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQTNPLE9BQU91cEIsWUFBWSxHQUFHLFNBQVNBLGFBQWFwMEIsR0FBRyxFQUFFZ0gsUUFBUTtRQUN2RCxJQUFJaUcsYUFBYSxJQUFJLENBQUM0bUIsS0FBSyxDQUFDdG9CLEdBQUcsQ0FBQ3ZMO1FBQ2hDZ0gsV0FBV2lHLFdBQVd1TixnQkFBZ0IsQ0FBQ3hUO1FBQ3ZDLElBQUlBLGFBQWEvRCxZQUFZd1gsU0FBUyxFQUFFO1lBQ3RDLElBQUlaLFlBQVk3QjtZQUNoQixJQUFJK0wsU0FBUy9JLGFBQWEsSUFBSTtZQUM5QixJQUFJRixTQUFTaUosVUFBVWxLLFlBQVk7Z0JBQ2pDUSxnQkFBZ0I7Z0JBQ2hCQyxpQkFBaUIsSUFBSSxDQUFDblEsS0FBSztnQkFDM0JtTyxNQUFNb0M7Z0JBQ05qVyxRQUFRLElBQUk7Z0JBQ1p1SixVQUFVZixXQUFXaU4sTUFBTTtnQkFDM0I1WixNQUFNTjtnQkFDTmdILFVBQVVBO1lBQ1osSUFBSTtZQUNKLElBQUluRyxLQUFxQyxJQUFJZ1osV0FBVztnQkFDdER4QixlQUFleUM7WUFDakIsRUFBRSxnQkFBZ0I7WUFDbEI3TixXQUFXME4sWUFBWSxDQUFDM1Q7WUFDeEIsSUFBSStjLFFBQVE7Z0JBQ1Y5SSxnQkFBZ0IsSUFBSSxFQUFFSDtZQUN4QjtZQUNBLElBQUlqYSxLQUFxQyxJQUFJZ1osV0FBVztnQkFDdERMO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EzTyxPQUFPd3BCLFNBQVMsR0FBRyxTQUFTQSxVQUFVcjBCLEdBQUcsRUFBRWdILFFBQVE7UUFDakQsSUFBSXl0QixTQUFTLElBQUk7UUFDakI3WixvQ0FBb0MsSUFBSSxDQUFDbVosU0FBUztRQUNsRHhHLFlBQVk7WUFDVixJQUFJbUg7WUFDSixJQUFJem5CLGFBQWEsSUFBSW1HLGdCQUFnQnBNLFVBQVV5dEIsT0FBT3ZFLFNBQVMsRUFBRXJ2QixLQUFxQyxHQUFHNHpCLE9BQU90cUIsS0FBSyxHQUFHLE1BQU0vRCxhQUFhcEcsT0FBTyxDQUFtQixFQUFFO1lBQ3ZLeTBCLE9BQU9aLEtBQUssQ0FBQ3BvQixHQUFHLENBQUN6TCxLQUFLaU47WUFDdEJqRyxXQUFXaUcsV0FBV2lOLE1BQU0sRUFBRSxnQ0FBZ0M7WUFDN0R3YSxDQUFBQSxxQkFBcUJELE9BQU9YLE9BQU8sQ0FBQ3ZvQixHQUFHLENBQUN2TCxJQUFHLEtBQU0sUUFBUTAwQixtQkFBbUIvWixZQUFZLENBQUM7WUFDMUY4WixPQUFPVixTQUFTLENBQUM1b0IsYUFBYTtRQUNoQztRQUNBLElBQUkwTyxZQUFZN0I7UUFDaEIsSUFBSStMLFNBQVMvSSxhQUFhLElBQUk7UUFDOUIsSUFBSUYsU0FBU2lKLFVBQVVsSyxZQUFZO1lBQ2pDUSxnQkFBZ0I7WUFDaEJDLGlCQUFpQixJQUFJLENBQUNuUSxLQUFLO1lBQzNCbU8sTUFBTW9iO1lBQ05qdkIsUUFBUSxJQUFJO1lBQ1puRSxNQUFNTjtZQUNOZ0gsVUFBVUE7UUFDWixJQUFJO1FBQ0osSUFBSW5HLEtBQXFDLElBQUlnWixXQUFXO1lBQ3REeEIsZUFBZXlDO1FBQ2pCLEVBQUUsZ0JBQWdCO1FBQ2xCLElBQUlpSixRQUFRO1lBQ1Y5SSxnQkFBZ0IsSUFBSSxFQUFFSDtRQUN4QjtRQUNBLElBQUlqYSxLQUFxQyxJQUFJZ1osV0FBVztZQUN0REw7UUFDRjtJQUNGO0lBQ0EzTyxPQUFPVSxHQUFHLEdBQUcsU0FBU0EsSUFBSXZMLEdBQUc7UUFDM0IsSUFBSSxJQUFJLENBQUNzVCxHQUFHLENBQUN0VCxNQUFNO1lBQ2pCLE9BQU8sSUFBSSxDQUFDc3dCLGFBQWEsQ0FBQyxJQUFJLENBQUN1RCxLQUFLLENBQUN0b0IsR0FBRyxDQUFDdkwsS0FBS3VMLEdBQUc7UUFDbkQ7UUFDQSxPQUFPLElBQUksQ0FBQytrQixhQUFhLENBQUNuakI7SUFDNUI7SUFDQXRDLE9BQU95bEIsYUFBYSxHQUFHLFNBQVNBLGNBQWMxc0IsS0FBSztRQUNqRCxJQUFJLElBQUksQ0FBQ3VXLFFBQVEsS0FBS2hOLFdBQVc7WUFDL0IsT0FBTyxJQUFJLENBQUNnTixRQUFRLENBQUN2VztRQUN2QjtRQUNBLE9BQU9BO0lBQ1Q7SUFDQWlILE9BQU9sRixJQUFJLEdBQUcsU0FBU0E7UUFDckIsSUFBSSxDQUFDb3VCLFNBQVMsQ0FBQzlvQixjQUFjO1FBQzdCLE9BQU8sSUFBSSxDQUFDNG9CLEtBQUssQ0FBQ2x1QixJQUFJO0lBQ3hCO0lBQ0FrRixPQUFPK2dCLE1BQU0sR0FBRyxTQUFTQTtRQUN2QixJQUFJNXBCLFFBQU8sSUFBSTtRQUNmLElBQUkyRCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixPQUFPZ3ZCLG1CQUFtQjtZQUN4Qi9zQixNQUFNLFNBQVNBO2dCQUNiLElBQUlndEIsYUFBYWp2QixLQUFLaUMsSUFBSSxJQUN4QkksT0FBTzRzQixXQUFXNXNCLElBQUksRUFDdEJwRSxRQUFRZ3hCLFdBQVdoeEIsS0FBSztnQkFDMUIsT0FBTztvQkFDTG9FLE1BQU1BO29CQUNOcEUsT0FBT29FLE9BQU9tRixZQUFZbkwsTUFBS3VKLEdBQUcsQ0FBQzNIO2dCQUNyQztZQUNGO1FBQ0Y7SUFDRjtJQUNBaUgsT0FBT2doQixPQUFPLEdBQUcsU0FBU0E7UUFDeEIsSUFBSTdwQixRQUFPLElBQUk7UUFDZixJQUFJMkQsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDcEIsT0FBT2d2QixtQkFBbUI7WUFDeEIvc0IsTUFBTSxTQUFTQTtnQkFDYixJQUFJaXRCLGNBQWNsdkIsS0FBS2lDLElBQUksSUFDekJJLE9BQU82c0IsWUFBWTdzQixJQUFJLEVBQ3ZCcEUsUUFBUWl4QixZQUFZanhCLEtBQUs7Z0JBQzNCLE9BQU87b0JBQ0xvRSxNQUFNQTtvQkFDTnBFLE9BQU9vRSxPQUFPbUYsWUFBWTt3QkFBQ3ZKO3dCQUFPNUIsTUFBS3VKLEdBQUcsQ0FBQzNIO3FCQUFPO2dCQUNwRDtZQUNGO1FBQ0Y7SUFDRjtJQUNBaUgsTUFBTSxDQUFDbkQsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDeEIsT0FBTyxJQUFJLENBQUNra0IsT0FBTztJQUNyQjtJQUNBaGhCLE9BQU9sRSxPQUFPLEdBQUcsU0FBU0EsUUFBUXdzQixRQUFRLEVBQUUzRixPQUFPO1FBQ2pELElBQUssSUFBSXNILFlBQVlydEIsZ0NBQWdDLElBQUksR0FBR3N0QixPQUFPLENBQUMsQ0FBQ0EsUUFBUUQsV0FBVSxFQUFHOXNCLElBQUksRUFBRztZQUMvRixJQUFJZ3RCLGNBQWNELE1BQU1ueEIsS0FBSyxFQUMzQjVELE1BQU1nMUIsV0FBVyxDQUFDLEVBQUUsRUFDcEJweEIsUUFBUW94QixXQUFXLENBQUMsRUFBRTtZQUN4QjdCLFNBQVMvdUIsSUFBSSxDQUFDb3BCLFNBQVM1cEIsT0FBTzVELEtBQUssSUFBSTtRQUN6QztJQUNGLEVBQ0EseURBQXlEO0lBQ3pENkssT0FBT21wQixLQUFLLEdBQUcsU0FBU0EsTUFBTTV6QixLQUFLO1FBQ2pDLElBQUk2MEIsU0FBUyxJQUFJO1FBQ2pCLElBQUl0bkIsZ0JBQWdCdk4sUUFBUTtZQUMxQkEsUUFBUSxJQUFJNnNCLElBQUk3c0I7UUFDbEI7UUFDQW10QixZQUFZO1lBQ1YsSUFBSXhwQixjQUFjM0QsUUFBUTtnQkFDeEJzRixtQkFBbUJ0RixPQUFPdUcsT0FBTyxDQUFDLFNBQVUzRyxHQUFHO29CQUM3QyxPQUFPaTFCLE9BQU94cEIsR0FBRyxDQUFDekwsS0FBS0ksS0FBSyxDQUFDSixJQUFJO2dCQUNuQztZQUNGLE9BQU8sSUFBSW1CLE1BQU0yRyxPQUFPLENBQUMxSCxRQUFRO2dCQUMvQkEsTUFBTXVHLE9BQU8sQ0FBQyxTQUFVOEosSUFBSTtvQkFDMUIsSUFBSXpRLE1BQU15USxJQUFJLENBQUMsRUFBRSxFQUNmN00sUUFBUTZNLElBQUksQ0FBQyxFQUFFO29CQUNqQixPQUFPd2tCLE9BQU94cEIsR0FBRyxDQUFDekwsS0FBSzREO2dCQUN6QjtZQUNGLE9BQU8sSUFBSXNCLFNBQVM5RSxRQUFRO2dCQUMxQixJQUFJLENBQUMrRSxjQUFjL0UsUUFBUTtvQkFDekJVLElBQUksSUFBSVY7Z0JBQ1Y7Z0JBQ0FBLE1BQU11RyxPQUFPLENBQUMsU0FBVS9DLEtBQUssRUFBRTVELEdBQUc7b0JBQ2hDLE9BQU9pMUIsT0FBT3hwQixHQUFHLENBQUN6TCxLQUFLNEQ7Z0JBQ3pCO1lBQ0YsT0FBTyxJQUFJeEQsVUFBVSxRQUFRQSxVQUFVK00sV0FBVztnQkFDaERyTSxJQUFJLElBQUlWO1lBQ1Y7UUFDRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0F5SyxPQUFPbW5CLEtBQUssR0FBRyxTQUFTQTtRQUN0QixJQUFJa0QsU0FBUyxJQUFJO1FBQ2pCM0gsWUFBWTtZQUNWMU0sVUFBVTtnQkFDUixJQUFLLElBQUlzVSxhQUFhMXRCLGdDQUFnQ3l0QixPQUFPdnZCLElBQUksS0FBS3l2QixRQUFRLENBQUMsQ0FBQ0EsU0FBU0QsWUFBVyxFQUFHbnRCLElBQUksRUFBRztvQkFDNUcsSUFBSWhJLE1BQU1vMUIsT0FBT3h4QixLQUFLO29CQUN0QnN4QixNQUFNLENBQUMsU0FBUyxDQUFDbDFCO2dCQUNuQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBNkssT0FBT21ZLE9BQU8sR0FBRyxTQUFTQSxRQUFRNEksTUFBTTtRQUN0QyxJQUFJeUosU0FBUyxJQUFJO1FBQ2pCLCtCQUErQjtRQUMvQix3Q0FBd0M7UUFDeEMsNEVBQTRFO1FBQzVFLCtHQUErRztRQUMvRywrRkFBK0Y7UUFDL0YsaUZBQWlGO1FBQ2pGOUgsWUFBWTtZQUNWLGdEQUFnRDtZQUNoRCxJQUFJK0gsaUJBQWlCQyxhQUFhM0o7WUFDbEMsSUFBSTRKLGNBQWMsSUFBSXZJO1lBQ3RCLHdCQUF3QjtZQUN4QixJQUFJd0ksMEJBQTBCO1lBQzlCLGtEQUFrRDtZQUNsRCxrREFBa0Q7WUFDbEQsK0NBQStDO1lBQy9DLElBQUssSUFBSUMsYUFBYWp1QixnQ0FBZ0M0dEIsT0FBT3hCLEtBQUssQ0FBQ2x1QixJQUFJLEtBQUtnd0IsUUFBUSxDQUFDLENBQUNBLFNBQVNELFlBQVcsRUFBRzF0QixJQUFJLEVBQUc7Z0JBQ2xILElBQUloSSxNQUFNMjFCLE9BQU8veEIsS0FBSztnQkFDdEIsdUNBQXVDO2dCQUN2Qyx3Q0FBd0M7Z0JBQ3hDLElBQUksQ0FBQzB4QixlQUFlaGlCLEdBQUcsQ0FBQ3RULE1BQU07b0JBQzVCLElBQUk0MUIsVUFBVVAsTUFBTSxDQUFDLFNBQVMsQ0FBQ3IxQjtvQkFDL0IsdUJBQXVCO29CQUN2QixJQUFJNDFCLFNBQVM7d0JBQ1gsK0NBQStDO3dCQUMvQ0gsMEJBQTBCO29CQUM1QixPQUFPO3dCQUNMLGtDQUFrQzt3QkFDbEMsSUFBSTd4QixRQUFReXhCLE9BQU94QixLQUFLLENBQUN0b0IsR0FBRyxDQUFDdkw7d0JBQzdCdzFCLFlBQVkvcEIsR0FBRyxDQUFDekwsS0FBSzREO29CQUN2QjtnQkFDRjtZQUNGO1lBQ0EsZ0JBQWdCO1lBQ2hCLElBQUssSUFBSWl5QixhQUFhcHVCLGdDQUFnQzZ0QixlQUFlekosT0FBTyxLQUFLaUssUUFBUSxDQUFDLENBQUNBLFNBQVNELFlBQVcsRUFBRzd0QixJQUFJLEVBQUc7Z0JBQ3ZILElBQUkrdEIsZUFBZUQsT0FBT2x5QixLQUFLLEVBQzdCeEMsT0FBTzIwQixZQUFZLENBQUMsRUFBRSxFQUN0QkMsU0FBU0QsWUFBWSxDQUFDLEVBQUU7Z0JBQzFCLGtEQUFrRDtnQkFDbEQsSUFBSUUsYUFBYVosT0FBT3hCLEtBQUssQ0FBQ3ZnQixHQUFHLENBQUNsUztnQkFDbEMsc0JBQXNCO2dCQUN0QmkwQixPQUFPNXBCLEdBQUcsQ0FBQ3JLLE1BQU00MEI7Z0JBQ2pCLHNEQUFzRDtnQkFDdEQsSUFBSVgsT0FBT3hCLEtBQUssQ0FBQ3ZnQixHQUFHLENBQUNsUyxPQUFPO29CQUMxQixzREFBc0Q7b0JBQ3RELCtDQUErQztvQkFDL0MsMkRBQTJEO29CQUMzRCxJQUFJODBCLFVBQVViLE9BQU94QixLQUFLLENBQUN0b0IsR0FBRyxDQUFDbks7b0JBQy9CbzBCLFlBQVkvcEIsR0FBRyxDQUFDckssTUFBTTgwQjtvQkFDdEIsdUJBQXVCO29CQUN2QixJQUFJLENBQUNELFlBQVk7d0JBQ2YsK0NBQStDO3dCQUMvQ1IsMEJBQTBCO29CQUM1QjtnQkFDRjtZQUNGO1lBQ0Esc0NBQXNDO1lBQ3RDLElBQUksQ0FBQ0EseUJBQXlCO2dCQUM1QixJQUFJSixPQUFPeEIsS0FBSyxDQUFDMVcsSUFBSSxLQUFLcVksWUFBWXJZLElBQUksRUFBRTtvQkFDMUMsZ0RBQWdEO29CQUNoRGtZLE9BQU90QixTQUFTLENBQUM1b0IsYUFBYTtnQkFDaEMsT0FBTztvQkFDTCxJQUFJZ3JCLFFBQVFkLE9BQU94QixLQUFLLENBQUNsdUIsSUFBSTtvQkFDN0IsSUFBSXl3QixRQUFRWixZQUFZN3ZCLElBQUk7b0JBQzVCLElBQUkwd0IsUUFBUUYsTUFBTXZ1QixJQUFJO29CQUN0QixJQUFJMHVCLFFBQVFGLE1BQU14dUIsSUFBSTtvQkFDdEIsTUFBTyxDQUFDeXVCLE1BQU1ydUIsSUFBSSxDQUFFO3dCQUNsQixJQUFJcXVCLE1BQU16eUIsS0FBSyxLQUFLMHlCLE1BQU0xeUIsS0FBSyxFQUFFOzRCQUMvQnl4QixPQUFPdEIsU0FBUyxDQUFDNW9CLGFBQWE7NEJBQzlCO3dCQUNGO3dCQUNBa3JCLFFBQVFGLE1BQU12dUIsSUFBSTt3QkFDbEIwdUIsUUFBUUYsTUFBTXh1QixJQUFJO29CQUNwQjtnQkFDRjtZQUNGO1lBQ0EsNEJBQTRCO1lBQzVCeXRCLE9BQU94QixLQUFLLEdBQUcyQjtRQUNqQjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EzcUIsT0FBTzVLLFFBQVEsR0FBRyxTQUFTQTtRQUN6QixPQUFPO0lBQ1Q7SUFDQTRLLE9BQU80USxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsT0FBT3RhLE1BQU15SCxJQUFJLENBQUMsSUFBSTtJQUN4QjtJQUNBOzs7O0dBSUMsR0FDRGlDLE9BQU93USxRQUFRLEdBQUcsU0FBU0EsU0FBU3RRLFFBQVEsRUFBRXVRLGVBQWU7UUFDM0QsSUFBSXphLEtBQXFDLElBQUl5YSxvQkFBb0IsTUFBTTtZQUNyRXhhLElBQUk7UUFDTjtRQUNBLE9BQU95YSxpQkFBaUIsSUFBSSxFQUFFeFE7SUFDaEM7SUFDQUYsT0FBT3FRLFVBQVUsR0FBRyxTQUFTQSxXQUFXQyxPQUFPO1FBQzdDLE9BQU9DLG9CQUFvQixJQUFJLEVBQUVEO0lBQ25DO0lBQ0EsT0FBTzNULGFBQWEwTyxlQUFlO1FBQUM7WUFDbENsVyxLQUFLO1lBQ0x1TCxLQUFLLFNBQVNBO2dCQUNaLElBQUksQ0FBQ3dvQixTQUFTLENBQUM5b0IsY0FBYztnQkFDN0IsT0FBTyxJQUFJLENBQUM0b0IsS0FBSyxDQUFDMVcsSUFBSTtZQUN4QjtRQUNGO1FBQUc7WUFDRG5kLEtBQUswSCxPQUFPNnVCLFdBQVc7WUFDdkJockIsS0FBSyxTQUFTQTtnQkFDWixPQUFPO1lBQ1Q7UUFDRjtLQUFFO0FBQ0o7QUFDQSwyQkFBMkI7QUFDM0IsSUFBSW9DLGtCQUFrQixXQUFXLEdBQUU1SSwwQkFBMEIsaUJBQWlCbVI7QUFDOUUsU0FBU3llLG1CQUFtQmh0QixRQUFRO0lBQ2xDQSxRQUFRLENBQUNELE9BQU82dUIsV0FBVyxDQUFDLEdBQUc7SUFDL0IsT0FBT0MsYUFBYTd1QjtBQUN0QjtBQUNBLFNBQVM0dEIsYUFBYWgxQixhQUFhO0lBQ2pDLElBQUkyRSxTQUFTM0Usa0JBQWtCb04sZ0JBQWdCcE4sZ0JBQWdCO1FBQzdELE9BQU9BO0lBQ1QsT0FBTyxJQUFJWSxNQUFNMkcsT0FBTyxDQUFDdkgsZ0JBQWdCO1FBQ3ZDLE9BQU8sSUFBSTBzQixJQUFJMXNCO0lBQ2pCLE9BQU8sSUFBSXdELGNBQWN4RCxnQkFBZ0I7UUFDdkMsSUFBSWlCLE1BQU0sSUFBSXlyQjtRQUNkLElBQUssSUFBSWp0QixPQUFPTyxjQUFlO1lBQzdCaUIsSUFBSWlLLEdBQUcsQ0FBQ3pMLEtBQUtPLGFBQWEsQ0FBQ1AsSUFBSTtRQUNqQztRQUNBLE9BQU93QjtJQUNULE9BQU87UUFDTCxPQUFPVixJQUFJLElBQUlQO0lBQ2pCO0FBQ0Y7QUFFQSxJQUFJazJCLHNCQUFzQixDQUFDO0FBQzNCLElBQUl0Z0IsZ0JBQWdCLFdBQVcsR0FBRTtJQUMvQixTQUFTQSxjQUFjeWQsV0FBVyxFQUFFN2dCLFFBQVEsRUFBRTVJLEtBQUs7UUFDakQsSUFBSTJQLFFBQVEsSUFBSTtRQUNoQixJQUFJL0csYUFBYSxLQUFLLEdBQUc7WUFDdkJBLFdBQVdqRztRQUNiO1FBQ0EsSUFBSTNDLFVBQVUsS0FBSyxHQUFHO1lBQ3BCQSxRQUFRdEosS0FBcUMsR0FBRyxtQkFBbUJzQyxjQUFjLENBQWU7UUFDbEc7UUFDQSxJQUFJLENBQUNnSCxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNGLE1BQU0sR0FBR3dzQjtRQUNkLElBQUksQ0FBQzVDLEtBQUssR0FBRyxJQUFJdnBCO1FBQ2pCLElBQUksQ0FBQzJsQixLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNoVyxnQkFBZ0IsR0FBRyxLQUFLO1FBQzdCLElBQUksQ0FBQ0QsYUFBYSxHQUFHLEtBQUs7UUFDMUIsSUFBSSxDQUFDRyxRQUFRLEdBQUcsS0FBSztRQUNyQixJQUFJLENBQUMrVixTQUFTLEdBQUcsS0FBSztRQUN0QixJQUFJLENBQUMvbEIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzFHLFdBQVc2RyxNQUFNO1lBQ3BCeEosSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDb3ZCLFNBQVMsR0FBRyxTQUFVRSxJQUFJLEVBQUVDLElBQUk7WUFDbkMsT0FBT3RkLFNBQVNxZCxNQUFNQyxNQUFNbG1CO1FBQzlCO1FBQ0FtTSxlQUFlO1lBQ2J3RCxNQUFNbVcsS0FBSyxHQUFHcGtCLFdBQVdpTyxNQUFNM1AsS0FBSztZQUNwQyxJQUFJeXBCLGFBQWE7Z0JBQ2Y5WixNQUFNa0osT0FBTyxDQUFDNFE7WUFDaEI7UUFDRjtJQUNGO0lBQ0EsSUFBSS9vQixTQUFTc0wsY0FBYzVULFNBQVM7SUFDcENzSSxPQUFPeWxCLGFBQWEsR0FBRyxTQUFTQSxjQUFjMXNCLEtBQUs7UUFDakQsSUFBSSxJQUFJLENBQUN1VyxRQUFRLEtBQUtoTixXQUFXO1lBQy9CLE9BQU8sSUFBSSxDQUFDZ04sUUFBUSxDQUFDdlc7UUFDdkI7UUFDQSxPQUFPQTtJQUNUO0lBQ0FpSCxPQUFPbW5CLEtBQUssR0FBRyxTQUFTQTtRQUN0QixJQUFJek4sU0FBUyxJQUFJO1FBQ2pCZ0osWUFBWTtZQUNWMU0sVUFBVTtnQkFDUixJQUFLLElBQUlpVSxZQUFZcnRCLGdDQUFnQzhjLE9BQU9zUCxLQUFLLENBQUNqSSxNQUFNLEtBQUttSixPQUFPLENBQUMsQ0FBQ0EsUUFBUUQsV0FBVSxFQUFHOXNCLElBQUksRUFBRztvQkFDaEgsSUFBSXBFLFFBQVFteEIsTUFBTW54QixLQUFLO29CQUN2QjJnQixNQUFNLENBQUMsU0FBUyxDQUFDM2dCO2dCQUNuQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBaUgsT0FBT2xFLE9BQU8sR0FBRyxTQUFTQSxRQUFRK3ZCLFVBQVUsRUFBRWxKLE9BQU87UUFDbkQsSUFBSyxJQUFJMkgsYUFBYTF0QixnQ0FBZ0MsSUFBSSxHQUFHMnRCLFFBQVEsQ0FBQyxDQUFDQSxTQUFTRCxZQUFXLEVBQUdudEIsSUFBSSxFQUFHO1lBQ25HLElBQUlwRSxRQUFRd3hCLE9BQU94eEIsS0FBSztZQUN4Qjh5QixXQUFXdHlCLElBQUksQ0FBQ29wQixTQUFTNXBCLE9BQU9BLE9BQU8sSUFBSTtRQUM3QztJQUNGO0lBQ0FpSCxPQUFPd0ksR0FBRyxHQUFHLFNBQVNBLElBQUl6UCxLQUFLO1FBQzdCLElBQUl5dkIsU0FBUyxJQUFJO1FBQ2pCelksb0NBQW9DLElBQUksQ0FBQ3FWLEtBQUs7UUFDOUMsSUFBSXBWLGdCQUFnQixJQUFJLEdBQUc7WUFDekIsSUFBSUMsU0FBU0MsZ0JBQWdCLElBQUksRUFBRTtnQkFDakN6QyxNQUFNb2I7Z0JBQ05qdkIsUUFBUSxJQUFJO2dCQUNadUMsVUFBVXBEO1lBQ1o7WUFDQSxJQUFJLENBQUNrWCxRQUFRO2dCQUNYLE9BQU8sSUFBSTtZQUNiO1lBQ0EsK0RBQStEO1lBQy9EbFgsUUFBUWtYLE9BQU85VCxRQUFRO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3NNLEdBQUcsQ0FBQzFQLFFBQVE7WUFDcEIycEIsWUFBWTtnQkFDVjhGLE9BQU9RLEtBQUssQ0FBQ3hnQixHQUFHLENBQUNnZ0IsT0FBT25ELFNBQVMsQ0FBQ3RzQixPQUFPdUo7Z0JBQ3pDa21CLE9BQU9wRCxLQUFLLENBQUM5a0IsYUFBYTtZQUM1QjtZQUNBLElBQUkwTyxZQUFZaFosS0FBcUMsSUFBSW1YO1lBQ3pELElBQUkrTCxTQUFTL0ksYUFBYSxJQUFJO1lBQzlCLElBQUl1WixVQUFVeFEsVUFBVWxLLFlBQVk7Z0JBQ2xDUSxnQkFBZ0I7Z0JBQ2hCQyxpQkFBaUIsSUFBSSxDQUFDblEsS0FBSztnQkFDM0JtTyxNQUFNb2I7Z0JBQ05qdkIsUUFBUSxJQUFJO2dCQUNadUMsVUFBVXBEO1lBQ1osSUFBSTtZQUNKLElBQUlpVyxhQUFhaFosa0JBQXlCLGNBQWM7Z0JBQ3REd1gsZUFBZWtjO1lBQ2pCO1lBQ0EsSUFBSXhRLFFBQVE7Z0JBQ1Y5SSxnQkFBZ0IsSUFBSSxFQUFFc1o7WUFDeEI7WUFDQSxJQUFJMWEsYUFBYWhaLGtCQUF5QixjQUFjO2dCQUN0RDJZO1lBQ0Y7UUFDRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EzTyxNQUFNLENBQUMsU0FBUyxHQUFHLFNBQVN5cEIsUUFBUTF3QixLQUFLO1FBQ3ZDLElBQUk2d0IsU0FBUyxJQUFJO1FBQ2pCLElBQUk1WixnQkFBZ0IsSUFBSSxHQUFHO1lBQ3pCLElBQUlDLFNBQVNDLGdCQUFnQixJQUFJLEVBQUU7Z0JBQ2pDekMsTUFBTXFiO2dCQUNObHZCLFFBQVEsSUFBSTtnQkFDWnVKLFVBQVVwSztZQUNaO1lBQ0EsSUFBSSxDQUFDa1gsUUFBUTtnQkFDWCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDeEgsR0FBRyxDQUFDMVAsUUFBUTtZQUNuQixJQUFJaVcsWUFBWWhaLEtBQXFDLElBQUltWDtZQUN6RCxJQUFJK0wsU0FBUy9JLGFBQWEsSUFBSTtZQUM5QixJQUFJMmIsV0FBVzVTLFVBQVVsSyxZQUFZO2dCQUNuQ1EsZ0JBQWdCO2dCQUNoQkMsaUJBQWlCLElBQUksQ0FBQ25RLEtBQUs7Z0JBQzNCbU8sTUFBTXFiO2dCQUNObHZCLFFBQVEsSUFBSTtnQkFDWnVKLFVBQVVwSztZQUNaLElBQUk7WUFDSixJQUFJaVcsYUFBYWhaLGtCQUF5QixjQUFjO2dCQUN0RHdYLGVBQWVzZTtZQUNqQjtZQUNBcEosWUFBWTtnQkFDVmtILE9BQU94RSxLQUFLLENBQUM5a0IsYUFBYTtnQkFDMUJzcEIsT0FBT1osS0FBSyxDQUFDLFNBQVMsQ0FBQ2p3QjtZQUN6QjtZQUNBLElBQUltZ0IsUUFBUTtnQkFDVjlJLGdCQUFnQixJQUFJLEVBQUUwYjtZQUN4QjtZQUNBLElBQUk5YyxhQUFhaFosa0JBQXlCLGNBQWM7Z0JBQ3REMlk7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBM08sT0FBT3lJLEdBQUcsR0FBRyxTQUFTQSxJQUFJMVAsS0FBSztRQUM3QixJQUFJLENBQUNxc0IsS0FBSyxDQUFDaGxCLGNBQWM7UUFDekIsT0FBTyxJQUFJLENBQUM0b0IsS0FBSyxDQUFDdmdCLEdBQUcsQ0FBQyxJQUFJLENBQUNnZCxhQUFhLENBQUMxc0I7SUFDM0M7SUFDQWlILE9BQU9naEIsT0FBTyxHQUFHLFNBQVNBO1FBQ3hCLElBQUlELFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLE9BQU9nTCxtQkFBbUI7WUFDeEJodkIsTUFBTSxTQUFTQTtnQkFDYixJQUFJaXZCLGVBQWVqTCxPQUFPaGtCLElBQUksSUFDNUJoRSxRQUFRaXpCLGFBQWFqekIsS0FBSyxFQUMxQm9FLE9BQU82dUIsYUFBYTd1QixJQUFJO2dCQUMxQixPQUFPLENBQUNBLE9BQU87b0JBQ2JwRSxPQUFPO3dCQUFDQTt3QkFBT0E7cUJBQU07b0JBQ3JCb0UsTUFBTUE7Z0JBQ1IsSUFBSTtvQkFDRnBFLE9BQU91SjtvQkFDUG5GLE1BQU1BO2dCQUNSO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E2QyxPQUFPbEYsSUFBSSxHQUFHLFNBQVNBO1FBQ3JCLE9BQU8sSUFBSSxDQUFDaW1CLE1BQU07SUFDcEI7SUFDQS9nQixPQUFPK2dCLE1BQU0sR0FBRyxTQUFTQTtRQUN2QixJQUFJLENBQUNxRSxLQUFLLENBQUNobEIsY0FBYztRQUN6QixJQUFJakosUUFBTyxJQUFJO1FBQ2YsSUFBSTRwQixTQUFTLElBQUksQ0FBQ2lJLEtBQUssQ0FBQ2pJLE1BQU07UUFDOUIsT0FBT2dMLG1CQUFtQjtZQUN4Qmh2QixNQUFNLFNBQVNBO2dCQUNiLElBQUlrdkIsZ0JBQWdCbEwsT0FBT2hrQixJQUFJLElBQzdCaEUsUUFBUWt6QixjQUFjbHpCLEtBQUssRUFDM0JvRSxPQUFPOHVCLGNBQWM5dUIsSUFBSTtnQkFDM0IsT0FBTyxDQUFDQSxPQUFPO29CQUNicEUsT0FBTzVCLE1BQUtzdUIsYUFBYSxDQUFDMXNCO29CQUMxQm9FLE1BQU1BO2dCQUNSLElBQUk7b0JBQ0ZwRSxPQUFPdUo7b0JBQ1BuRixNQUFNQTtnQkFDUjtZQUNGO1FBQ0Y7SUFDRjtJQUNBNkMsT0FBT2tzQixZQUFZLEdBQUcsU0FBU0EsYUFBYUMsUUFBUTtRQUNsRCxJQUFJenhCLFNBQVN5eEIsYUFBYSxDQUFDcHBCLGdCQUFnQm9wQixXQUFXO1lBQ3BELE9BQU9BLFNBQVNELFlBQVksQ0FBQyxJQUFJO1FBQ25DLE9BQU87WUFDTCxJQUFJRSxjQUFjLElBQUkzc0IsSUFBSSxJQUFJO1lBQzlCLE9BQU8yc0IsWUFBWUYsWUFBWSxDQUFDQztRQUNsQztJQUNGO0lBQ0Fuc0IsT0FBT3FzQixLQUFLLEdBQUcsU0FBU0EsTUFBTUYsUUFBUTtRQUNwQyxJQUFJenhCLFNBQVN5eEIsYUFBYSxDQUFDcHBCLGdCQUFnQm9wQixXQUFXO1lBQ3BELE9BQU9BLFNBQVNFLEtBQUssQ0FBQyxJQUFJO1FBQzVCLE9BQU87WUFDTCxJQUFJRCxjQUFjLElBQUkzc0IsSUFBSSxJQUFJO1lBQzlCLE9BQU8yc0IsWUFBWUMsS0FBSyxDQUFDRjtRQUMzQjtJQUNGO0lBQ0Fuc0IsT0FBT3NzQixVQUFVLEdBQUcsU0FBU0EsV0FBV0gsUUFBUTtRQUM5QyxPQUFPLElBQUkxc0IsSUFBSSxJQUFJLEVBQUU2c0IsVUFBVSxDQUFDSDtJQUNsQztJQUNBbnNCLE9BQU91c0IsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQW9CSixRQUFRO1FBQ2hFLElBQUl6eEIsU0FBU3l4QixhQUFhLENBQUNwcEIsZ0JBQWdCb3BCLFdBQVc7WUFDcEQsT0FBT0EsU0FBU0ksbUJBQW1CLENBQUMsSUFBSTtRQUMxQyxPQUFPO1lBQ0wsSUFBSUgsY0FBYyxJQUFJM3NCLElBQUksSUFBSTtZQUM5QixPQUFPMnNCLFlBQVlHLG1CQUFtQixDQUFDSjtRQUN6QztJQUNGO0lBQ0Fuc0IsT0FBT3dzQixVQUFVLEdBQUcsU0FBU0EsV0FBV0wsUUFBUTtRQUM5QyxPQUFPLElBQUkxc0IsSUFBSSxJQUFJLEVBQUUrc0IsVUFBVSxDQUFDTDtJQUNsQztJQUNBbnNCLE9BQU95c0IsWUFBWSxHQUFHLFNBQVNBLGFBQWFOLFFBQVE7UUFDbEQsT0FBTyxJQUFJMXNCLElBQUksSUFBSSxFQUFFZ3RCLFlBQVksQ0FBQ047SUFDcEM7SUFDQW5zQixPQUFPMHNCLGNBQWMsR0FBRyxTQUFTQSxlQUFlUCxRQUFRO1FBQ3RELElBQUl6eEIsU0FBU3l4QixhQUFhLENBQUNwcEIsZ0JBQWdCb3BCLFdBQVc7WUFDcEQsT0FBT0EsU0FBU08sY0FBYyxDQUFDLElBQUk7UUFDckMsT0FBTztZQUNMLElBQUlOLGNBQWMsSUFBSTNzQixJQUFJLElBQUk7WUFDOUIsT0FBTzJzQixZQUFZTSxjQUFjLENBQUNQO1FBQ3BDO0lBQ0Y7SUFDQW5zQixPQUFPbVksT0FBTyxHQUFHLFNBQVNBLFFBQVE1aUIsS0FBSztRQUNyQyxJQUFJNjBCLFNBQVMsSUFBSTtRQUNqQixJQUFJcm5CLGdCQUFnQnhOLFFBQVE7WUFDMUJBLFFBQVEsSUFBSWtLLElBQUlsSztRQUNsQjtRQUNBbXRCLFlBQVk7WUFDVixJQUFJcHNCLE1BQU0yRyxPQUFPLENBQUMxSCxRQUFRO2dCQUN4QjYwQixPQUFPakQsS0FBSztnQkFDWjV4QixNQUFNdUcsT0FBTyxDQUFDLFNBQVUvQyxLQUFLO29CQUMzQixPQUFPcXhCLE9BQU81aEIsR0FBRyxDQUFDelA7Z0JBQ3BCO1lBQ0YsT0FBTyxJQUFJMkIsU0FBU25GLFFBQVE7Z0JBQzFCNjBCLE9BQU9qRCxLQUFLO2dCQUNaNXhCLE1BQU11RyxPQUFPLENBQUMsU0FBVS9DLEtBQUs7b0JBQzNCLE9BQU9xeEIsT0FBTzVoQixHQUFHLENBQUN6UDtnQkFDcEI7WUFDRixPQUFPLElBQUl4RCxVQUFVLFFBQVFBLFVBQVUrTSxXQUFXO2dCQUNoRHJNLElBQUksZ0NBQWdDVjtZQUN0QztRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQXlLLE9BQU93USxRQUFRLEdBQUcsU0FBU0EsU0FBU3RRLFFBQVEsRUFBRXVRLGVBQWU7UUFDM0QsNENBQTRDO1FBQzVDLElBQUl6YSxLQUFxQyxJQUFJeWEsb0JBQW9CLE1BQU07WUFDckV4YSxJQUFJO1FBQ047UUFDQSxPQUFPeWEsaUJBQWlCLElBQUksRUFBRXhRO0lBQ2hDO0lBQ0FGLE9BQU9xUSxVQUFVLEdBQUcsU0FBU0EsV0FBV0MsT0FBTztRQUM3QyxPQUFPQyxvQkFBb0IsSUFBSSxFQUFFRDtJQUNuQztJQUNBdFEsT0FBTzRRLE1BQU0sR0FBRyxTQUFTQTtRQUN2QixPQUFPdGEsTUFBTXlILElBQUksQ0FBQyxJQUFJO0lBQ3hCO0lBQ0FpQyxPQUFPNUssUUFBUSxHQUFHLFNBQVNBO1FBQ3pCLE9BQU87SUFDVDtJQUNBNEssTUFBTSxDQUFDbkQsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDeEIsT0FBTyxJQUFJLENBQUNpa0IsTUFBTTtJQUNwQjtJQUNBLE9BQU9wa0IsYUFBYTJPLGVBQWU7UUFBQztZQUNsQ25XLEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osSUFBSSxDQUFDMGtCLEtBQUssQ0FBQ2hsQixjQUFjO2dCQUN6QixPQUFPLElBQUksQ0FBQzRvQixLQUFLLENBQUMxVyxJQUFJO1lBQ3hCO1FBQ0Y7UUFBRztZQUNEbmQsS0FBSzBILE9BQU82dUIsV0FBVztZQUN2QmhyQixLQUFLLFNBQVNBO2dCQUNaLE9BQU87WUFDVDtRQUNGO0tBQUU7QUFDSjtBQUNBLDJCQUEyQjtBQUMzQixJQUFJcUMsa0JBQWtCLFdBQVcsR0FBRTdJLDBCQUEwQixpQkFBaUJvUjtBQUM5RSxTQUFTeWdCLG1CQUFtQmp2QixRQUFRO0lBQ2xDQSxRQUFRLENBQUNELE9BQU82dUIsV0FBVyxDQUFDLEdBQUc7SUFDL0IsT0FBT0MsYUFBYTd1QjtBQUN0QjtBQUVBLElBQUk2dkIsa0JBQWtCLFdBQVcsR0FBRXQxQixPQUFPa0csTUFBTSxDQUFDO0FBQ2pELElBQUlxdkIsU0FBUztBQUNiLElBQUlDLGlDQUFpQyxXQUFXLEdBQUU7SUFDaEQsU0FBU0EsK0JBQStCcG9CLE9BQU8sRUFBRStDLE9BQU8sRUFBRWxJLEtBQUssRUFDL0Qsc0RBQXNEO0lBQ3REd3RCLGtCQUFrQjtRQUNoQixJQUFJdGxCLFlBQVksS0FBSyxHQUFHO1lBQ3RCQSxVQUFVLElBQUk0YTtRQUNoQjtRQUNBLElBQUkwSyx1QkFBdUIsS0FBSyxHQUFHO1lBQ2pDQSxxQkFBcUJqa0I7UUFDdkI7UUFDQSxJQUFJLENBQUNwRSxPQUFPLEdBQUcsS0FBSztRQUNwQixJQUFJLENBQUMrQyxPQUFPLEdBQUcsS0FBSztRQUNwQixJQUFJLENBQUNsSSxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUN3dEIsa0JBQWtCLEdBQUcsS0FBSztRQUMvQixJQUFJLENBQUM1RCxTQUFTLEdBQUcsS0FBSztRQUN0QixJQUFJLENBQUM5WixnQkFBZ0IsR0FBRyxLQUFLO1FBQzdCLElBQUksQ0FBQ0QsYUFBYSxHQUFHLEtBQUs7UUFDMUIsSUFBSSxDQUFDNUksTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDOUMsY0FBYyxHQUFHLEtBQUs7UUFDM0IsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxLQUFLO1FBQ2hDLElBQUksQ0FBQ3FwQixZQUFZLEdBQUcsS0FBSztRQUN6QixJQUFJLENBQUN0b0IsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQytDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNsSSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDd3RCLGtCQUFrQixHQUFHQTtRQUMxQixJQUFJLENBQUM1RCxTQUFTLEdBQUcsSUFBSTdwQixLQUFLckosS0FBcUMsR0FBRyxJQUFJLENBQUNzSixLQUFLLEdBQUcsVUFBVSxDQUF1QjtRQUNoSCx1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDbUUsY0FBYyxHQUFHdkssY0FBYyxJQUFJLENBQUN1TCxPQUFPO1FBQ2hELElBQUl6TyxLQUFxQyxJQUFJLENBQUNnM0IsYUFBYSxJQUFJLENBQUNGLGtCQUFrQixHQUFHO1lBQ25GNzJCLElBQUk7UUFDTjtRQUNBLElBQUlELElBQXFDLEVBQUU7WUFDekMscUVBQXFFO1lBQ3JFLElBQUksQ0FBQzBOLG1CQUFtQixHQUFHLENBQUM7UUFDOUI7SUFDRjtJQUNBLElBQUkxRCxTQUFTNnNCLCtCQUErQm4xQixTQUFTO0lBQ3JEc0ksT0FBTzBILHVCQUF1QixHQUFHLFNBQVNBLHdCQUF3QnZTLEdBQUc7UUFDbkUsT0FBTyxJQUFJLENBQUNxUyxPQUFPLENBQUM5RyxHQUFHLENBQUN2TCxLQUFLdUwsR0FBRztJQUNsQztJQUNBVixPQUFPMEksdUJBQXVCLEdBQUcsU0FBU0Esd0JBQXdCdlQsR0FBRyxFQUFFZ0gsUUFBUTtRQUM3RSxJQUFJaUcsYUFBYSxJQUFJLENBQUNvRixPQUFPLENBQUM5RyxHQUFHLENBQUN2TDtRQUNsQyxJQUFJaU4sc0JBQXNCcUYsZUFBZTtZQUN2Q3JGLFdBQVd4QixHQUFHLENBQUN6RTtZQUNmLE9BQU87UUFDVDtRQUNBLFlBQVk7UUFDWixJQUFJNlQsZ0JBQWdCLElBQUksR0FBRztZQUN6QixJQUFJQyxTQUFTQyxnQkFBZ0IsSUFBSSxFQUFFO2dCQUNqQ3pDLE1BQU1vQztnQkFDTmpXLFFBQVEsSUFBSSxDQUFDMk0sTUFBTSxJQUFJLElBQUksQ0FBQzlCLE9BQU87Z0JBQ25DaFAsTUFBTU47Z0JBQ05nSCxVQUFVQTtZQUNaO1lBQ0EsSUFBSSxDQUFDOFQsUUFBUTtnQkFDWCxPQUFPO1lBQ1Q7WUFDQTlULFdBQVc4VCxPQUFPOVQsUUFBUTtRQUM1QjtRQUNBQSxXQUFXaUcsV0FBV3VOLGdCQUFnQixDQUFDeFQ7UUFDdkMseUJBQXlCO1FBQ3pCLElBQUlBLGFBQWEvRCxZQUFZd1gsU0FBUyxFQUFFO1lBQ3RDLElBQUlzSixTQUFTL0ksYUFBYSxJQUFJO1lBQzlCLElBQUluQixZQUFZaFosS0FBcUMsSUFBSW1YO1lBQ3pELElBQUl1YyxVQUFVeFEsVUFBVWxLLFlBQVk7Z0JBQ2xDdkIsTUFBTW9DO2dCQUNOTCxnQkFBZ0I7Z0JBQ2hCQyxpQkFBaUIsSUFBSSxDQUFDblEsS0FBSztnQkFDM0IxRixRQUFRLElBQUksQ0FBQzJNLE1BQU0sSUFBSSxJQUFJLENBQUM5QixPQUFPO2dCQUNuQ3RCLFVBQVVmLFdBQVdpTixNQUFNO2dCQUMzQjVaLE1BQU1OO2dCQUNOZ0gsVUFBVUE7WUFDWixJQUFJO1lBQ0osSUFBSW5HLEtBQXFDLElBQUlnWixXQUFXO2dCQUN0RHhCLGVBQWVrYztZQUNqQjtZQUNBdG5CLFdBQVcwTixZQUFZLENBQUMzVDtZQUN4QixJQUFJK2MsUUFBUTtnQkFDVjlJLGdCQUFnQixJQUFJLEVBQUVzWjtZQUN4QjtZQUNBLElBQUkxekIsS0FBcUMsSUFBSWdaLFdBQVc7Z0JBQ3RETDtZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQTNPLE9BQU91aEIsSUFBSSxHQUFHLFNBQVNBLEtBQUtwc0IsR0FBRztRQUM3QixJQUFJaUQsWUFBWXdWLGtCQUFrQixJQUFJLENBQUNuUyxRQUFRLElBQUksQ0FBQ2dKLE9BQU8sRUFBRXRQLE1BQU07WUFDakUsbUVBQW1FO1lBQ25FLElBQUksQ0FBQ21zQixJQUFJLENBQUNuc0I7UUFDWjtRQUNBLE9BQU8sSUFBSSxDQUFDc1AsT0FBTyxDQUFDdFAsSUFBSTtJQUMxQixFQUNBOzs7Ozs7R0FNQztJQUNENkssT0FBT2toQixJQUFJLEdBQUcsU0FBU0EsS0FBSy9yQixHQUFHLEVBQUU0RCxLQUFLLEVBQUU2SyxTQUFTO1FBQy9DLElBQUlBLGNBQWMsS0FBSyxHQUFHO1lBQ3hCQSxZQUFZO1FBQ2Q7UUFDQSwwQ0FBMEM7UUFDMUMsSUFBSW5JLFFBQVEsSUFBSSxDQUFDZ0osT0FBTyxFQUFFdFAsTUFBTTtZQUM5QixnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNxUyxPQUFPLENBQUNpQixHQUFHLENBQUN0VCxNQUFNO2dCQUN6QixrQ0FBa0M7Z0JBQ2xDLE9BQU8sSUFBSSxDQUFDdVQsdUJBQXVCLENBQUN2VCxLQUFLNEQ7WUFDM0MsT0FBTyxJQUFJNkssV0FBVztnQkFDcEIseUJBQXlCO2dCQUN6QixPQUFPdkksUUFBUXVGLEdBQUcsQ0FBQyxJQUFJLENBQUM2RCxPQUFPLEVBQUV0UCxLQUFLNEQ7WUFDeEMsT0FBTztnQkFDTCxpQkFBaUI7Z0JBQ2pCLElBQUksQ0FBQzBMLE9BQU8sQ0FBQ3RQLElBQUksR0FBRzREO2dCQUNwQixPQUFPO1lBQ1Q7UUFDRixPQUFPO1lBQ0wsV0FBVztZQUNYLE9BQU8sSUFBSSxDQUFDd0ssT0FBTyxDQUFDcE8sS0FBSztnQkFDdkI0RCxPQUFPQTtnQkFDUGUsWUFBWTtnQkFDWkMsVUFBVTtnQkFDVkMsY0FBYztZQUNoQixHQUFHLElBQUksQ0FBQzh5QixrQkFBa0IsRUFBRWxwQjtRQUM5QjtJQUNGO0lBR0E1RCxPQUFPc2hCLElBQUksR0FBRyxTQUFTQSxLQUFLbnNCLEdBQUc7UUFDN0IsSUFBSSxDQUFDaUQsWUFBWXdWLGtCQUFrQixFQUFFO1lBQ25DLDJDQUEyQztZQUMzQyxPQUFPelksT0FBTyxJQUFJLENBQUNzUCxPQUFPO1FBQzVCO1FBQ0EsSUFBSSxDQUFDc29CLFlBQVksSUFBSyxLQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJM0ssS0FBSTtRQUNsRCxJQUFJZ0gsUUFBUSxJQUFJLENBQUMyRCxZQUFZLENBQUNyc0IsR0FBRyxDQUFDdkw7UUFDbEMsSUFBSSxDQUFDaTBCLE9BQU87WUFDVkEsUUFBUSxJQUFJN2dCLGdCQUFnQnBULE9BQU8sSUFBSSxDQUFDc1AsT0FBTyxFQUFFeEIsbUJBQW1Cak4sS0FBcUMsR0FBRyxJQUFJLENBQUNzSixLQUFLLEdBQUcsTUFBTS9ELGFBQWFwRyxPQUFPLE1BQU0sQ0FBdUIsRUFBRTtZQUNsTCxJQUFJLENBQUM0M0IsWUFBWSxDQUFDbnNCLEdBQUcsQ0FBQ3pMLEtBQUtpMEI7UUFDN0I7UUFDQSxPQUFPQSxNQUFNMW9CLEdBQUc7SUFDbEIsRUFDQTs7O0dBR0M7SUFDRFYsT0FBT3NELEtBQUssR0FBRyxTQUFTQSxNQUFNbk8sR0FBRyxFQUFFZ0osVUFBVTtRQUMzQyxJQUFJQSxlQUFlLE1BQU07WUFDdkJBLGFBQWEsSUFBSSxDQUFDMnVCLGtCQUFrQjtRQUN0QztRQUNBLElBQUkzdUIsZUFBZSxPQUFPO1lBQ3hCO1FBQ0Y7UUFDQTh1QixnQkFBZ0IsSUFBSSxFQUFFOXVCLFlBQVloSjtRQUNsQyxJQUFJLENBQUVBLENBQUFBLE9BQU8sSUFBSSxDQUFDc1AsT0FBTyxHQUFHO1lBQzFCLElBQUl5b0I7WUFDSiwrQ0FBK0M7WUFDL0Msa0VBQWtFO1lBQ2xFLHlEQUF5RDtZQUN6RCxxREFBcUQ7WUFDckQsNkRBQTZEO1lBQzdELElBQUksQ0FBQ0Esd0JBQXdCLElBQUksQ0FBQ3pvQixPQUFPLENBQUN4Ryx3QkFBd0IsS0FBSyxRQUFRaXZCLHFCQUFxQixDQUFDLzNCLElBQUksRUFBRTtnQkFDekcsUUFBUSw0Q0FBNEM7WUFDdEQsT0FBTztnQkFDTGMsSUFBSSxHQUFHa0ksV0FBV1MsZUFBZSxFQUFFLElBQUksQ0FBQ1UsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRO1lBQ3BFO1FBQ0Y7UUFDQSxJQUFJa1AsU0FBUyxJQUFJLENBQUNHLE9BQU87UUFDekIsTUFBT0gsVUFBVUEsV0FBVzdNLGdCQUFpQjtZQUMzQyxJQUFJa00sYUFBYXJNLGNBQWNnTixRQUFRblA7WUFDdkMsSUFBSXdPLFlBQVk7Z0JBQ2QsSUFBSXdwQixVQUFVaHZCLFdBQVdtRixLQUFLLENBQUMsSUFBSSxFQUFFbk8sS0FBS3dPLFlBQVlXO2dCQUN0RCxJQUFJNm9CLFlBQVksRUFBRSxxQkFBcUIsS0FBSTtvQkFDekM7Z0JBQ0Y7Z0JBQ0EsSUFBSUEsWUFBWSxFQUFFLG9CQUFvQixLQUFJO29CQUN4QztnQkFDRjtZQUNGO1lBQ0E3b0IsU0FBU2pOLE9BQU8rQixjQUFjLENBQUNrTDtRQUNqQztRQUNBOG9CLHdCQUF3QixJQUFJLEVBQUVqdkIsWUFBWWhKO0lBQzVDLEVBQ0E7Ozs7OztHQU1DO0lBQ0Q2SyxPQUFPdUQsT0FBTyxHQUFHLFNBQVNBLFFBQVFwTyxHQUFHLEVBQUV3TyxVQUFVLEVBQUV4RixVQUFVLEVBQUV5RixTQUFTO1FBQ3RFLElBQUlBLGNBQWMsS0FBSyxHQUFHO1lBQ3hCQSxZQUFZO1FBQ2Q7UUFDQSxJQUFJekYsZUFBZSxNQUFNO1lBQ3ZCQSxhQUFhLElBQUksQ0FBQzJ1QixrQkFBa0I7UUFDdEM7UUFDQSxJQUFJM3VCLGVBQWUsT0FBTztZQUN4QixPQUFPLElBQUksQ0FBQ3lHLGVBQWUsQ0FBQ3pQLEtBQUt3TyxZQUFZQztRQUMvQztRQUNBcXBCLGdCQUFnQixJQUFJLEVBQUU5dUIsWUFBWWhKO1FBQ2xDLElBQUlnNEIsVUFBVWh2QixXQUFXb0YsT0FBTyxDQUFDLElBQUksRUFBRXBPLEtBQUt3TyxZQUFZQztRQUN4RCxJQUFJdXBCLFNBQVM7WUFDWEMsd0JBQXdCLElBQUksRUFBRWp2QixZQUFZaEo7UUFDNUM7UUFDQSxPQUFPZzRCO0lBQ1QsRUFDQTs7Ozs7R0FLQztJQUNEbnRCLE9BQU80RSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCelAsR0FBRyxFQUFFd08sVUFBVSxFQUFFQyxTQUFTO1FBQzFFLElBQUlBLGNBQWMsS0FBSyxHQUFHO1lBQ3hCQSxZQUFZO1FBQ2Q7UUFDQW1NLG9DQUFvQyxJQUFJLENBQUNtWixTQUFTO1FBQ2xELElBQUk7WUFDRjNvQjtZQUNBLFNBQVM7WUFDVCxJQUFJOHNCLGdCQUFnQixJQUFJLENBQUNoTSxPQUFPLENBQUNsc0I7WUFDakMsSUFBSSxDQUFDazRCLGVBQWU7Z0JBQ2xCLHlCQUF5QjtnQkFDekIsT0FBT0E7WUFDVDtZQUNBLGtCQUFrQjtZQUNsQixJQUFJcmQsZ0JBQWdCLElBQUksR0FBRztnQkFDekIsSUFBSUMsU0FBU0MsZ0JBQWdCLElBQUksRUFBRTtvQkFDakN0VyxRQUFRLElBQUksQ0FBQzJNLE1BQU0sSUFBSSxJQUFJLENBQUM5QixPQUFPO29CQUNuQ2hQLE1BQU1OO29CQUNOc1ksTUFBTW9iO29CQUNOMXNCLFVBQVV3SCxXQUFXNUssS0FBSztnQkFDNUI7Z0JBQ0EsSUFBSSxDQUFDa1gsUUFBUTtvQkFDWCxPQUFPO2dCQUNUO2dCQUNBLElBQUk5VCxXQUFXOFQsT0FBTzlULFFBQVE7Z0JBQzlCLElBQUl3SCxXQUFXNUssS0FBSyxLQUFLb0QsVUFBVTtvQkFDakN3SCxhQUFhdEcsU0FBUyxDQUFDLEdBQUdzRyxZQUFZO3dCQUNwQzVLLE9BQU9vRDtvQkFDVDtnQkFDRjtZQUNGO1lBQ0EsU0FBUztZQUNULElBQUl5SCxXQUFXO2dCQUNiLElBQUksQ0FBQ3ZJLFFBQVE3RCxjQUFjLENBQUMsSUFBSSxDQUFDaU4sT0FBTyxFQUFFdFAsS0FBS3dPLGFBQWE7b0JBQzFELE9BQU87Z0JBQ1Q7WUFDRixPQUFPO2dCQUNMbk0sZUFBZSxJQUFJLENBQUNpTixPQUFPLEVBQUV0UCxLQUFLd087WUFDcEM7WUFDQSxTQUFTO1lBQ1QsSUFBSSxDQUFDMnBCLHVCQUF1QixDQUFDbjRCLEtBQUt3TyxXQUFXNUssS0FBSztRQUNwRCxTQUFVO1lBQ1IwSDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBR0FULE9BQU9pSSx5QkFBeUIsR0FBRyxTQUFTQSwwQkFBMEI5UyxHQUFHLEVBQUU0RCxLQUFLLEVBQUVtUCxRQUFRLEVBQUV0RSxTQUFTO1FBQ25HLElBQUlBLGNBQWMsS0FBSyxHQUFHO1lBQ3hCQSxZQUFZO1FBQ2Q7UUFDQW1NLG9DQUFvQyxJQUFJLENBQUNtWixTQUFTO1FBQ2xELElBQUk7WUFDRjNvQjtZQUNBLFNBQVM7WUFDVCxJQUFJOHNCLGdCQUFnQixJQUFJLENBQUNoTSxPQUFPLENBQUNsc0I7WUFDakMsSUFBSSxDQUFDazRCLGVBQWU7Z0JBQ2xCLHlCQUF5QjtnQkFDekIsT0FBT0E7WUFDVDtZQUNBLGtCQUFrQjtZQUNsQixJQUFJcmQsZ0JBQWdCLElBQUksR0FBRztnQkFDekIsSUFBSUMsU0FBU0MsZ0JBQWdCLElBQUksRUFBRTtvQkFDakN0VyxRQUFRLElBQUksQ0FBQzJNLE1BQU0sSUFBSSxJQUFJLENBQUM5QixPQUFPO29CQUNuQ2hQLE1BQU1OO29CQUNOc1ksTUFBTW9iO29CQUNOMXNCLFVBQVVwRDtnQkFDWjtnQkFDQSxJQUFJLENBQUNrWCxRQUFRO29CQUNYLE9BQU87Z0JBQ1Q7Z0JBQ0FsWCxRQUFRa1gsT0FBTzlULFFBQVE7WUFDekI7WUFDQSxJQUFJb3hCLG1CQUFtQkMsa0NBQWtDcjRCO1lBQ3pELElBQUl3TyxhQUFhO2dCQUNmM0osY0FBYzVCLFlBQVkwTixlQUFlLEdBQUcsSUFBSSxDQUFDckMsY0FBYyxHQUFHO2dCQUNsRTNKLFlBQVk7Z0JBQ1o0RyxLQUFLNnNCLGlCQUFpQjdzQixHQUFHO2dCQUN6QkUsS0FBSzJzQixpQkFBaUIzc0IsR0FBRztZQUMzQjtZQUNBLFNBQVM7WUFDVCxJQUFJZ0QsV0FBVztnQkFDYixJQUFJLENBQUN2SSxRQUFRN0QsY0FBYyxDQUFDLElBQUksQ0FBQ2lOLE9BQU8sRUFBRXRQLEtBQUt3TyxhQUFhO29CQUMxRCxPQUFPO2dCQUNUO1lBQ0YsT0FBTztnQkFDTG5NLGVBQWUsSUFBSSxDQUFDaU4sT0FBTyxFQUFFdFAsS0FBS3dPO1lBQ3BDO1lBQ0EsSUFBSXZCLGFBQWEsSUFBSW1HLGdCQUFnQnhQLE9BQU9tUCxVQUFVbFMsS0FBcUMsR0FBRyxJQUFJLENBQUNzSixLQUFLLEdBQUcsTUFBTW5LLElBQUlDLFFBQVEsS0FBSyxDQUFzQixFQUFFO1lBQzFKLElBQUksQ0FBQ29TLE9BQU8sQ0FBQzVHLEdBQUcsQ0FBQ3pMLEtBQUtpTjtZQUN0QixxREFBcUQ7WUFDckQsSUFBSSxDQUFDa3JCLHVCQUF1QixDQUFDbjRCLEtBQUtpTixXQUFXaU4sTUFBTTtRQUNyRCxTQUFVO1lBQ1I1TztRQUNGO1FBQ0EsT0FBTztJQUNUO0lBR0FULE9BQU9zSCx1QkFBdUIsR0FBRyxTQUFTQSx3QkFBd0JuUyxHQUFHLEVBQUU4TyxPQUFPLEVBQUVMLFNBQVM7UUFDdkYsSUFBSUEsY0FBYyxLQUFLLEdBQUc7WUFDeEJBLFlBQVk7UUFDZDtRQUNBbU0sb0NBQW9DLElBQUksQ0FBQ21aLFNBQVM7UUFDbEQsSUFBSTtZQUNGM29CO1lBQ0EsU0FBUztZQUNULElBQUk4c0IsZ0JBQWdCLElBQUksQ0FBQ2hNLE9BQU8sQ0FBQ2xzQjtZQUNqQyxJQUFJLENBQUNrNEIsZUFBZTtnQkFDbEIseUJBQXlCO2dCQUN6QixPQUFPQTtZQUNUO1lBQ0Esa0JBQWtCO1lBQ2xCLElBQUlyZCxnQkFBZ0IsSUFBSSxHQUFHO2dCQUN6QixJQUFJQyxTQUFTQyxnQkFBZ0IsSUFBSSxFQUFFO29CQUNqQ3RXLFFBQVEsSUFBSSxDQUFDMk0sTUFBTSxJQUFJLElBQUksQ0FBQzlCLE9BQU87b0JBQ25DaFAsTUFBTU47b0JBQ05zWSxNQUFNb2I7b0JBQ04xc0IsVUFBVW1HO2dCQUNaO2dCQUNBLElBQUksQ0FBQzJOLFFBQVE7b0JBQ1gsT0FBTztnQkFDVDtZQUNGO1lBQ0FoTSxRQUFReE8sSUFBSSxJQUFLd08sQ0FBQUEsUUFBUXhPLElBQUksR0FBR08sS0FBcUMsR0FBRyxJQUFJLENBQUNzSixLQUFLLEdBQUcsTUFBTW5LLElBQUlDLFFBQVEsS0FBSyxDQUFxQjtZQUNqSTZPLFFBQVFsRixPQUFPLEdBQUcsSUFBSSxDQUFDd0gsTUFBTSxJQUFJLElBQUksQ0FBQzlCLE9BQU87WUFDN0MsSUFBSThvQixtQkFBbUJDLGtDQUFrQ3I0QjtZQUN6RCxJQUFJd08sYUFBYTtnQkFDZjNKLGNBQWM1QixZQUFZME4sZUFBZSxHQUFHLElBQUksQ0FBQ3JDLGNBQWMsR0FBRztnQkFDbEUzSixZQUFZO2dCQUNaNEcsS0FBSzZzQixpQkFBaUI3c0IsR0FBRztnQkFDekJFLEtBQUsyc0IsaUJBQWlCM3NCLEdBQUc7WUFDM0I7WUFDQSxTQUFTO1lBQ1QsSUFBSWdELFdBQVc7Z0JBQ2IsSUFBSSxDQUFDdkksUUFBUTdELGNBQWMsQ0FBQyxJQUFJLENBQUNpTixPQUFPLEVBQUV0UCxLQUFLd08sYUFBYTtvQkFDMUQsT0FBTztnQkFDVDtZQUNGLE9BQU87Z0JBQ0xuTSxlQUFlLElBQUksQ0FBQ2lOLE9BQU8sRUFBRXRQLEtBQUt3TztZQUNwQztZQUNBLElBQUksQ0FBQzZELE9BQU8sQ0FBQzVHLEdBQUcsQ0FBQ3pMLEtBQUssSUFBSXNTLGNBQWN4RDtZQUN4QyxTQUFTO1lBQ1QsSUFBSSxDQUFDcXBCLHVCQUF1QixDQUFDbjRCLEtBQUttTjtRQUNwQyxTQUFVO1lBQ1I3QjtRQUNGO1FBQ0EsT0FBTztJQUNULEVBQ0E7Ozs7O0dBS0M7SUFDRFQsT0FBT3FoQixPQUFPLEdBQUcsU0FBU0EsUUFBUWxzQixHQUFHLEVBQUV5TyxTQUFTO1FBQzlDLElBQUlBLGNBQWMsS0FBSyxHQUFHO1lBQ3hCQSxZQUFZO1FBQ2Q7UUFDQW1NLG9DQUFvQyxJQUFJLENBQUNtWixTQUFTO1FBQ2xELGVBQWU7UUFDZixJQUFJLENBQUN6dEIsUUFBUSxJQUFJLENBQUNnSixPQUFPLEVBQUV0UCxNQUFNO1lBQy9CLE9BQU87UUFDVDtRQUNBLFlBQVk7UUFDWixJQUFJNmEsZ0JBQWdCLElBQUksR0FBRztZQUN6QixJQUFJQyxTQUFTQyxnQkFBZ0IsSUFBSSxFQUFFO2dCQUNqQ3RXLFFBQVEsSUFBSSxDQUFDMk0sTUFBTSxJQUFJLElBQUksQ0FBQzlCLE9BQU87Z0JBQ25DaFAsTUFBTU47Z0JBQ05zWSxNQUFNbWY7WUFDUjtZQUNBLFlBQVk7WUFDWixJQUFJLENBQUMzYyxRQUFRO2dCQUNYLE9BQU87WUFDVDtRQUNGO1FBQ0EsU0FBUztRQUNULElBQUk7WUFDRixJQUFJd2Q7WUFDSmx0QjtZQUNBLElBQUkyWSxTQUFTL0ksYUFBYSxJQUFJO1lBQzlCLElBQUluQixZQUFZaFosS0FBcUMsSUFBSW1YO1lBQ3pELElBQUkvSyxhQUFhLElBQUksQ0FBQ29GLE9BQU8sQ0FBQzlHLEdBQUcsQ0FBQ3ZMO1lBQ2xDLG1DQUFtQztZQUNuQyxJQUFJNEQsUUFBUXVKO1lBQ1osNERBQTREO1lBQzVELElBQUksQ0FBQ0YsY0FBZThXLENBQUFBLFVBQVVsSyxTQUFRLEdBQUk7Z0JBQ3hDLElBQUk1QztnQkFDSnJULFFBQVEsQ0FBQ3FULGlCQUFpQjlVLGNBQWMsSUFBSSxDQUFDbU4sT0FBTyxFQUFFdFAsSUFBRyxLQUFNLE9BQU8sS0FBSyxJQUFJaVgsZUFBZXJULEtBQUs7WUFDckc7WUFDQSxtQ0FBbUM7WUFDbkMsSUFBSTZLLFdBQVc7Z0JBQ2IsSUFBSSxDQUFDdkksUUFBUXVvQixjQUFjLENBQUMsSUFBSSxDQUFDbmYsT0FBTyxFQUFFdFAsTUFBTTtvQkFDOUMsT0FBTztnQkFDVDtZQUNGLE9BQU87Z0JBQ0wsT0FBTyxJQUFJLENBQUNzUCxPQUFPLENBQUN0UCxJQUFJO1lBQzFCO1lBQ0EsaUNBQWlDO1lBQ2pDLElBQUlhLElBQXFDLEVBQUU7Z0JBQ3pDLE9BQU8sSUFBSSxDQUFDME4sbUJBQW1CLENBQUN2TyxJQUFJO1lBQ3RDO1lBQ0EsbUJBQW1CO1lBQ25CLElBQUlpTixZQUFZO2dCQUNkLElBQUksQ0FBQ29GLE9BQU8sQ0FBQyxTQUFTLENBQUNyUztnQkFDdkIsbUNBQW1DO2dCQUNuQyxJQUFJaU4sc0JBQXNCbUcsaUJBQWlCO29CQUN6Q3hQLFFBQVFxSixXQUFXaU4sTUFBTTtnQkFDM0I7Z0JBQ0EsNkNBQTZDO2dCQUM3QzdPLGlCQUFpQjRCO1lBQ25CO1lBQ0EseUNBQXlDO1lBQ3pDLElBQUksQ0FBQzhtQixTQUFTLENBQUM1b0IsYUFBYTtZQUM1Qix5QkFBeUI7WUFDekIsc0NBQXNDO1lBQ3JDbXRCLENBQUFBLHFCQUFxQixJQUFJLENBQUNWLFlBQVksS0FBSyxRQUFRLENBQUNVLHFCQUFxQkEsbUJBQW1CL3NCLEdBQUcsQ0FBQ3ZMLElBQUcsS0FBTSxRQUFRczRCLG1CQUFtQjdzQixHQUFHLENBQUN6TCxPQUFPLElBQUksQ0FBQ3NQLE9BQU87WUFDNUoseUJBQXlCO1lBQ3pCLElBQUl5VSxVQUFVbEssV0FBVztnQkFDdkIsSUFBSThjLFdBQVc7b0JBQ2JyZSxNQUFNbWY7b0JBQ05wZCxnQkFBZ0I7b0JBQ2hCNVYsUUFBUSxJQUFJLENBQUMyTSxNQUFNLElBQUksSUFBSSxDQUFDOUIsT0FBTztvQkFDbkNnTCxpQkFBaUIsSUFBSSxDQUFDblEsS0FBSztvQkFDM0I2RCxVQUFVcEs7b0JBQ1Z0RCxNQUFNTjtnQkFDUjtnQkFDQSxJQUFJYSxLQUFxQyxJQUFJZ1osV0FBVztvQkFDdER4QixlQUFlc2U7Z0JBQ2pCO2dCQUNBLElBQUk1UyxRQUFRO29CQUNWOUksZ0JBQWdCLElBQUksRUFBRTBiO2dCQUN4QjtnQkFDQSxJQUFJOTFCLEtBQXFDLElBQUlnWixXQUFXO29CQUN0REw7Z0JBQ0Y7WUFDRjtRQUNGLFNBQVU7WUFDUmxPO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsRUFDQTs7OztHQUlDO0lBQ0RULE9BQU93USxRQUFRLEdBQUcsU0FBU0EsU0FBUzhYLFFBQVEsRUFBRTdYLGVBQWU7UUFDM0QsSUFBSXphLEtBQXFDLElBQUl5YSxvQkFBb0IsTUFBTTtZQUNyRXhhLElBQUk7UUFDTjtRQUNBLE9BQU95YSxpQkFBaUIsSUFBSSxFQUFFNFg7SUFDaEM7SUFDQXRvQixPQUFPcVEsVUFBVSxHQUFHLFNBQVNBLFdBQVdDLE9BQU87UUFDN0MsT0FBT0Msb0JBQW9CLElBQUksRUFBRUQ7SUFDbkM7SUFDQXRRLE9BQU9zdEIsdUJBQXVCLEdBQUcsU0FBU0Esd0JBQXdCbjRCLEdBQUcsRUFBRTRELEtBQUs7UUFDMUUsSUFBSTIwQjtRQUNKLElBQUl4VSxTQUFTL0ksYUFBYSxJQUFJO1FBQzlCLElBQUluQixZQUFZaFosS0FBcUMsSUFBSW1YO1FBQ3pELElBQUkrTCxVQUFVbEssV0FBVztZQUN2QixJQUFJaUIsU0FBU2lKLFVBQVVsSyxZQUFZO2dCQUNqQ3ZCLE1BQU1vYjtnQkFDTnJaLGdCQUFnQjtnQkFDaEJDLGlCQUFpQixJQUFJLENBQUNuUSxLQUFLO2dCQUMzQjFGLFFBQVEsSUFBSSxDQUFDMk0sTUFBTSxJQUFJLElBQUksQ0FBQzlCLE9BQU87Z0JBQ25DaFAsTUFBTU47Z0JBQ05nSCxVQUFVcEQ7WUFDWixJQUFJO1lBQ0osSUFBSS9DLEtBQXFDLElBQUlnWixXQUFXO2dCQUN0RHhCLGVBQWV5QztZQUNqQjtZQUNBLElBQUlpSixRQUFRO2dCQUNWOUksZ0JBQWdCLElBQUksRUFBRUg7WUFDeEI7WUFDQSxJQUFJamEsS0FBcUMsSUFBSWdaLFdBQVc7Z0JBQ3RETDtZQUNGO1FBQ0Y7UUFDQytlLENBQUFBLHNCQUFzQixJQUFJLENBQUNYLFlBQVksS0FBSyxRQUFRLENBQUNXLHNCQUFzQkEsb0JBQW9CaHRCLEdBQUcsQ0FBQ3ZMLElBQUcsS0FBTSxRQUFRdTRCLG9CQUFvQjlzQixHQUFHLENBQUM7UUFDN0kseUNBQXlDO1FBQ3pDLElBQUksQ0FBQ3NvQixTQUFTLENBQUM1b0IsYUFBYTtJQUM5QjtJQUNBTixPQUFPMGhCLFFBQVEsR0FBRyxTQUFTQTtRQUN6QixJQUFJLENBQUN3SCxTQUFTLENBQUM5b0IsY0FBYztRQUM3QixPQUFPaEYsUUFBUSxJQUFJLENBQUNxSixPQUFPO0lBQzdCO0lBQ0F6RSxPQUFPOGdCLEtBQUssR0FBRyxTQUFTQTtRQUN0Qix1RkFBdUY7UUFDdkYsNkhBQTZIO1FBQzdILDhGQUE4RjtRQUM5Riw0REFBNEQ7UUFDNUQsaURBQWlEO1FBQ2pELHFGQUFxRjtRQUNyRixJQUFJLENBQUNvSSxTQUFTLENBQUM5b0IsY0FBYztRQUM3QixPQUFPL0ksT0FBT3lELElBQUksQ0FBQyxJQUFJLENBQUMySixPQUFPO0lBQ2pDO0lBQ0EsT0FBT29vQjtBQUNUO0FBQ0EsU0FBU3RsQixtQkFBbUI3TCxNQUFNLEVBQUV1SSxPQUFPO0lBQ3pDLElBQUkwcEI7SUFDSixJQUFJMzNCLEtBQXFDLElBQUlpTyxXQUFXckIsbUJBQW1CbEgsU0FBUztRQUNsRnpGLElBQUk7SUFDTjtJQUNBLElBQUl3RixRQUFRQyxRQUFRMEQsUUFBUTtRQUMxQixJQUFJcEosS0FBcUMsSUFBSSxDQUFFcXFCLENBQUFBLGtCQUFrQjNrQixtQkFBbUJteEIsOEJBQTZCLEdBQUk7WUFDbkg1MkIsSUFBSSxxQkFBcUIyM0IsYUFBYWx5QixVQUFVLDhCQUE4QiwwREFBMEQ7UUFDMUk7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsSUFBSTFGLEtBQXFDLElBQUksQ0FBQ3FCLE9BQU93MkIsWUFBWSxDQUFDbnlCLFNBQVM7UUFDekV6RixJQUFJO0lBQ047SUFDQSxJQUFJUixPQUFPLENBQUNrNEIsZ0JBQWdCMXBCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF4TyxJQUFJLEtBQUssT0FBT2s0QixnQkFBZ0IzM0IsS0FBcUMsR0FBRyxDQUFDa0QsY0FBY3dDLFVBQVUscUJBQXFCQSxPQUFPbEcsV0FBVyxDQUFDQyxJQUFJLElBQUksTUFBTTZDLGNBQWMsQ0FBa0I7SUFDdFAsSUFBSWtMLE1BQU0sSUFBSXFwQiwrQkFBK0JueEIsUUFBUSxJQUFJMG1CLE9BQU94ckIsT0FBT25CLE9BQU9nVix5QkFBeUJ4RztJQUN2R3RLLGNBQWMrQixRQUFRMEQsT0FBT29FO0lBQzdCLE9BQU85SDtBQUNUO0FBQ0EsSUFBSW95QixtQ0FBbUMsV0FBVyxHQUFFNXpCLDBCQUEwQixrQ0FBa0MyeUI7QUFDaEgsU0FBU1csa0NBQWtDcjRCLEdBQUc7SUFDNUMsT0FBT3czQixlQUFlLENBQUN4M0IsSUFBSSxJQUFLdzNCLENBQUFBLGVBQWUsQ0FBQ3gzQixJQUFJLEdBQUc7UUFDckR1TCxLQUFLLFNBQVNBO1lBQ1osT0FBTyxJQUFJLENBQUN0QixNQUFNLENBQUNzSSx1QkFBdUIsQ0FBQ3ZTO1FBQzdDO1FBQ0F5TCxLQUFLLFNBQVNBLElBQUk3SCxLQUFLO1lBQ3JCLE9BQU8sSUFBSSxDQUFDcUcsTUFBTSxDQUFDc0osdUJBQXVCLENBQUN2VCxLQUFLNEQ7UUFDbEQ7SUFDRjtBQUNGO0FBQ0EsU0FBUzZKLG1CQUFtQmpOLEtBQUs7SUFDL0IsSUFBSXNELFNBQVN0RCxRQUFRO1FBQ25CLE9BQU9tNEIsaUNBQWlDbjRCLEtBQUssQ0FBQ3lKLE1BQU07SUFDdEQ7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTZ3VCLHdCQUF3QjVwQixHQUFHLEVBQUVyRixVQUFVLEVBQUVoSixHQUFHO0lBQ25ELElBQUk0NEI7SUFDSixJQUFJLzNCLElBQXFDLEVBQUU7UUFDekN3TixJQUFJRSxtQkFBbUIsQ0FBQ3ZPLElBQUksR0FBR2dKO0lBQ2pDO0lBQ0EsZ0dBQWdHO0lBQy9GNHZCLENBQUFBLHdCQUF3QnZxQixJQUFJaUIsT0FBTyxDQUFDeEcsd0JBQXdCLEtBQUssUUFBUSxPQUFPOHZCLHFCQUFxQixDQUFDNTRCLElBQUk7QUFDN0c7QUFDQSxTQUFTODNCLGdCQUFnQnpwQixHQUFHLEVBQUVyRixVQUFVLEVBQUVoSixHQUFHO0lBQzNDLG1CQUFtQjtJQUNuQixJQUFJYSxLQUFxQyxJQUFJLENBQUNnM0IsYUFBYTd1QixhQUFhO1FBQ3RFbEksSUFBSSxzQkFBc0J1TixJQUFJbEUsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRLEtBQUs7SUFDL0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2QkEsR0FDQSxnQkFBZ0I7SUFDaEIsSUFBSVksS0FBcUMsSUFBSSxDQUFDd0ksV0FBV0wsZUFBZTFDLFFBQVErSCxJQUFJRSxtQkFBbUIsRUFBRXZPLE1BQU07UUFDN0csSUFBSXNKLFlBQVkrRSxJQUFJbEUsS0FBSyxHQUFHLE1BQU1uSyxJQUFJQyxRQUFRO1FBQzlDLElBQUl1Six3QkFBd0I2RSxJQUFJRSxtQkFBbUIsQ0FBQ3ZPLElBQUksQ0FBQ3lKLGVBQWU7UUFDeEUsSUFBSUMsMEJBQTBCVixXQUFXUyxlQUFlO1FBQ3hEM0ksSUFBSSxtQkFBbUI0SSwwQkFBMEIsV0FBV0osWUFBWSxPQUFRLDZDQUE0Q0Usd0JBQXdCLElBQUcsSUFBSywyQ0FBMkM7SUFDek07QUFDRjtBQUVBLHVEQUF1RDtBQUN2RCxJQUFJcXZCLFVBQVUsV0FBVyxHQUFFQywyQkFBMkI7QUFDdEQsSUFBSUMsc0NBQXNDLFdBQVcsR0FBRTtJQUNyRCxJQUFJaHNCLElBQUk7SUFDUixJQUFJaXNCLElBQUksQ0FBQztJQUNUOTJCLE9BQU9HLGNBQWMsQ0FBQzIyQixHQUFHLEtBQUs7UUFDNUJ2dEIsS0FBSyxTQUFTQTtZQUNac0IsSUFBSTtRQUNOO0lBQ0Y7SUFDQSxXQUFXLEdBQUU3SyxPQUFPa0csTUFBTSxDQUFDNHdCLEVBQUUsQ0FBQyxJQUFJLEdBQUc7SUFDckMsT0FBT2pzQixNQUFNO0FBQ2Y7QUFDQTs7OztDQUlDLEdBQ0QsSUFBSWtzQiwrQkFBK0I7QUFDbkMsbUVBQW1FO0FBQ25FLElBQUlDLFlBQVksU0FBU0EsYUFBYTtBQUN0QyxTQUFTQyxRQUFRQyxJQUFJLEVBQUVwMUIsS0FBSztJQUMxQixJQUFJOUIsT0FBT29HLGNBQWMsRUFBRTtRQUN6QnBHLE9BQU9vRyxjQUFjLENBQUM4d0IsS0FBSzcyQixTQUFTLEVBQUV5QjtJQUN4QyxPQUFPLElBQUlvMUIsS0FBSzcyQixTQUFTLENBQUNnRyxTQUFTLEtBQUs0RSxXQUFXO1FBQ2pEaXNCLEtBQUs3MkIsU0FBUyxDQUFDZ0csU0FBUyxHQUFHdkU7SUFDN0IsT0FBTztRQUNMbzFCLEtBQUs3MkIsU0FBUyxHQUFHeUI7SUFDbkI7QUFDRjtBQUNBbTFCLFFBQVFELFdBQVcvM0IsTUFBTW9CLFNBQVM7QUFDbEMseUNBQXlDO0FBQ3pDLDZFQUE2RTtBQUM3RSw4QkFBOEI7QUFDOUIsSUFBSTgyQix3QkFBd0IsV0FBVyxHQUFFLFNBQVVDLFVBQVU7SUFDM0QsU0FBU0Qsc0JBQXNCdmpCLGFBQWEsRUFBRS9DLFFBQVEsRUFBRXpTLElBQUksRUFBRXl4QixLQUFLO1FBQ2pFLElBQUlqWTtRQUNKLElBQUl4WixTQUFTLEtBQUssR0FBRztZQUNuQkEsT0FBT08sS0FBcUMsR0FBRyxxQkFBcUJzQyxjQUFjLENBQWlCO1FBQ3JHO1FBQ0EsSUFBSTR1QixVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUTtRQUNWO1FBQ0FqWSxRQUFRd2YsV0FBV2wxQixJQUFJLENBQUMsSUFBSSxLQUFLLElBQUk7UUFDckNrUyxlQUFlO1lBQ2IsSUFBSWpJLE1BQU0sSUFBSXloQiw4QkFBOEJ4dkIsTUFBTXlTLFVBQVVnZixPQUFPO1lBQ25FMWpCLElBQUkrQyxNQUFNLEdBQUcwSTtZQUNiaFYsbUJBQW1CZ1YsT0FBTzdQLE9BQU9vRTtZQUNqQyxJQUFJeUgsaUJBQWlCQSxjQUFjM1YsTUFBTSxFQUFFO2dCQUN6QyxhQUFhO2dCQUNiMlosTUFBTW1ZLGVBQWUsQ0FBQyxHQUFHLEdBQUduYztZQUM5QjtZQUNBLElBQUlpakIscUNBQXFDO2dCQUN2Qyx1RkFBdUY7Z0JBQ3ZGLHVGQUF1RjtnQkFDdkY3MkIsT0FBT0csY0FBYyxDQUFDeVgsT0FBTyxLQUFLK2U7WUFDcEM7UUFDRjtRQUNBLE9BQU8vZTtJQUNUO0lBQ0EzUixlQUFla3hCLHVCQUF1QkM7SUFDdEMsSUFBSXp1QixTQUFTd3VCLHNCQUFzQjkyQixTQUFTO0lBQzVDc0ksT0FBT2hGLE1BQU0sR0FBRyxTQUFTQTtRQUN2QixJQUFJLENBQUNvRSxNQUFNLENBQUNnbUIsS0FBSyxDQUFDaGxCLGNBQWM7UUFDaEMsSUFBSyxJQUFJakssT0FBT0MsVUFBVWQsTUFBTSxFQUFFbzVCLFNBQVMsSUFBSXA0QixNQUFNSCxPQUFPSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQVE7WUFDekZtNEIsTUFBTSxDQUFDbjRCLEtBQUssR0FBR0gsU0FBUyxDQUFDRyxLQUFLO1FBQ2hDO1FBQ0EsT0FBT0QsTUFBTW9CLFNBQVMsQ0FBQ3NELE1BQU0sQ0FBQ3ZFLEtBQUssQ0FBQyxJQUFJLENBQUNxSCxLQUFLLElBQzlDLFlBQVk7UUFDWjR3QixPQUFPLzNCLEdBQUcsQ0FBQyxTQUFVMkYsQ0FBQztZQUNwQixPQUFPdUcsa0JBQWtCdkcsS0FBS0EsRUFBRXdCLEtBQUssS0FBS3hCO1FBQzVDO0lBQ0Y7SUFDQTBELE1BQU0sQ0FBQ25ELE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ3hCLElBQUkzRixRQUFPLElBQUk7UUFDZixJQUFJdzNCLFlBQVk7UUFDaEIsT0FBT2hELGFBQWE7WUFDbEI1dUIsTUFBTSxTQUFTQTtnQkFDYixPQUFPNHhCLFlBQVl4M0IsTUFBSzdCLE1BQU0sR0FBRztvQkFDL0J5RCxPQUFPNUIsS0FBSSxDQUFDdzNCLFlBQVk7b0JBQ3hCeHhCLE1BQU07Z0JBQ1IsSUFBSTtvQkFDRkEsTUFBTTtvQkFDTnBFLE9BQU91SjtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU8zRixhQUFhNnhCLHVCQUF1QjtRQUFDO1lBQzFDcjVCLEtBQUs7WUFDTHVMLEtBQUssU0FBU0E7Z0JBQ1osT0FBTyxJQUFJLENBQUN0QixNQUFNLENBQUN5bEIsZUFBZTtZQUNwQztZQUNBamtCLEtBQUssU0FBU0EsSUFBSW1sQixTQUFTO2dCQUN6QixJQUFJLENBQUMzbUIsTUFBTSxDQUFDNGxCLGVBQWUsQ0FBQ2U7WUFDOUI7UUFDRjtRQUFHO1lBQ0Q1d0IsS0FBSzBILE9BQU82dUIsV0FBVztZQUN2QmhyQixLQUFLLFNBQVNBO2dCQUNaLE9BQU87WUFDVDtRQUNGO0tBQUU7QUFDSixFQUFFMnRCO0FBQ0ZoM0IsT0FBTzJwQixPQUFPLENBQUMrRCxpQkFBaUJqcEIsT0FBTyxDQUFDLFNBQVU4SixJQUFJO0lBQ3BELElBQUlqSyxPQUFPaUssSUFBSSxDQUFDLEVBQUUsRUFDaEIvTSxLQUFLK00sSUFBSSxDQUFDLEVBQUU7SUFDZCxJQUFJakssU0FBUyxVQUFVO1FBQ3JCaEMsY0FBYzYwQixzQkFBc0I5MkIsU0FBUyxFQUFFaUUsTUFBTTlDO0lBQ3ZEO0FBQ0Y7QUFDQSxTQUFTbzFCLDJCQUEyQjU0QixLQUFLO0lBQ3ZDLE9BQU87UUFDTHlFLFlBQVk7UUFDWkUsY0FBYztRQUNkMEcsS0FBSyxTQUFTQTtZQUNaLE9BQU8sSUFBSSxDQUFDdEIsTUFBTSxDQUFDbWlCLElBQUksQ0FBQ2xzQjtRQUMxQjtRQUNBdUwsS0FBSyxTQUFTQSxJQUFJN0gsS0FBSztZQUNyQixJQUFJLENBQUNxRyxNQUFNLENBQUM4aEIsSUFBSSxDQUFDN3JCLE9BQU8wRDtRQUMxQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTNjFCLHNCQUFzQnY1QixLQUFLO0lBQ2xDbUMsZUFBZWczQixzQkFBc0I5MkIsU0FBUyxFQUFFLEtBQUtyQyxPQUFPNDRCLDJCQUEyQjU0QjtBQUN6RjtBQUNBLFNBQVNpeEIsbUJBQW1CRyxHQUFHO0lBQzdCLElBQUlBLE1BQU0ySCw4QkFBOEI7UUFDdEMsSUFBSyxJQUFJLzRCLFFBQVErNEIsOEJBQThCLzRCLFFBQVFveEIsTUFBTSxLQUFLcHhCLFFBQVM7WUFDekV1NUIsc0JBQXNCdjVCO1FBQ3hCO1FBQ0ErNEIsK0JBQStCM0g7SUFDakM7QUFDRjtBQUNBSCxtQkFBbUI7QUFDbkIsU0FBU25iLGtCQUFrQkYsYUFBYSxFQUFFL0MsUUFBUSxFQUFFelMsSUFBSTtJQUN0RCxPQUFPLElBQUkrNEIsc0JBQXNCdmpCLGVBQWUvQyxVQUFVelM7QUFDNUQ7QUFFQSxTQUFTa29CLFFBQVFob0IsS0FBSyxFQUFFQyxRQUFRO0lBQzlCLElBQUksT0FBT0QsVUFBVSxZQUFZQSxVQUFVLE1BQU07UUFDL0MsSUFBSWtOLGtCQUFrQmxOLFFBQVE7WUFDNUIsSUFBSUMsYUFBYTBNLFdBQVc7Z0JBQzFCck0sSUFBSTtZQUNOO1lBQ0EsT0FBT04sS0FBSyxDQUFDeUosTUFBTSxDQUFDZ21CLEtBQUs7UUFDM0I7UUFDQSxJQUFJcmlCLGdCQUFnQnBOLFFBQVE7WUFDMUIsT0FBT0EsTUFBTXl2QixLQUFLO1FBQ3BCO1FBQ0EsSUFBSXRpQixnQkFBZ0JuTixRQUFRO1lBQzFCLElBQUlDLGFBQWEwTSxXQUFXO2dCQUMxQixPQUFPM00sTUFBTXV6QixTQUFTO1lBQ3hCO1lBQ0EsSUFBSTltQixhQUFhek0sTUFBTXF6QixLQUFLLENBQUN0b0IsR0FBRyxDQUFDOUssYUFBYUQsTUFBTXN6QixPQUFPLENBQUN2b0IsR0FBRyxDQUFDOUs7WUFDaEUsSUFBSSxDQUFDd00sWUFBWTtnQkFDZm5NLElBQUksSUFBSUwsVUFBVWc0QixhQUFhajRCO1lBQ2pDO1lBQ0EsT0FBT3lNO1FBQ1Q7UUFDQSxJQUFJUSxtQkFBbUJqTixRQUFRO1lBQzdCLElBQUksQ0FBQ0MsVUFBVTtnQkFDYixPQUFPSyxJQUFJO1lBQ2I7WUFDQSxJQUFJNDRCLGNBQWNsNUIsS0FBSyxDQUFDeUosTUFBTSxDQUFDb0ksT0FBTyxDQUFDOUcsR0FBRyxDQUFDOUs7WUFDM0MsSUFBSSxDQUFDaTVCLGFBQWE7Z0JBQ2hCNTRCLElBQUksSUFBSUwsVUFBVWc0QixhQUFhajRCO1lBQ2pDO1lBQ0EsT0FBT2s1QjtRQUNUO1FBQ0EsSUFBSTl0QixPQUFPcEwsVUFBVXNlLGdCQUFnQnRlLFVBQVVrbEIsV0FBV2xsQixRQUFRO1lBQ2hFLE9BQU9BO1FBQ1Q7SUFDRixPQUFPLElBQUlpRCxXQUFXakQsUUFBUTtRQUM1QixJQUFJa2xCLFdBQVdsbEIsS0FBSyxDQUFDeUosTUFBTSxHQUFHO1lBQzVCLG9CQUFvQjtZQUNwQixPQUFPekosS0FBSyxDQUFDeUosTUFBTTtRQUNyQjtJQUNGO0lBQ0FuSixJQUFJO0FBQ047QUFDQSxTQUFTb3FCLGtCQUFrQjFxQixLQUFLLEVBQUVDLFFBQVE7SUFDeEMsSUFBSSxDQUFDRCxPQUFPO1FBQ1ZNLElBQUk7SUFDTjtJQUNBLElBQUlMLGFBQWEwTSxXQUFXO1FBQzFCLE9BQU8rZCxrQkFBa0IxQyxRQUFRaG9CLE9BQU9DO0lBQzFDO0lBQ0EsSUFBSW1MLE9BQU9wTCxVQUFVc2UsZ0JBQWdCdGUsVUFBVWtsQixXQUFXbGxCLFFBQVE7UUFDaEUsT0FBT0E7SUFDVDtJQUNBLElBQUltTixnQkFBZ0JuTixVQUFVb04sZ0JBQWdCcE4sUUFBUTtRQUNwRCxPQUFPQTtJQUNUO0lBQ0EsSUFBSUEsS0FBSyxDQUFDeUosTUFBTSxFQUFFO1FBQ2hCLE9BQU96SixLQUFLLENBQUN5SixNQUFNO0lBQ3JCO0lBQ0FuSixJQUFJLElBQUlOO0FBQ1Y7QUFDQSxTQUFTaTRCLGFBQWFqNEIsS0FBSyxFQUFFQyxRQUFRO0lBQ25DLElBQUlrNUI7SUFDSixJQUFJbDVCLGFBQWEwTSxXQUFXO1FBQzFCd3NCLFFBQVFuUixRQUFRaG9CLE9BQU9DO0lBQ3pCLE9BQU8sSUFBSTJNLFNBQVM1TSxRQUFRO1FBQzFCLE9BQU9BLE1BQU1GLElBQUk7SUFDbkIsT0FBTyxJQUFJbU4sbUJBQW1Cak4sVUFBVW1OLGdCQUFnQm5OLFVBQVVvTixnQkFBZ0JwTixRQUFRO1FBQ3hGbTVCLFFBQVF6TyxrQkFBa0IxcUI7SUFDNUIsT0FBTztRQUNMLDJCQUEyQjtRQUMzQm01QixRQUFRblIsUUFBUWhvQjtJQUNsQjtJQUNBLE9BQU9tNUIsTUFBTXh2QixLQUFLO0FBQ3BCO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTbU0sZUFBZW1TLEVBQUU7SUFDeEIsSUFBSS9uQixhQUFhbVk7SUFDakIsSUFBSUQsb0JBQW9CRSx1QkFBdUI7SUFDL0MxTjtJQUNBLElBQUk7UUFDRixPQUFPcWQ7SUFDVCxTQUFVO1FBQ1JuZDtRQUNBK04scUJBQXFCVDtRQUNyQlcsYUFBYTdZO0lBQ2Y7QUFDRjtBQUVBLElBQUlULFdBQVdxQyxnQkFBZ0JyQyxRQUFRO0FBQ3ZDLFNBQVNxTSxVQUFVbkYsQ0FBQyxFQUFFaUYsQ0FBQyxFQUFFOFcsS0FBSztJQUM1QixJQUFJQSxVQUFVLEtBQUssR0FBRztRQUNwQkEsUUFBUSxDQUFDO0lBQ1g7SUFDQSxPQUFPMFcsR0FBR3p5QixHQUFHaUYsR0FBRzhXO0FBQ2xCO0FBQ0EsOEhBQThIO0FBQzlILHdHQUF3RztBQUN4RyxFQUFFO0FBQ0Ysd0RBQXdEO0FBQ3hELFNBQVMwVyxHQUFHenlCLENBQUMsRUFBRWlGLENBQUMsRUFBRThXLEtBQUssRUFBRTJXLE1BQU0sRUFBRUMsTUFBTTtJQUNyQyxzRUFBc0U7SUFDdEUsMEZBQTBGO0lBQzFGLElBQUkzeUIsTUFBTWlGLEdBQUc7UUFDWCxPQUFPakYsTUFBTSxLQUFLLElBQUlBLE1BQU0sSUFBSWlGO0lBQ2xDO0lBQ0Esa0VBQWtFO0lBQ2xFLElBQUlqRixLQUFLLFFBQVFpRixLQUFLLE1BQU07UUFDMUIsT0FBTztJQUNUO0lBQ0EsNENBQTRDO0lBQzVDLElBQUlqRixNQUFNQSxHQUFHO1FBQ1gsT0FBT2lGLE1BQU1BO0lBQ2Y7SUFDQSwyQkFBMkI7SUFDM0IsSUFBSWtNLE9BQU8sT0FBT25SO0lBQ2xCLElBQUltUixTQUFTLGNBQWNBLFNBQVMsWUFBWSxPQUFPbE0sS0FBSyxVQUFVO1FBQ3BFLE9BQU87SUFDVDtJQUNBLDZCQUE2QjtJQUM3QixJQUFJMnRCLFlBQVk5NUIsU0FBU21FLElBQUksQ0FBQytDO0lBQzlCLElBQUk0eUIsY0FBYzk1QixTQUFTbUUsSUFBSSxDQUFDZ0ksSUFBSTtRQUNsQyxPQUFPO0lBQ1Q7SUFDQSxPQUFRMnRCO1FBQ04sb0ZBQW9GO1FBQ3BGLEtBQUs7UUFDTCw2RUFBNkU7UUFDN0UsS0FBSztZQUNILG9GQUFvRjtZQUNwRixtQ0FBbUM7WUFDbkMsT0FBTyxLQUFLNXlCLE1BQU0sS0FBS2lGO1FBQ3pCLEtBQUs7WUFDSCw0Q0FBNEM7WUFDNUMsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ0EsR0FBRztnQkFDYixPQUFPLENBQUNpRixNQUFNLENBQUNBO1lBQ2pCO1lBQ0EsOERBQThEO1lBQzlELE9BQU8sQ0FBQ2pGLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSWlGLElBQUksQ0FBQ2pGLE1BQU0sQ0FBQ2lGO1FBQy9DLEtBQUs7UUFDTCxLQUFLO1lBQ0gscUZBQXFGO1lBQ3JGLHdGQUF3RjtZQUN4RiwrQkFBK0I7WUFDL0IsT0FBTyxDQUFDakYsTUFBTSxDQUFDaUY7UUFDakIsS0FBSztZQUNILE9BQU8sT0FBTzFFLFdBQVcsZUFBZUEsT0FBT2dVLE9BQU8sQ0FBQ3RYLElBQUksQ0FBQytDLE9BQU9PLE9BQU9nVSxPQUFPLENBQUN0WCxJQUFJLENBQUNnSTtRQUN6RixLQUFLO1FBQ0wsS0FBSztZQUNILG9GQUFvRjtZQUNwRixpREFBaUQ7WUFDakQsSUFBSThXLFNBQVMsR0FBRztnQkFDZEE7WUFDRjtZQUNBO0lBQ0o7SUFDQSw4QkFBOEI7SUFDOUIvYixJQUFJNnlCLE9BQU83eUI7SUFDWGlGLElBQUk0dEIsT0FBTzV0QjtJQUNYLElBQUk2dEIsWUFBWUYsY0FBYztJQUM5QixJQUFJLENBQUNFLFdBQVc7UUFDZCxJQUFJLE9BQU85eUIsS0FBSyxZQUFZLE9BQU9pRixLQUFLLFVBQVU7WUFDaEQsT0FBTztRQUNUO1FBQ0Esb0ZBQW9GO1FBQ3BGLDZCQUE2QjtRQUM3QixJQUFJOHRCLFFBQVEveUIsRUFBRTlHLFdBQVcsRUFDdkI4NUIsUUFBUS90QixFQUFFL0wsV0FBVztRQUN2QixJQUFJNjVCLFVBQVVDLFNBQVMsQ0FBRTEyQixDQUFBQSxXQUFXeTJCLFVBQVVBLGlCQUFpQkEsU0FBU3oyQixXQUFXMDJCLFVBQVVBLGlCQUFpQkEsS0FBSSxLQUFNLGlCQUFpQmh6QixLQUFLLGlCQUFpQmlGLEdBQUc7WUFDaEssT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJOFcsVUFBVSxHQUFHO1FBQ2YsT0FBTztJQUNULE9BQU8sSUFBSUEsUUFBUSxHQUFHO1FBQ3BCQSxRQUFRLENBQUM7SUFDWDtJQUNBLDRFQUE0RTtJQUM1RSw4RUFBOEU7SUFDOUUsMkNBQTJDO0lBQzNDLDRFQUE0RTtJQUM1RTJXLFNBQVNBLFVBQVUsRUFBRTtJQUNyQkMsU0FBU0EsVUFBVSxFQUFFO0lBQ3JCLElBQUkzNUIsU0FBUzA1QixPQUFPMTVCLE1BQU07SUFDMUIsTUFBT0EsU0FBVTtRQUNmLHdFQUF3RTtRQUN4RSw0QkFBNEI7UUFDNUIsSUFBSTA1QixNQUFNLENBQUMxNUIsT0FBTyxLQUFLZ0gsR0FBRztZQUN4QixPQUFPMnlCLE1BQU0sQ0FBQzM1QixPQUFPLEtBQUtpTTtRQUM1QjtJQUNGO0lBQ0EsMERBQTBEO0lBQzFEeXRCLE9BQU94WCxJQUFJLENBQUNsYjtJQUNaMnlCLE9BQU96WCxJQUFJLENBQUNqVztJQUNaLDBDQUEwQztJQUMxQyxJQUFJNnRCLFdBQVc7UUFDYix3RUFBd0U7UUFDeEU5NUIsU0FBU2dILEVBQUVoSCxNQUFNO1FBQ2pCLElBQUlBLFdBQVdpTSxFQUFFak0sTUFBTSxFQUFFO1lBQ3ZCLE9BQU87UUFDVDtRQUNBLDhEQUE4RDtRQUM5RCxNQUFPQSxTQUFVO1lBQ2YsSUFBSSxDQUFDeTVCLEdBQUd6eUIsQ0FBQyxDQUFDaEgsT0FBTyxFQUFFaU0sQ0FBQyxDQUFDak0sT0FBTyxFQUFFK2lCLFFBQVEsR0FBRzJXLFFBQVFDLFNBQVM7Z0JBQ3hELE9BQU87WUFDVDtRQUNGO0lBQ0YsT0FBTztRQUNMLHdCQUF3QjtRQUN4QixJQUFJbjBCLE9BQU96RCxPQUFPeUQsSUFBSSxDQUFDd0I7UUFDdkIsSUFBSWl6QixVQUFVejBCLEtBQUt4RixNQUFNO1FBQ3pCLGlHQUFpRztRQUNqRyxJQUFJK0IsT0FBT3lELElBQUksQ0FBQ3lHLEdBQUdqTSxNQUFNLEtBQUtpNkIsU0FBUztZQUNyQyxPQUFPO1FBQ1Q7UUFDQSxJQUFLLElBQUkzeEIsSUFBSSxHQUFHQSxJQUFJMnhCLFNBQVMzeEIsSUFBSztZQUNoQywyQkFBMkI7WUFDM0IsSUFBSXpJLE1BQU0yRixJQUFJLENBQUM4QyxFQUFFO1lBQ2pCLElBQUksQ0FBRW5DLENBQUFBLFFBQVE4RixHQUFHcE0sUUFBUTQ1QixHQUFHenlCLENBQUMsQ0FBQ25ILElBQUksRUFBRW9NLENBQUMsQ0FBQ3BNLElBQUksRUFBRWtqQixRQUFRLEdBQUcyVyxRQUFRQyxPQUFNLEdBQUk7Z0JBQ3ZFLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQSwrREFBK0Q7SUFDL0RELE9BQU96TSxHQUFHO0lBQ1YwTSxPQUFPMU0sR0FBRztJQUNWLE9BQU87QUFDVDtBQUNBLFNBQVM0TSxPQUFPN3lCLENBQUM7SUFDZixJQUFJdUcsa0JBQWtCdkcsSUFBSTtRQUN4QixPQUFPQSxFQUFFd0IsS0FBSztJQUNoQjtJQUNBLElBQUl6RCxTQUFTaUMsTUFBTXdHLGdCQUFnQnhHLElBQUk7UUFDckMsT0FBT2hHLE1BQU15SCxJQUFJLENBQUN6QixFQUFFMGtCLE9BQU87SUFDN0I7SUFDQSxJQUFJdG1CLFNBQVM0QixNQUFNeUcsZ0JBQWdCekcsSUFBSTtRQUNyQyxPQUFPaEcsTUFBTXlILElBQUksQ0FBQ3pCLEVBQUUwa0IsT0FBTztJQUM3QjtJQUNBLE9BQU8xa0I7QUFDVDtBQUVBLElBQUlrekI7QUFDSiw2Q0FBNkM7QUFDN0MsSUFBSUMseUJBQXlCLENBQUMsQ0FBQ0Qsc0JBQXNCLFdBQVcsR0FBRXo0QixZQUFZMjRCLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUYsb0JBQW9COTNCLFNBQVMsS0FBSyxDQUFDO0FBQzlJLFNBQVNpMEIsYUFBYTd1QixRQUFRO0lBQzVCQSxRQUFRLENBQUNELE9BQU9DLFFBQVEsQ0FBQyxHQUFHNnlCO0lBQzVCLE9BQU90NEIsT0FBT0QsTUFBTSxDQUFDQyxPQUFPa0csTUFBTSxDQUFDa3lCLHlCQUF5QjN5QjtBQUM5RDtBQUNBLFNBQVM2eUI7SUFDUCxPQUFPLElBQUk7QUFDYjtBQUVBLFNBQVMzQyxhQUFhcjNCLEtBQUs7SUFDekIsT0FDRSxrQkFBa0I7SUFDbEJBLGlCQUFpQjBCLFVBQVUsT0FBTzFCLE1BQU1pSixlQUFlLEtBQUssWUFBWWhHLFdBQVdqRCxNQUFNMk4sS0FBSyxLQUFLMUssV0FBV2pELE1BQU00TixPQUFPO0FBRS9IO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRDtJQUFDO0lBQVU7SUFBTztDQUFNLENBQUN6SCxPQUFPLENBQUMsU0FBVW1KLENBQUM7SUFDMUMsSUFBSTJxQixJQUFJNzRCO0lBQ1IsSUFBSSxPQUFPNjRCLENBQUMsQ0FBQzNxQixFQUFFLEtBQUssYUFBYTtRQUMvQmhQLElBQUksMkJBQTJCZ1AsSUFBSTtJQUNyQztBQUNGO0FBQ0EsSUFBSSxPQUFPNHFCLGtDQUFrQyxVQUFVO0lBQ3JELGlEQUFpRDtJQUNqREEsOEJBQThCQyxVQUFVLENBQUM7UUFDdkMzVSxLQUFLQTtRQUNMNFUsUUFBUTtZQUNObkMsY0FBY0E7UUFDaEI7UUFDQXh1QixPQUFPQTtJQUNUO0FBQ0Y7QUFFeXFDLENBQ3pxQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZlLW1lbW9yaWVzLy4vbm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmVzbS5qcz83ZWFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcbiAgLypcbiAgMihwcm9wKSB7XG4gICAgICByZXR1cm4gYGludmFsaWQgZGVjb3JhdG9yIGZvciAnJHtwcm9wLnRvU3RyaW5nKCl9J2BcbiAgfSxcbiAgMyhwcm9wKSB7XG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogYWN0aW9uIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuYFxuICB9LFxuICA0KHByb3ApIHtcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBjb21wdXRlZCBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlciBwcm9wZXJ0aWVzLmBcbiAgfSxcbiAgKi9cbiAgNTogXCIna2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDY6IFwiJ3ZhbHVlcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDc6IFwiJ2VudHJpZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA4OiBcIidzZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA5OiBcIidyZW1vdmUoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMDogXCInaGFzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTE6IFwiJ2dldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEyOiBcIkludmFsaWQgYW5ub3RhdGlvblwiLFxuICAxMzogXCJEeW5hbWljIG9ic2VydmFibGUgb2JqZWN0cyBjYW5ub3QgYmUgZnJvemVuLiBJZiB5b3UncmUgcGFzc2luZyBvYnNlcnZhYmxlcyB0byAzcmQgcGFydHkgY29tcG9uZW50L2Z1bmN0aW9uIHRoYXQgY2FsbHMgT2JqZWN0LmZyZWV6ZSwgcGFzcyBjb3B5IGluc3RlYWQ6IHRvSlMob2JzZXJ2YWJsZSlcIixcbiAgMTQ6IFwiSW50ZXJjZXB0IGhhbmRsZXJzIHNob3VsZCByZXR1cm4gbm90aGluZyBvciBhIGNoYW5nZSBvYmplY3RcIixcbiAgMTU6IFwiT2JzZXJ2YWJsZSBhcnJheXMgY2Fubm90IGJlIGZyb3plbi4gSWYgeW91J3JlIHBhc3Npbmcgb2JzZXJ2YWJsZXMgdG8gM3JkIHBhcnR5IGNvbXBvbmVudC9mdW5jdGlvbiB0aGF0IGNhbGxzIE9iamVjdC5mcmVlemUsIHBhc3MgY29weSBpbnN0ZWFkOiB0b0pTKG9ic2VydmFibGUpXCIsXG4gIDE2OiBcIk1vZGlmaWNhdGlvbiBleGNlcHRpb246IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgYW4gb2JzZXJ2YWJsZSBhcnJheSB3YXMgY2hhbmdlZC5cIixcbiAgMTc6IGZ1bmN0aW9uIF8oaW5kZXgsIGxlbmd0aCkge1xuICAgIHJldHVybiBcIlttb2J4LmFycmF5XSBJbmRleCBvdXQgb2YgYm91bmRzLCBcIiArIGluZGV4ICsgXCIgaXMgbGFyZ2VyIHRoYW4gXCIgKyBsZW5ndGg7XG4gIH0sXG4gIDE4OiBcIm1vYngubWFwIHJlcXVpcmVzIE1hcCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvbWFwLmpzXCIsXG4gIDE5OiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgZnJvbSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIE1hcDogXCIgKyBvdGhlci5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9LFxuICAyMDogZnVuY3Rpb24gXyhvdGhlcikge1xuICAgIHJldHVybiBcIkNhbm5vdCBpbml0aWFsaXplIG1hcCBmcm9tIFwiICsgb3RoZXI7XG4gIH0sXG4gIDIxOiBmdW5jdGlvbiBfKGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgY29udmVydCB0byBtYXAgZnJvbSAnXCIgKyBkYXRhU3RydWN0dXJlICsgXCInXCI7XG4gIH0sXG4gIDIyOiBcIm1vYnguc2V0IHJlcXVpcmVzIFNldCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvc2V0LmpzXCIsXG4gIDIzOiBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byBnZXQgaW5kZXggYXRvbXMgZnJvbSBhcnJheXNcIixcbiAgMjQ6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJDYW5ub3Qgb2J0YWluIGFkbWluaXN0cmF0aW9uIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjU6IGZ1bmN0aW9uIF8ocHJvcGVydHksIG5hbWUpIHtcbiAgICByZXR1cm4gXCJ0aGUgZW50cnkgJ1wiICsgcHJvcGVydHkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9ic2VydmFibGUgbWFwICdcIiArIG5hbWUgKyBcIidcIjtcbiAgfSxcbiAgMjY6IFwicGxlYXNlIHNwZWNpZnkgYSBwcm9wZXJ0eVwiLFxuICAyNzogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcIm5vIG9ic2VydmFibGUgcHJvcGVydHkgJ1wiICsgcHJvcGVydHkudG9TdHJpbmcoKSArIFwiJyBmb3VuZCBvbiB0aGUgb2JzZXJ2YWJsZSBvYmplY3QgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyODogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYXRvbSBmcm9tIFwiICsgdGhpbmc7XG4gIH0sXG4gIDI5OiBcIkV4cGVjdGluZyBzb21lIG9iamVjdFwiLFxuICAzMDogXCJpbnZhbGlkIGFjdGlvbiBzdGFjay4gZGlkIHlvdSBmb3JnZXQgdG8gZmluaXNoIGFuIGFjdGlvbj9cIixcbiAgMzE6IFwibWlzc2luZyBvcHRpb24gZm9yIGNvbXB1dGVkOiBnZXRcIixcbiAgMzI6IGZ1bmN0aW9uIF8obmFtZSwgZGVyaXZhdGlvbikge1xuICAgIHJldHVybiBcIkN5Y2xlIGRldGVjdGVkIGluIGNvbXB1dGF0aW9uIFwiICsgbmFtZSArIFwiOiBcIiArIGRlcml2YXRpb247XG4gIH0sXG4gIDMzOiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJUaGUgc2V0dGVyIG9mIGNvbXB1dGVkIHZhbHVlICdcIiArIG5hbWUgKyBcIicgaXMgdHJ5aW5nIHRvIHVwZGF0ZSBpdHNlbGYuIERpZCB5b3UgaW50ZW5kIHRvIHVwZGF0ZSBhbiBfb2JzZXJ2YWJsZV8gdmFsdWUsIGluc3RlYWQgb2YgdGhlIGNvbXB1dGVkIHByb3BlcnR5P1wiO1xuICB9LFxuICAzNDogZnVuY3Rpb24gXyhuYW1lKSB7XG4gICAgcmV0dXJuIFwiW0NvbXB1dGVkVmFsdWUgJ1wiICsgbmFtZSArIFwiJ10gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGFzc2lnbiBhIG5ldyB2YWx1ZSB0byBhIGNvbXB1dGVkIHZhbHVlLlwiO1xuICB9LFxuICAzNTogXCJUaGVyZSBhcmUgbXVsdGlwbGUsIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBNb2JYIGFjdGl2ZS4gTWFrZSBzdXJlIE1vYlggaXMgbG9hZGVkIG9ubHkgb25jZSBvciB1c2UgYGNvbmZpZ3VyZSh7IGlzb2xhdGVHbG9iYWxTdGF0ZTogdHJ1ZSB9KWBcIixcbiAgMzY6IFwiaXNvbGF0ZUdsb2JhbFN0YXRlIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIE1vYlggaXMgcnVubmluZyBhbnkgcmVhY3Rpb25zXCIsXG4gIDM3OiBmdW5jdGlvbiBfKG1ldGhvZCkge1xuICAgIHJldHVybiBcIlttb2J4XSBgb2JzZXJ2YWJsZUFycmF5LlwiICsgbWV0aG9kICsgXCIoKWAgbXV0YXRlcyB0aGUgYXJyYXkgaW4tcGxhY2UsIHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluc2lkZSBhIGRlcml2YXRpb24uIFVzZSBgYXJyYXkuc2xpY2UoKS5cIiArIG1ldGhvZCArIFwiKClgIGluc3RlYWRcIjtcbiAgfSxcbiAgMzg6IFwiJ293bktleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIixcbiAgMzk6IFwiJ2RlZmluZVByb3BlcnR5KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzXCJcbn07XG52YXIgZXJyb3JzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gbmljZUVycm9ycyA6IHt9O1xuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGUgPSB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBlcnJvciA6IGVycm9yc1tlcnJvcl07XG4gICAgaWYgKHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIpIGUgPSBlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIltNb2JYXSBcIiArIGUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcih0eXBlb2YgZXJyb3IgPT09IFwibnVtYmVyXCIgPyBcIltNb2JYXSBtaW5pZmllZCBlcnJvciBucjogXCIgKyBlcnJvciArIChhcmdzLmxlbmd0aCA/IFwiIFwiICsgYXJncy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9ibG9iL21haW4vcGFja2FnZXMvbW9ieC9zcmMvZXJyb3JzLnRzXCIgOiBcIltNb2JYXSBcIiArIGVycm9yKTtcbn1cblxudmFyIG1vY2tHbG9iYWwgPSB7fTtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICByZXR1cm4gbW9ja0dsb2JhbDtcbn1cblxuLy8gV2Ugc2hvcnRlbiBhbnl0aGluZyB1c2VkID4gNSB0aW1lc1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG52YXIgZ2V0RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xuT2JqZWN0LmZyZWV6ZShFTVBUWV9BUlJBWSk7XG52YXIgRU1QVFlfT0JKRUNUID0ge307XG5PYmplY3QuZnJlZXplKEVNUFRZX09CSkVDVCk7XG52YXIgaGFzUHJveHkgPSB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgcGxhaW5PYmplY3RTdHJpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBhc3NlcnRQcm94aWVzKCkge1xuICBpZiAoIWhhc1Byb3h5KSB7XG4gICAgZGllKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiYFByb3h5YCBvYmplY3RzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBQbGVhc2UgY29uZmlndXJlIE1vYlggdG8gZW5hYmxlIGEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24uYFwiIDogXCJQcm94eSBub3QgYXZhaWxhYmxlXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMpIHtcbiAgICBkaWUoXCJNb2JYIGlzIGN1cnJlbnRseSBjb25maWd1cmVkIHRvIGJlIGFibGUgdG8gcnVuIGluIEVTNSBtb2RlLCBidXQgaW4gRVM1IE1vYlggd29uJ3QgYmUgYWJsZSB0byBcIiArIG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgcmV0dXJuICsrZ2xvYmFsU3RhdGUubW9ieEd1aWQ7XG59XG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgaW52b2tlZCBhdCBtb3N0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICB2YXIgaW52b2tlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpbnZva2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludm9rZWQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdpc2godmFsdWUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcHJvdG9Db25zdHJ1Y3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIHByb3RvQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBwcm90b0NvbnN0cnVjdG9yLnRvU3RyaW5nKCkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3ODY1MTcwXG5mdW5jdGlvbiBpc0dlbmVyYXRvcihvYmopIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouY29uc3RydWN0b3I7XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IubmFtZSB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlbkZpbmFsUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKG5hbWUsIHRoZUNsYXNzKSB7XG4gIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xuICB0aGVDbGFzcy5wcm90b3R5cGVbcHJvcE5hbWVdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHhbcHJvcE5hbWVdID09PSB0cnVlO1xuICB9O1xufVxuLyoqXG4gKiBZaWVsZHMgdHJ1ZSBmb3IgYm90aCBuYXRpdmUgYW5kIG9ic2VydmFibGUgTWFwLCBldmVuIGFjcm9zcyBkaWZmZXJlbnQgd2luZG93cy5cbiAqL1xuZnVuY3Rpb24gaXNFUzZNYXAodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbn1cbi8qKlxuICogTWFrZXMgc3VyZSBhIE1hcCBpcyBhbiBpbnN0YW5jZSBvZiBub24taW5oZXJpdGVkIG5hdGl2ZSBvciBvYnNlcnZhYmxlIE1hcC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbkVTNk1hcCh0aGluZykge1xuICB2YXIgbWFwUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobWFwUHJvdG8pO1xuICB2YXIgbnVsbFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdFByb3RvKTtcbiAgcmV0dXJuIG51bGxQcm90byA9PT0gbnVsbDtcbn1cbi8qKlxuICogWWllbGRzIHRydWUgZm9yIGJvdGggbmF0aXZlIGFuZCBvYnNlcnZhYmxlIFNldCwgZXZlbiBhY3Jvc3MgZGlmZmVyZW50IHdpbmRvd3MuXG4gKi9cbmZ1bmN0aW9uIGlzRVM2U2V0KHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGluZykgPT09IFwiW29iamVjdCBTZXRdXCI7XG59XG52YXIgaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIGZvbGxvd2luZzogb3duIGVudW1lcmFibGUga2V5cyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0UGxhaW5PYmplY3RLZXlzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIC8vIE5vdCBzdXBwb3J0ZWQgaW4gSUUsIHNvIHRoZXJlIGFyZSBub3QgZ29pbmcgdG8gYmUgc3ltYm9sIHByb3BzIGFueXdheS4uLlxuICBpZiAoIWhhc0dldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICBpZiAoIXN5bWJvbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdChrZXlzLCBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBvYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHMpO1xuICB9KSk7XG59XG4vLyBGcm9tIEltbWVyIHV0aWxzXG4vLyBSZXR1cm5zIGFsbCBvd24ga2V5cywgaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xpY1xudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5mdW5jdGlvbiBzdHJpbmdpZnlLZXkoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgIHJldHVybiBrZXkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmluZyhrZXkpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBudWxsIDogdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gXCJcIiArIHZhbHVlIDogdmFsdWU7XG59XG5mdW5jdGlvbiBoYXNQcm9wKHRhcmdldCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKTtcbn1cbi8vIEZyb20gSW1tZXIgdXRpbHNcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTtcbiAgLy8gTm90ZTogd2l0aG91dCBwb2x5ZmlsbCBmb3Igb3duS2V5cywgc3ltYm9scyB3b24ndCBiZSBwaWNrZWQgdXBcbiAgb3duS2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZ2V0RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGdldEZsYWcoZmxhZ3MsIG1hc2spIHtcbiAgcmV0dXJuICEhKGZsYWdzICYgbWFzayk7XG59XG5mdW5jdGlvbiBzZXRGbGFnKGZsYWdzLCBtYXNrLCBuZXdWYWx1ZSkge1xuICBpZiAobmV3VmFsdWUpIHtcbiAgICBmbGFncyB8PSBtYXNrO1xuICB9IGVsc2Uge1xuICAgIGZsYWdzICY9IH5tYXNrO1xuICB9XG4gIHJldHVybiBmbGFncztcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyLCBlKSB7XG4gIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKHQpIHJldHVybiAodCA9IHQuY2FsbChyKSkubmV4dC5iaW5kKHQpO1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSkgfHwgZSAmJiByICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIHIubGVuZ3RoKSB7XG4gICAgdCAmJiAociA9IHQpO1xuICAgIHZhciBvID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG8gPj0gci5sZW5ndGggPyB7XG4gICAgICAgIGRvbmU6ICEwXG4gICAgICB9IDoge1xuICAgICAgICBkb25lOiAhMSxcbiAgICAgICAgdmFsdWU6IHJbbysrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2UodCwgbykge1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoby5wcm90b3R5cGUpLCB0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHQsIF9zZXRQcm90b3R5cGVPZih0LCBvKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieC1zdG9yZWQtYW5ub3RhdGlvbnNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXNcbiAqIC0gZGVjb3JhdG9yXG4gKiAtIGFubm90YXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChpczIwMjIzRGVjb3JhdG9yKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIGFubm90YXRpb24uZGVjb3JhdGVfMjAyMjNfKHRhcmdldCwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZUFubm90YXRpb24odGFyZ2V0LCBwcm9wZXJ0eSwgYW5ub3RhdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGRlY29yYXRvciwgYW5ub3RhdGlvbik7XG59XG4vKipcbiAqIFN0b3JlcyBhbm5vdGF0aW9uIHRvIHByb3RvdHlwZSxcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBzdG9yZUFubm90YXRpb24ocHJvdG90eXBlLCBrZXksIGFubm90YXRpb24pIHtcbiAgaWYgKCFoYXNQcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgYWRkSGlkZGVuUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sLCBfZXh0ZW5kcyh7fSwgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkpO1xuICB9XG4gIC8vIEBvdmVycmlkZSBtdXN0IG92ZXJyaWRlIHNvbWV0aGluZ1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgIWhhc1Byb3AocHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSwga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIGtleS50b1N0cmluZygpO1xuICAgIGRpZShcIidcIiArIGZpZWxkTmFtZSArIFwiJyBpcyBkZWNvcmF0ZWQgd2l0aCAnb3ZlcnJpZGUnLCBcIiArIFwiYnV0IG5vIHN1Y2ggZGVjb3JhdGVkIG1lbWJlciB3YXMgZm91bmQgb24gcHJvdG90eXBlLlwiKTtcbiAgfVxuICAvLyBDYW5ub3QgcmUtZGVjb3JhdGVcbiAgYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KTtcbiAgLy8gSWdub3JlIG92ZXJyaWRlXG4gIGlmICghaXNPdmVycmlkZShhbm5vdGF0aW9uKSkge1xuICAgIHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF1ba2V5XSA9IGFubm90YXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vdERlY29yYXRlZChwcm90b3R5cGUsIGFubm90YXRpb24sIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AocHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSwga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIGtleS50b1N0cmluZygpO1xuICAgIHZhciBjdXJyZW50QW5ub3RhdGlvblR5cGUgPSBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnQFwiICsgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsgZmllbGROYW1lICsgXCInOlwiICsgKFwiXFxuVGhlIGZpZWxkIGlzIGFscmVhZHkgZGVjb3JhdGVkIHdpdGggJ0BcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWRlY29yYXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ0BvdmVycmlkZScgZGVjb3JhdG9yIGZvciBtZXRob2RzIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG4vKipcbiAqIENvbGxlY3RzIGFubm90YXRpb25zIGZyb20gcHJvdG90eXBlcyBhbmQgc3RvcmVzIHRoZW0gb24gdGFyZ2V0IChpbnN0YW5jZSlcbiAqL1xuZnVuY3Rpb24gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCkge1xuICBpZiAoIWhhc1Byb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICAvLyBpZiAoX19ERVZfXyAmJiAhdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkge1xuICAgIC8vICAgICBkaWUoXG4gICAgLy8gICAgICAgICBgTm8gYW5ub3RhdGlvbnMgd2VyZSBwYXNzZWQgdG8gbWFrZU9ic2VydmFibGUsIGJ1dCBubyBkZWNvcmF0ZWQgbWVtYmVycyBoYXZlIGJlZW4gZm91bmQgZWl0aGVyYFxuICAgIC8vICAgICApXG4gICAgLy8gfVxuICAgIC8vIFdlIG5lZWQgYSBjb3B5IGFzIHdlIHdpbGwgcmVtb3ZlIGFubm90YXRpb24gZnJvbSB0aGUgbGlzdCBvbmNlIGl0J3MgYXBwbGllZC5cbiAgICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF07XG59XG5mdW5jdGlvbiBpczIwMjIzRGVjb3JhdG9yKGNvbnRleHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb250ZXh0ID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbnRleHRbXCJraW5kXCJdID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBhc3NlcnQyMDIyM0RlY29yYXRvclR5cGUoY29udGV4dCwgdHlwZXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhdHlwZXMuaW5jbHVkZXMoY29udGV4dC5raW5kKSkge1xuICAgIGRpZShcIlRoZSBkZWNvcmF0b3IgYXBwbGllZCB0byAnXCIgKyBTdHJpbmcoY29udGV4dC5uYW1lKSArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBhIFwiICsgY29udGV4dC5raW5kICsgXCIgZWxlbWVudFwiKTtcbiAgfVxufVxuXG52YXIgJG1vYnggPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieCBhZG1pbmlzdHJhdGlvblwiKTtcbnZhciBBdG9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBhdG9tLiBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGl0IGlzIHJlY29tbWVuZGVkIHRvIGdpdmUgaXQgYSBuYW1lLlxuICAgKiBUaGUgb25CZWNvbWVPYnNlcnZlZCBhbmQgb25CZWNvbWVVbm9ic2VydmVkIGNhbGxiYWNrcyBjYW4gYmUgdXNlZCBmb3IgcmVzb3VyY2UgbWFuYWdlbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIEF0b20obmFtZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkF0b21AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXRvbVwiO1xuICAgIH1cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhZ3NfID0gMDtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIC8vIG9uQmVjb21lT2JzZXJ2ZWRMaXN0ZW5lcnNcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIC8vIG9uQmVjb21lVW5vYnNlcnZlZExpc3RlbmVyc1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgfVxuICAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcbiAgdmFyIF9wcm90byA9IEF0b20ucHJvdG90eXBlO1xuICBfcHJvdG8ub25CTyA9IGZ1bmN0aW9uIG9uQk8oKSB7XG4gICAgaWYgKHRoaXMub25CT0wpIHtcbiAgICAgIHRoaXMub25CT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCB0byBub3RpZnkgbW9ieCB0aGF0IHlvdXIgYXRvbSBoYXMgYmVlbiB1c2VkIHNvbWVob3cuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSByZWFjdGl2ZSBjb250ZXh0LlxuICAgKi87XG4gIF9wcm90by5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkJDEoKSB7XG4gICAgcmV0dXJuIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBJbnZva2UgdGhpcyBtZXRob2QgX2FmdGVyXyB0aGlzIG1ldGhvZCBoYXMgY2hhbmdlZCB0byBzaWduYWwgbW9ieCB0aGF0IGFsbCBpdHMgb2JzZXJ2ZXJzIHNob3VsZCBpbnZhbGlkYXRlLlxuICAgKi87XG4gIF9wcm90by5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gcmVwb3J0Q2hhbmdlZCgpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgcHJvcGFnYXRlQ2hhbmdlZCh0aGlzKTtcbiAgICBlbmRCYXRjaCgpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdG9tLCBbe1xuICAgIGtleTogXCJpc0JlaW5nT2JzZXJ2ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBBdG9tLmlzQmVpbmdPYnNlcnZlZE1hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIEF0b20uaXNCZWluZ09ic2VydmVkTWFza18sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQZW5kaW5nVW5vYnNlcnZhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIEF0b20uaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIEF0b20uaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpZmZWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIEF0b20uZGlmZlZhbHVlTWFza18pID8gMSA6IDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBBdG9tLmRpZmZWYWx1ZU1hc2tfLCBuZXdWYWx1ZSA9PT0gMSA/IHRydWUgOiBmYWxzZSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5BdG9tLmlzQmVpbmdPYnNlcnZlZE1hc2tfID0gMTtcbkF0b20uaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfID0gMjtcbkF0b20uZGlmZlZhbHVlTWFza18gPSA0O1xudmFyIGlzQXRvbSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQXRvbVwiLCBBdG9tKTtcbmZ1bmN0aW9uIGNyZWF0ZUF0b20obmFtZSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIsIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpIHtcbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG4gIHZhciBhdG9tID0gbmV3IEF0b20obmFtZSk7XG4gIC8vIGRlZmF1bHQgYG5vb3BgIGxpc3RlbmVyIHdpbGwgbm90IGluaXRpYWxpemUgdGhlIGhvb2sgU2V0XG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIpO1xuICB9XG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkKGF0b20sIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpO1xuICB9XG4gIHJldHVybiBhdG9tO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUNvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBzdHJ1Y3R1cmFsQ29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xufVxuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCAxKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlcihhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzKGEsIGIpO1xuICB9XG4gIHJldHVybiBhID09PSBiID8gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGIgOiBhICE9PSBhICYmIGIgIT09IGI7XG59XG52YXIgY29tcGFyZXIgPSB7XG4gIGlkZW50aXR5OiBpZGVudGl0eUNvbXBhcmVyLFxuICBzdHJ1Y3R1cmFsOiBzdHJ1Y3R1cmFsQ29tcGFyZXIsXG4gIFwiZGVmYXVsdFwiOiBkZWZhdWx0Q29tcGFyZXIsXG4gIHNoYWxsb3c6IHNoYWxsb3dDb21wYXJlclxufTtcblxuZnVuY3Rpb24gZGVlcEVuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXG4gIGlmIChpc09ic2VydmFibGUodikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIGFuZCBtdXRhdGVkP1xuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNFUzZNYXAodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc0VTNlNldCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzQWN0aW9uKHYpICYmICFpc0Zsb3codikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IodikpIHtcbiAgICAgIHJldHVybiBmbG93KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXV0b0FjdGlvbihuYW1lLCB2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBzaGFsbG93RW5oYW5jZXIodiwgXywgbmFtZSkge1xuICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHYpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHYpIHx8IGlzT2JzZXJ2YWJsZU1hcCh2KSB8fCBpc09ic2VydmFibGVTZXQodikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZWVwOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIHVuZGVmaW5lZCwge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRlZXA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzRVM2TWFwKHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZWVwOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc0VTNlNldCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZGllKFwiVGhlIHNoYWxsb3cgbW9kaWZpZXIgLyBkZWNvcmF0b3IgY2FuIG9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGFycmF5cywgb2JqZWN0cywgbWFwcyBhbmQgc2V0c1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVmZXJlbmNlRW5oYW5jZXIobmV3VmFsdWUpIHtcbiAgLy8gbmV2ZXIgdHVybiBpbnRvIGFuIG9ic2VydmFibGVcbiAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gcmVmU3RydWN0RW5oYW5jZXIodiwgb2xkVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc09ic2VydmFibGUodikpIHtcbiAgICBkaWUoXCJvYnNlcnZhYmxlLnN0cnVjdCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCBvYnNlcnZhYmxlIHZhbHVlc1wiKTtcbiAgfVxuICBpZiAoZGVlcEVxdWFsKHYsIG9sZFZhbHVlKSkge1xuICAgIHJldHVybiBvbGRWYWx1ZTtcbiAgfVxuICByZXR1cm4gdjtcbn1cblxudmFyIE9WRVJSSURFID0gXCJvdmVycmlkZVwiO1xudmFyIG92ZXJyaWRlID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oe1xuICBhbm5vdGF0aW9uVHlwZV86IE9WRVJSSURFLFxuICBtYWtlXzogbWFrZV8sXG4gIGV4dGVuZF86IGV4dGVuZF8sXG4gIGRlY29yYXRlXzIwMjIzXzogZGVjb3JhdGVfMjAyMjNfXG59KTtcbmZ1bmN0aW9uIGlzT3ZlcnJpZGUoYW5ub3RhdGlvbikge1xuICByZXR1cm4gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8gPT09IE9WRVJSSURFO1xufVxuZnVuY3Rpb24gbWFrZV8oYWRtLCBrZXkpIHtcbiAgLy8gTXVzdCBub3QgYmUgcGxhaW4gb2JqZWN0XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYWRtLmlzUGxhaW5PYmplY3RfKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBwbGFpbiBvYmplY3RzLlwiKSk7XG4gIH1cbiAgLy8gTXVzdCBvdmVycmlkZSBzb21ldGhpbmdcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zXywga2V5KSkge1xuICAgIGRpZShcIidcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIicgaXMgYW5ub3RhdGVkIHdpdGggJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicsIFwiICsgXCJidXQgbm8gc3VjaCBhbm5vdGF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9XG4gIHJldHVybiAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGRpZShcIidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAnbWFrZU9ic2VydmFibGUnXCIpO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVfMjAyMjNfKGRlc2MsIGNvbnRleHQpIHtcbiAgY29uc29sZS53YXJuKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgd2l0aCBkZWNvcmF0b3JzIC0gdGhpcyBpcyBhIG5vLW9wXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDEsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQxLFxuICAgIGRlY29yYXRlXzIwMjIzXzogZGVjb3JhdGVfMjAyMjNfJDFcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VfJDEoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc187XG4gIC8vIGJvdW5kXG4gIGlmICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfLmJvdW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMCAvKiBNYWtlUmVzdWx0LkNhbmNlbCAqLyA6IDEgLyogTWFrZVJlc3VsdC5CcmVhayAqLztcbiAgfVxuICAvLyBvd25cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovIDogMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xuICB9XG4gIC8vIHByb3RvdHlwZVxuICBpZiAoaXNBY3Rpb24oZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAvLyBBIHByb3RvdHlwZSBjb3VsZCBoYXZlIGJlZW4gYW5ub3RhdGVkIGFscmVhZHkgYnkgb3RoZXIgY29uc3RydWN0b3IsXG4gICAgLy8gcmVzdCBvZiB0aGUgcHJvdG8gY2hhaW4gbXVzdCBiZSBhbm5vdGF0ZWQgYWxyZWFkeVxuICAgIHJldHVybiAxIC8qIE1ha2VSZXN1bHQuQnJlYWsgKi87XG4gIH1cbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBhY3Rpb25EZXNjcmlwdG9yKTtcbiAgcmV0dXJuIDIgLyogTWFrZVJlc3VsdC5Db250aW51ZSAqLztcbn1cbmZ1bmN0aW9uIGV4dGVuZF8kMShhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBhY3Rpb25EZXNjcmlwdG9yID0gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwgYWN0aW9uRGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlXzIwMjIzXyQxKG10aGQsIGNvbnRleHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGFzc2VydDIwMjIzRGVjb3JhdG9yVHlwZShjb250ZXh0LCBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXSk7XG4gIH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0LmtpbmQsXG4gICAgbmFtZSA9IGNvbnRleHQubmFtZSxcbiAgICBhZGRJbml0aWFsaXplciA9IGNvbnRleHQuYWRkSW5pdGlhbGl6ZXI7XG4gIHZhciBhbm4gPSB0aGlzO1xuICB2YXIgX2NyZWF0ZUFjdGlvbiA9IGZ1bmN0aW9uIF9jcmVhdGVBY3Rpb24obSkge1xuICAgIHZhciBfYW5uJG9wdGlvbnNfJG5hbWUsIF9hbm4kb3B0aW9uc18sIF9hbm4kb3B0aW9uc18kYXV0b0FjdCwgX2FubiRvcHRpb25zXzI7XG4gICAgcmV0dXJuIGNyZWF0ZUFjdGlvbigoX2FubiRvcHRpb25zXyRuYW1lID0gKF9hbm4kb3B0aW9uc18gPSBhbm4ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5uJG9wdGlvbnNfLm5hbWUpICE9IG51bGwgPyBfYW5uJG9wdGlvbnNfJG5hbWUgOiBuYW1lLnRvU3RyaW5nKCksIG0sIChfYW5uJG9wdGlvbnNfJGF1dG9BY3QgPSAoX2FubiRvcHRpb25zXzIgPSBhbm4ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5uJG9wdGlvbnNfMi5hdXRvQWN0aW9uKSAhPSBudWxsID8gX2FubiRvcHRpb25zXyRhdXRvQWN0IDogZmFsc2UpO1xuICB9O1xuICBpZiAoa2luZCA9PSBcImZpZWxkXCIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluaXRNdGhkKSB7XG4gICAgICB2YXIgX2FubiRvcHRpb25zXzM7XG4gICAgICB2YXIgbXRoZCA9IGluaXRNdGhkO1xuICAgICAgaWYgKCFpc0FjdGlvbihtdGhkKSkge1xuICAgICAgICBtdGhkID0gX2NyZWF0ZUFjdGlvbihtdGhkKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2FubiRvcHRpb25zXzMgPSBhbm4ub3B0aW9uc18pICE9IG51bGwgJiYgX2FubiRvcHRpb25zXzMuYm91bmQpIHtcbiAgICAgICAgbXRoZCA9IG10aGQuYmluZCh0aGlzKTtcbiAgICAgICAgbXRoZC5pc01vYnhBY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG10aGQ7XG4gICAgfTtcbiAgfVxuICBpZiAoa2luZCA9PSBcIm1ldGhvZFwiKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnNfMjtcbiAgICBpZiAoIWlzQWN0aW9uKG10aGQpKSB7XG4gICAgICBtdGhkID0gX2NyZWF0ZUFjdGlvbihtdGhkKTtcbiAgICB9XG4gICAgaWYgKChfdGhpcyRvcHRpb25zXzIgPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfMi5ib3VuZCkge1xuICAgICAgYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZCA9IHNlbGZbbmFtZV0uYmluZChzZWxmKTtcbiAgICAgICAgYm91bmQuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgc2VsZltuYW1lXSA9IGJvdW5kO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtdGhkO1xuICB9XG4gIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm4uYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIFN0cmluZyhuYW1lKSArIFwiJyAoa2luZDogXCIgKyBraW5kICsgXCIpOlwiICsgKFwiXFxuJ1wiICsgYW5uLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGZ1bmN0aW9uIHZhbHVlLlwiKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBY3Rpb25EZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGZ1bmN0aW9uIHZhbHVlLlwiKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsXG4vLyBwcm92aWRlcyBhYmlsaXR5IHRvIGRpc2FibGUgc2FmZURlc2NyaXB0b3JzIGZvciBwcm90b3R5cGVzXG5zYWZlRGVzY3JpcHRvcnMpIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfMiwgX2Fubm90YXRpb24kb3B0aW9uc18kMiwgX2Fubm90YXRpb24kb3B0aW9uc18zLCBfYW5ub3RhdGlvbiRvcHRpb25zXzQsIF9hZG0kcHJveHlfMjtcbiAgaWYgKHNhZmVEZXNjcmlwdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgc2FmZURlc2NyaXB0b3JzID0gZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzO1xuICB9XG4gIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IpO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICBpZiAoKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgIT0gbnVsbCAmJiBfYW5ub3RhdGlvbiRvcHRpb25zXy5ib3VuZCkge1xuICAgIHZhciBfYWRtJHByb3h5XztcbiAgICB2YWx1ZSA9IHZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGNyZWF0ZUFjdGlvbigoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMiA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzIubmFtZSkgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA6IGtleS50b1N0cmluZygpLCB2YWx1ZSwgKF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgPSAoX2Fubm90YXRpb24kb3B0aW9uc18zID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMy5hdXRvQWN0aW9uKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kMiA6IGZhbHNlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9kaXNjdXNzaW9ucy8zMTQwXG4gICAgKF9hbm5vdGF0aW9uJG9wdGlvbnNfNCA9IGFubm90YXRpb24ub3B0aW9uc18pICE9IG51bGwgJiYgX2Fubm90YXRpb24kb3B0aW9uc180LmJvdW5kID8gKF9hZG0kcHJveHlfMiA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XzIgOiBhZG0udGFyZ2V0XyA6IHVuZGVmaW5lZCksXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmxvd0Fubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMixcbiAgICBleHRlbmRfOiBleHRlbmRfJDIsXG4gICAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM18kMlxuICB9O1xufVxuZnVuY3Rpb24gbWFrZV8kMihhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXztcbiAgLy8gb3duXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMCAvKiBNYWtlUmVzdWx0LkNhbmNlbCAqLyA6IDIgLyogTWFrZVJlc3VsdC5Db250aW51ZSAqLztcbiAgfVxuICAvLyBwcm90b3R5cGVcbiAgLy8gYm91bmQgLSBtdXN0IGFubm90YXRlIHByb3RvcyB0byBzdXBwb3J0IHN1cGVyLmZsb3coKVxuICBpZiAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXy5ib3VuZCAmJiAoIWhhc1Byb3AoYWRtLnRhcmdldF8sIGtleSkgfHwgIWlzRmxvdyhhZG0udGFyZ2V0X1trZXldKSkpIHtcbiAgICBpZiAodGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwIC8qIE1ha2VSZXN1bHQuQ2FuY2VsICovO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGbG93KGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMSAvKiBNYWtlUmVzdWx0LkJyZWFrICovO1xuICB9XG4gIHZhciBmbG93RGVzY3JpcHRvciA9IGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSwgZmFsc2UpO1xuICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgZmxvd0Rlc2NyaXB0b3IpO1xuICByZXR1cm4gMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMjtcbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIChfdGhpcyRvcHRpb25zXzIgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18yLmJvdW5kKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBmbG93RGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlXzIwMjIzXyQyKG10aGQsIGNvbnRleHQpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGFzc2VydDIwMjIzRGVjb3JhdG9yVHlwZShjb250ZXh0LCBbXCJtZXRob2RcIl0pO1xuICB9XG4gIHZhciBuYW1lID0gY29udGV4dC5uYW1lLFxuICAgIGFkZEluaXRpYWxpemVyID0gY29udGV4dC5hZGRJbml0aWFsaXplcjtcbiAgaWYgKCFpc0Zsb3cobXRoZCkpIHtcbiAgICBtdGhkID0gZmxvdyhtdGhkKTtcbiAgfVxuICBpZiAoKF90aGlzJG9wdGlvbnNfMyA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18zLmJvdW5kKSB7XG4gICAgYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGJvdW5kID0gc2VsZltuYW1lXS5iaW5kKHNlbGYpO1xuICAgICAgYm91bmQuaXNNb2JYRmxvdyA9IHRydWU7XG4gICAgICBzZWxmW25hbWVdID0gYm91bmQ7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG10aGQ7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBnZW5lcmF0b3IgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIGJvdW5kLFxuLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuICBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gIC8vIEluIGNhc2Ugb2YgZmxvdy5ib3VuZCwgdGhlIGRlc2NyaXB0b3IgY2FuIGJlIGZyb20gYWxyZWFkeSBhbm5vdGF0ZWQgcHJvdG90eXBlXG4gIGlmICghaXNGbG93KHZhbHVlKSkge1xuICAgIHZhbHVlID0gZmxvdyh2YWx1ZSk7XG4gIH1cbiAgaWYgKGJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuICAgIC8vIFdlIGRvIG5vdCBrZWVwIG9yaWdpbmFsIGZ1bmN0aW9uIGFyb3VuZCwgc28gd2UgYmluZCB0aGUgZXhpc3RpbmcgZmxvd1xuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gICAgLy8gVGhpcyBpcyBub3JtYWxseSBzZXQgYnkgYGZsb3dgLCBidXQgYGJpbmRgIHJldHVybnMgbmV3IGZ1bmN0aW9uLi4uXG4gICAgdmFsdWUuaXNNb2JYRmxvdyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDMsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQzLFxuICAgIGRlY29yYXRlXzIwMjIzXzogZGVjb3JhdGVfMjAyMjNfJDNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VfJDMoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMCAvKiBNYWtlUmVzdWx0LkNhbmNlbCAqLyA6IDEgLyogTWFrZVJlc3VsdC5CcmVhayAqLztcbn1cbmZ1bmN0aW9uIGV4dGVuZF8kMyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zXywge1xuICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgc2V0OiBkZXNjcmlwdG9yLnNldFxuICB9KSwgcHJveHlUcmFwKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlXzIwMjIzXyQzKGdldCwgY29udGV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYXNzZXJ0MjAyMjNEZWNvcmF0b3JUeXBlKGNvbnRleHQsIFtcImdldHRlclwiXSk7XG4gIH1cbiAgdmFyIGFubiA9IHRoaXM7XG4gIHZhciBrZXkgPSBjb250ZXh0Lm5hbWUsXG4gICAgYWRkSW5pdGlhbGl6ZXIgPSBjb250ZXh0LmFkZEluaXRpYWxpemVyO1xuICBhZGRJbml0aWFsaXplcihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0aGlzKVskbW9ieF07XG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgYW5uLm9wdGlvbnNfLCB7XG4gICAgICBnZXQ6IGdldCxcbiAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICB9KTtcbiAgICBvcHRpb25zLm5hbWUgfHwgKG9wdGlvbnMubmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3QuXCIgKyBrZXkudG9TdHJpbmcoKSk7XG4gICAgYWRtLnZhbHVlc18uc2V0KGtleSwgbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucykpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgZ2V0ID0gX3JlZjIuZ2V0O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFnZXQpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIoK3NldHRlcikgcHJvcGVydGllcy5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDQsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQ0LFxuICAgIGRlY29yYXRlXzIwMjIzXzogZGVjb3JhdGVfMjAyMjNfJDRcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMCAvKiBNYWtlUmVzdWx0LkNhbmNlbCAqLyA6IDEgLyogTWFrZVJlc3VsdC5CcmVhayAqLztcbn1cbmZ1bmN0aW9uIGV4dGVuZF8kNChhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXyRlbmhhbmMsIF90aGlzJG9wdGlvbnNfO1xuICBhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IudmFsdWUsIChfdGhpcyRvcHRpb25zXyRlbmhhbmMgPSAoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uZW5oYW5jZXIpICE9IG51bGwgPyBfdGhpcyRvcHRpb25zXyRlbmhhbmMgOiBkZWVwRW5oYW5jZXIsIHByb3h5VHJhcCk7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZV8yMDIyM18kNChkZXNjLCBjb250ZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29udGV4dC5raW5kID09PSBcImZpZWxkXCIpIHtcbiAgICAgIHRocm93IGRpZShcIlBsZWFzZSB1c2UgYEBvYnNlcnZhYmxlIGFjY2Vzc29yIFwiICsgU3RyaW5nKGNvbnRleHQubmFtZSkgKyBcImAgaW5zdGVhZCBvZiBgQG9ic2VydmFibGUgXCIgKyBTdHJpbmcoY29udGV4dC5uYW1lKSArIFwiYFwiKTtcbiAgICB9XG4gICAgYXNzZXJ0MjAyMjNEZWNvcmF0b3JUeXBlKGNvbnRleHQsIFtcImFjY2Vzc29yXCJdKTtcbiAgfVxuICB2YXIgYW5uID0gdGhpcztcbiAgdmFyIGtpbmQgPSBjb250ZXh0LmtpbmQsXG4gICAgbmFtZSA9IGNvbnRleHQubmFtZTtcbiAgLy8gVGhlIGxhemluZXNzIGhlcmUgaXMgbm90IGlkZWFsLi4uIEl0J3MgYSB3b3JrYXJvdW5kIHRvIGhvdyAyMDIyLjMgRGVjb3JhdG9ycyBhcmUgaW1wbGVtZW50ZWQ6XG4gIC8vICAgYGFkZEluaXRpYWxpemVyYCBjYWxsYmFja3MgYXJlIGV4ZWN1dGVkIF9iZWZvcmVfIGFueSBhY2Nlc3NvcnMgYXJlIGRlZmluZWQgKGluc3RlYWQgb2YgdGhlIGlkZWFsLWZvci11cyByaWdodCBhZnRlciBlYWNoKS5cbiAgLy8gICBUaGlzIG1lYW5zIHRoYXQsIGlmIHdlIHdlcmUgdG8gZG8gb3VyIHN0dWZmIGluIGFuIGBhZGRJbml0aWFsaXplcmAsIHdlJ2QgYXR0ZW1wdCB0byByZWFkIGEgcHJpdmF0ZSBzbG90XG4gIC8vICAgYmVmb3JlIGl0IGhhcyBiZWVuIGluaXRpYWxpemVkLiBUaGUgcnVudGltZSBkb2Vzbid0IGxpa2UgdGhhdCBhbmQgdGhyb3dzIGEgYENhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyXG4gIC8vICAgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0YCBlcnJvci5cbiAgLy8gVE9ETzogaXQgc2VlbXMgdGhhdCB0aGlzIHdpbGwgbm90IGJlIHJlcXVpcmVkIGFueW1vcmUgaW4gdGhlIGZpbmFsIHZlcnNpb24gb2YgdGhlIHNwZWNcbiAgLy8gU2VlIFRPRE86IGxpbmtcbiAgdmFyIGluaXRpYWxpemVkT2JqZWN0cyA9IG5ldyBXZWFrU2V0KCk7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemVPYnNlcnZhYmxlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgX2FubiRvcHRpb25zXyRlbmhhbmNlLCBfYW5uJG9wdGlvbnNfO1xuICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0KVskbW9ieF07XG4gICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCAoX2FubiRvcHRpb25zXyRlbmhhbmNlID0gKF9hbm4kb3B0aW9uc18gPSBhbm4ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2FubiRvcHRpb25zXyRlbmhhbmNlIDogZGVlcEVuaGFuY2VyLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBhZG0ubmFtZV8gKyBcIi5cIiArIG5hbWUudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5cIiArIG5hbWUudG9TdHJpbmcoKSwgZmFsc2UpO1xuICAgIGFkbS52YWx1ZXNfLnNldChuYW1lLCBvYnNlcnZhYmxlKTtcbiAgICBpbml0aWFsaXplZE9iamVjdHMuYWRkKHRhcmdldCk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIWluaXRpYWxpemVkT2JqZWN0cy5oYXModGhpcykpIHtcbiAgICAgICAgICBpbml0aWFsaXplT2JzZXJ2YWJsZSh0aGlzLCBkZXNjLmdldC5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8obmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsaXplZE9iamVjdHMuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZU9ic2VydmFibGUodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhuYW1lLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWluaXRpYWxpemVkT2JqZWN0cy5oYXModGhpcykpIHtcbiAgICAgICAgICBpbml0aWFsaXplT2JzZXJ2YWJsZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIGdldHRlci9zZXR0ZXIgcHJvcGVydGllc1wiKSk7XG4gIH1cbn1cblxudmFyIEFVVE8gPSBcInRydWVcIjtcbnZhciBhdXRvQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdXRvQW5ub3RhdGlvbigpO1xuZnVuY3Rpb24gY3JlYXRlQXV0b0Fubm90YXRpb24ob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogQVVUTyxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDUsXG4gICAgZGVjb3JhdGVfMjAyMjNfOiBkZWNvcmF0ZV8yMDIyM18kNVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZV8kNShhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzMsIF90aGlzJG9wdGlvbnNfNDtcbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfVxuICAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG4gIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgIC8vIFRPRE8gbWFrZSBhY3Rpb24gYXBwbGljYWJsZSB0byBzZXR0ZXIgYW5kIGRlbGVnYXRlIHRvIGFjdGlvbi5tYWtlX1xuICAgIHZhciBzZXQgPSBjcmVhdGVBY3Rpb24oa2V5LnRvU3RyaW5nKCksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAvLyBvd25cbiAgICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgICAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXRcbiAgICAgIH0pID09PSBudWxsID8gMCAvKiBNYWtlUmVzdWx0LkNhbmNlbCAqLyA6IDIgLyogTWFrZVJlc3VsdC5Db250aW51ZSAqLztcbiAgICB9XG4gICAgLy8gcHJvdG9cbiAgICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiBzZXRcbiAgICB9KTtcbiAgICByZXR1cm4gMiAvKiBNYWtlUmVzdWx0LkNvbnRpbnVlICovO1xuICB9XG4gIC8vIGZ1bmN0aW9uIG9uIHByb3RvIC0+IGF1dG9BY3Rpb24vZmxvd1xuICBpZiAoc291cmNlICE9PSBhZG0udGFyZ2V0XyAmJiB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnNfMjtcbiAgICBpZiAoaXNHZW5lcmF0b3IoZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zXztcbiAgICAgIHZhciBmbG93QW5ub3RhdGlvbiA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18uYXV0b0JpbmQgPyBmbG93LmJvdW5kIDogZmxvdztcbiAgICAgIHJldHVybiBmbG93QW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgICB9XG4gICAgdmFyIGFjdGlvbkFubm90YXRpb24gPSAoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzIuYXV0b0JpbmQgPyBhdXRvQWN0aW9uLmJvdW5kIDogYXV0b0FjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfVxuICAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIENvcHkgcHJvcHMgZnJvbSBwcm90byBhcyB3ZWxsLCBzZWUgdGVzdDpcbiAgLy8gXCJkZWNvcmF0ZSBzaG91bGQgd29yayB3aXRoIE9iamVjdC5jcmVhdGVcIlxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfMyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzMuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlO1xuICAvLyBpZiBmdW5jdGlvbiByZXNwZWN0IGF1dG9CaW5kIG9wdGlvblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoX3RoaXMkb3B0aW9uc180ID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzQuYXV0b0JpbmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cbiAgcmV0dXJuIG9ic2VydmFibGVBbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xufVxuZnVuY3Rpb24gZXh0ZW5kXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfNSwgX3RoaXMkb3B0aW9uc182O1xuICAvLyBnZXR0ZXIgLT4gY29tcHV0ZWRcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG4gIH1cbiAgLy8gbG9uZSBzZXR0ZXIgLT4gYWN0aW9uIHNldHRlclxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24uZXh0ZW5kX1xuICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgc2V0OiBjcmVhdGVBY3Rpb24oa2V5LnRvU3RyaW5nKCksIGRlc2NyaXB0b3Iuc2V0KVxuICAgIH0sIHByb3h5VHJhcCk7XG4gIH1cbiAgLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBpZiBmdW5jdGlvbiByZXNwZWN0IGF1dG9CaW5kIG9wdGlvblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoX3RoaXMkb3B0aW9uc181ID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzUuYXV0b0JpbmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV8yO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfMiA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XzIgOiBhZG0udGFyZ2V0Xyk7XG4gIH1cbiAgdmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzYgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc182LmRlZXApID09PSBmYWxzZSA/IG9ic2VydmFibGUucmVmIDogb2JzZXJ2YWJsZTtcbiAgcmV0dXJuIG9ic2VydmFibGVBbm5vdGF0aW9uLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZV8yMDIyM18kNShkZXNjLCBjb250ZXh0KSB7XG4gIGRpZShcIidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIGFzIGEgZGVjb3JhdG9yXCIpO1xufVxuXG52YXIgT0JTRVJWQUJMRSA9IFwib2JzZXJ2YWJsZVwiO1xudmFyIE9CU0VSVkFCTEVfUkVGID0gXCJvYnNlcnZhYmxlLnJlZlwiO1xudmFyIE9CU0VSVkFCTEVfU0hBTExPVyA9IFwib2JzZXJ2YWJsZS5zaGFsbG93XCI7XG52YXIgT0JTRVJWQUJMRV9TVFJVQ1QgPSBcIm9ic2VydmFibGUuc3RydWN0XCI7XG4vLyBQcmVkZWZpbmVkIGJhZ3Mgb2YgY3JlYXRlIG9ic2VydmFibGUgb3B0aW9ucywgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcmlseSBvcHRpb24gb2JqZWN0c1xuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG52YXIgZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zID0ge1xuICBkZWVwOiB0cnVlLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIGRlZmF1bHREZWNvcmF0b3I6IHVuZGVmaW5lZCxcbiAgcHJveHk6IHRydWVcbn07XG5PYmplY3QuZnJlZXplKGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyk7XG5mdW5jdGlvbiBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyB8fCBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnM7XG59XG52YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRSk7XG52YXIgb2JzZXJ2YWJsZVJlZkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9SRUYsIHtcbiAgZW5oYW5jZXI6IHJlZmVyZW5jZUVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TSEFMTE9XLCB7XG4gIGVuaGFuY2VyOiBzaGFsbG93RW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEVfU1RSVUNULCB7XG4gIGVuaGFuY2VyOiByZWZTdHJ1Y3RFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZGVlcCA9PT0gdHJ1ZSA/IGRlZXBFbmhhbmNlciA6IG9wdGlvbnMuZGVlcCA9PT0gZmFsc2UgPyByZWZlcmVuY2VFbmhhbmNlciA6IGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24ob3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRkZWZhdWx0RGVjb3I7XG4gIHJldHVybiBvcHRpb25zID8gKF9vcHRpb25zJGRlZmF1bHREZWNvciA9IG9wdGlvbnMuZGVmYXVsdERlY29yYXRvcikgIT0gbnVsbCA/IF9vcHRpb25zJGRlZmF1bHREZWNvciA6IGNyZWF0ZUF1dG9Bbm5vdGF0aW9uKG9wdGlvbnMpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIHZhciBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfO1xuICByZXR1cm4gIWFubm90YXRpb24gPyBkZWVwRW5oYW5jZXIgOiAoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDogZGVlcEVuaGFuY2VyO1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3QsIGFycmF5IG9yIGZ1bmN0aW9uIGludG8gYSByZWFjdGl2ZSBzdHJ1Y3R1cmUuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgd2hpY2ggc2hvdWxkIGJlY29tZSBvYnNlcnZhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHYsIGFyZzIsIGFyZzMpIHtcbiAgLy8gQG9ic2VydmFibGUgc29tZVByb3A7ICgyMDIyLjMgRGVjb3JhdG9ycylcbiAgaWYgKGlzMjAyMjNEZWNvcmF0b3IoYXJnMikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24uZGVjb3JhdGVfMjAyMjNfKHYsIGFyZzIpO1xuICB9XG4gIC8vIEBvYnNlcnZhYmxlIHNvbWVQcm9wO1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICBzdG9yZUFubm90YXRpb24odiwgYXJnMiwgb2JzZXJ2YWJsZUFubm90YXRpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhbHJlYWR5IG9ic2VydmFibGUgLSBpZ25vcmVcbiAgaWYgKGlzT2JzZXJ2YWJsZSh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIC8vIHBsYWluIG9iamVjdFxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKTtcbiAgfVxuICAvLyBBcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIGFyZzIpO1xuICB9XG4gIC8vIE1hcFxuICBpZiAoaXNFUzZNYXAodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwgYXJnMik7XG4gIH1cbiAgLy8gU2V0XG4gIGlmIChpc0VTNlNldCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCBhcmcyKTtcbiAgfVxuICAvLyBvdGhlciBvYmplY3QgLSBpZ25vcmVcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICAvLyBhbnl0aGluZyBlbHNlXG4gIHJldHVybiBvYnNlcnZhYmxlLmJveCh2LCBhcmcyKTtcbn1cbmFzc2lnbihjcmVhdGVPYnNlcnZhYmxlLCBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbik7XG52YXIgb2JzZXJ2YWJsZUZhY3RvcmllcyA9IHtcbiAgYm94OiBmdW5jdGlvbiBib3godmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSwgdHJ1ZSwgby5lcXVhbHMpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gKGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPT09IGZhbHNlIHx8IG8ucHJveHkgPT09IGZhbHNlID8gY3JlYXRlTGVnYWN5QXJyYXkgOiBjcmVhdGVPYnNlcnZhYmxlQXJyYXkpKGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIG1hcDogZnVuY3Rpb24gbWFwKGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlTWFwKGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU2V0KGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHByb3BzLCBkZWNvcmF0b3JzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluaXRPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPT09IGZhbHNlIHx8IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByb3h5KSA9PT0gZmFsc2UgPyBhc09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpIDogYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh7fSwgb3B0aW9ucyksIHByb3BzLCBkZWNvcmF0b3JzKTtcbiAgICB9KTtcbiAgfSxcbiAgcmVmOiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiksXG4gIHNoYWxsb3c6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiksXG4gIGRlZXA6IG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uLFxuICBzdHJ1Y3Q6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uKVxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIG9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVGYWN0b3JpZXMpO1xuXG52YXIgQ09NUFVURUQgPSBcImNvbXB1dGVkXCI7XG52YXIgQ09NUFVURURfU1RSVUNUID0gXCJjb21wdXRlZC5zdHJ1Y3RcIjtcbnZhciBjb21wdXRlZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEKTtcbnZhciBjb21wdXRlZFN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEX1NUUlVDVCwge1xuICBlcXVhbHM6IGNvbXBhcmVyLnN0cnVjdHVyYWxcbn0pO1xuLyoqXG4gKiBEZWNvcmF0b3IgZm9yIGNsYXNzIHByb3BlcnRpZXM6IEBjb21wdXRlZCBnZXQgdmFsdWUoKSB7IHJldHVybiBleHByOyB9LlxuICogRm9yIGxlZ2FjeSBwdXJwb3NlcyBhbHNvIGludm9rYWJsZSBhcyBFUzUgb2JzZXJ2YWJsZSBjcmVhdGVkOiBgY29tcHV0ZWQoKCkgPT4gZXhwcilgO1xuICovXG52YXIgY29tcHV0ZWQgPSBmdW5jdGlvbiBjb21wdXRlZChhcmcxLCBhcmcyKSB7XG4gIGlmIChpczIwMjIzRGVjb3JhdG9yKGFyZzIpKSB7XG4gICAgLy8gQGNvbXB1dGVkICgyMDIyLjMgRGVjb3JhdG9ycylcbiAgICByZXR1cm4gY29tcHV0ZWRBbm5vdGF0aW9uLmRlY29yYXRlXzIwMjIzXyhhcmcxLCBhcmcyKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWRcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QoYXJnMSkpIHtcbiAgICAvLyBAY29tcHV0ZWQoeyBvcHRpb25zIH0pXG4gICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVELCBhcmcxKSk7XG4gIH1cbiAgLy8gY29tcHV0ZWQoZXhwciwgb3B0aW9ucz8pXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgIGRpZShcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uXCIpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgZGllKFwiQSBzZXR0ZXIgYXMgc2Vjb25kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBgeyBzZXQ6IGZuIH1gIG9wdGlvbiBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0cyA9IGlzUGxhaW5PYmplY3QoYXJnMikgPyBhcmcyIDoge307XG4gIG9wdHMuZ2V0ID0gYXJnMTtcbiAgb3B0cy5uYW1lIHx8IChvcHRzLm5hbWUgPSBhcmcxLm5hbWUgfHwgXCJcIik7IC8qIGZvciBnZW5lcmF0ZWQgbmFtZSAqL1xuICByZXR1cm4gbmV3IENvbXB1dGVkVmFsdWUob3B0cyk7XG59O1xuT2JqZWN0LmFzc2lnbihjb21wdXRlZCwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbmNvbXB1dGVkLnN0cnVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbik7XG5cbnZhciBfZ2V0RGVzY3JpcHRvciRjb25maWcsIF9nZXREZXNjcmlwdG9yO1xuLy8gd2UgZG9uJ3QgdXNlIGdsb2JhbFN0YXRlIGZvciB0aGVzZSBpbiBvcmRlciB0byBhdm9pZCBwb3NzaWJsZSBpc3N1ZXMgd2l0aCBtdWx0aXBsZVxuLy8gbW9ieCB2ZXJzaW9uc1xudmFyIGN1cnJlbnRBY3Rpb25JZCA9IDA7XG52YXIgbmV4dEFjdGlvbklkID0gMTtcbnZhciBpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSA9IChfZ2V0RGVzY3JpcHRvciRjb25maWcgPSAoX2dldERlc2NyaXB0b3IgPSAvKiNfX1BVUkVfXyovZ2V0RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgXCJuYW1lXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSAhPSBudWxsID8gX2dldERlc2NyaXB0b3IkY29uZmlnIDogZmFsc2U7XG4vLyB3ZSBjYW4gc2FmZWx5IHJlY3ljbGUgdGhpcyBvYmplY3RcbnZhciB0bXBOYW1lRGVzY3JpcHRvciA9IHtcbiAgdmFsdWU6IFwiYWN0aW9uXCIsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgYXV0b0FjdGlvbiwgcmVmKSB7XG4gIGlmIChhdXRvQWN0aW9uID09PSB2b2lkIDApIHtcbiAgICBhdXRvQWN0aW9uID0gZmFsc2U7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIGRpZShcImBhY3Rpb25gIGNhbiBvbmx5IGJlIGludm9rZWQgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpIHtcbiAgICAgIGRpZShcImFjdGlvbnMgc2hvdWxkIGhhdmUgdmFsaWQgbmFtZXMsIGdvdDogJ1wiICsgYWN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzKCkge1xuICAgIHJldHVybiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGF1dG9BY3Rpb24sIGZuLCByZWYgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXMuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcbiAgcmVzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi50b1N0cmluZygpO1xuICB9O1xuICBpZiAoaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUpIHtcbiAgICB0bXBOYW1lRGVzY3JpcHRvci52YWx1ZSA9IGFjdGlvbk5hbWU7XG4gICAgZGVmaW5lUHJvcGVydHkocmVzLCBcIm5hbWVcIiwgdG1wTmFtZURlc2NyaXB0b3IpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgZm4sIHNjb3BlLCBhcmdzKSB7XG4gIHZhciBydW5JbmZvID0gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgc2NvcGUsIGFyZ3MpO1xuICB0cnkge1xuICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJ1bkluZm8uZXJyb3JfID0gZXJyO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBfZW5kQWN0aW9uKHJ1bkluZm8pO1xuICB9XG59XG5mdW5jdGlvbiBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLFxuLy8gdHJ1ZSBmb3IgYXV0b0FjdGlvblxuc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIG5vdGlmeVNweV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkgJiYgISFhY3Rpb25OYW1lO1xuICB2YXIgc3RhcnRUaW1lXyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5Xykge1xuICAgIHN0YXJ0VGltZV8gPSBEYXRlLm5vdygpO1xuICAgIHZhciBmbGF0dGVuZWRBcmdzID0gYXJncyA/IEFycmF5LmZyb20oYXJncykgOiBFTVBUWV9BUlJBWTtcbiAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICB0eXBlOiBBQ1RJT04sXG4gICAgICBuYW1lOiBhY3Rpb25OYW1lLFxuICAgICAgb2JqZWN0OiBzY29wZSxcbiAgICAgIGFyZ3VtZW50czogZmxhdHRlbmVkQXJnc1xuICAgIH0pO1xuICB9XG4gIHZhciBwcmV2RGVyaXZhdGlvbl8gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIHZhciBydW5Bc0FjdGlvbiA9ICFjYW5SdW5Bc0Rlcml2YXRpb24gfHwgIXByZXZEZXJpdmF0aW9uXztcbiAgc3RhcnRCYXRjaCgpO1xuICB2YXIgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzOyAvLyBieSBkZWZhdWx0IHByZXNlcnZlIHByZXZpb3VzIGFsbG93XG4gIGlmIChydW5Bc0FjdGlvbikge1xuICAgIHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gIH1cbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHNfID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gIHZhciBydW5JbmZvID0ge1xuICAgIHJ1bkFzQWN0aW9uXzogcnVuQXNBY3Rpb24sXG4gICAgcHJldkRlcml2YXRpb25fOiBwcmV2RGVyaXZhdGlvbl8sXG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXzogcHJldkFsbG93U3RhdGVDaGFuZ2VzXyxcbiAgICBwcmV2QWxsb3dTdGF0ZVJlYWRzXzogcHJldkFsbG93U3RhdGVSZWFkc18sXG4gICAgbm90aWZ5U3B5Xzogbm90aWZ5U3B5XyxcbiAgICBzdGFydFRpbWVfOiBzdGFydFRpbWVfLFxuICAgIGFjdGlvbklkXzogbmV4dEFjdGlvbklkKyssXG4gICAgcGFyZW50QWN0aW9uSWRfOiBjdXJyZW50QWN0aW9uSWRcbiAgfTtcbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5hY3Rpb25JZF87XG4gIHJldHVybiBydW5JbmZvO1xufVxuZnVuY3Rpb24gX2VuZEFjdGlvbihydW5JbmZvKSB7XG4gIGlmIChjdXJyZW50QWN0aW9uSWQgIT09IHJ1bkluZm8uYWN0aW9uSWRfKSB7XG4gICAgZGllKDMwKTtcbiAgfVxuICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLnBhcmVudEFjdGlvbklkXztcbiAgaWYgKHJ1bkluZm8uZXJyb3JfICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gdHJ1ZTtcbiAgfVxuICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlQ2hhbmdlc18pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZVJlYWRzXyk7XG4gIGVuZEJhdGNoKCk7XG4gIGlmIChydW5JbmZvLnJ1bkFzQWN0aW9uXykge1xuICAgIHVudHJhY2tlZEVuZChydW5JbmZvLnByZXZEZXJpdmF0aW9uXyk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBydW5JbmZvLm5vdGlmeVNweV8pIHtcbiAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHJ1bkluZm8uc3RhcnRUaW1lX1xuICAgIH0pO1xuICB9XG4gIGdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzKGFsbG93U3RhdGVDaGFuZ2VzLCBmdW5jKSB7XG4gIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBwcmV2O1xufVxuXG52YXIgQ1JFQVRFID0gXCJjcmVhdGVcIjtcbnZhciBPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdG9tKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIG5hbWVfLCBub3RpZnlTcHksIGVxdWFscykge1xuICAgIHZhciBfdGhpcztcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVWYWx1ZUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlVmFsdWVcIjtcbiAgICB9XG4gICAgaWYgKG5vdGlmeVNweSA9PT0gdm9pZCAwKSB7XG4gICAgICBub3RpZnlTcHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXF1YWxzID09PSB2b2lkIDApIHtcbiAgICAgIGVxdWFscyA9IGNvbXBhcmVyW1wiZGVmYXVsdFwiXTtcbiAgICB9XG4gICAgX3RoaXMgPSBfQXRvbS5jYWxsKHRoaXMsIG5hbWVfKSB8fCB0aGlzO1xuICAgIF90aGlzLmVuaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmVxdWFscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlXyA9IGZhbHNlO1xuICAgIF90aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy52YWx1ZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcbiAgICBfdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIF90aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICBfdGhpcy52YWx1ZV8gPSBlbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkLCBuYW1lXyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIC8vIG9ubHkgbm90aWZ5IHNweSBpZiB0aGlzIGlzIGEgc3RhbmQtYWxvbmUgb2JzZXJ2YWJsZVxuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogQ1JFQVRFLFxuICAgICAgICBvYmplY3Q6IF90aGlzLFxuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IF90aGlzLm5hbWVfLFxuICAgICAgICBuZXdWYWx1ZTogXCJcIiArIF90aGlzLnZhbHVlX1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHNMb29zZShPYnNlcnZhYmxlVmFsdWUsIF9BdG9tKTtcbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGU7XG4gIF9wcm90by5kZWhhbmNlVmFsdWUgPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIG5ld1ZhbHVlID0gdGhpcy5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnByZXBhcmVOZXdWYWx1ZV8gPSBmdW5jdGlvbiBwcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcyk7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLlVOQ0hBTkdFRDtcbiAgICAgIH1cbiAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cbiAgICAvLyBhcHBseSBtb2RpZmllclxuICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcihuZXdWYWx1ZSwgdGhpcy52YWx1ZV8sIHRoaXMubmFtZV8pO1xuICAgIHJldHVybiB0aGlzLmVxdWFscyh0aGlzLnZhbHVlXywgbmV3VmFsdWUpID8gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEIDogbmV3VmFsdWU7XG4gIH07XG4gIF9wcm90by5zZXROZXdWYWx1ZV8gPSBmdW5jdGlvbiBzZXROZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmVwb3J0Q2hhbmdlZCgpO1xuICAgIGlmIChoYXNMaXN0ZW5lcnModGhpcykpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHRoaXMucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWUodGhpcy52YWx1ZV8pO1xuICB9O1xuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBuZXdWYWx1ZTogdGhpcy52YWx1ZV8sXG4gICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG4gIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcoKSB7XG4gICAgLy8gdXNlZCBieSBNU1Qgb3QgZ2V0IHVuZGVoYW5jZWQgdmFsdWVcbiAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfICsgXCJbXCIgKyB0aGlzLnZhbHVlXyArIFwiXVwiO1xuICB9O1xuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuICBfcHJvdG9bU3ltYm9sLnRvUHJpbWl0aXZlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH07XG4gIHJldHVybiBPYnNlcnZhYmxlVmFsdWU7XG59KEF0b20pO1xudmFyIGlzT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlVmFsdWVcIiwgT2JzZXJ2YWJsZVZhbHVlKTtcblxuLyoqXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cbiAqXG4gKiBDb21wdXRlZFZhbHVlIHdpbGwgcmVtZW1iZXIgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYmF0Y2gsIG9yXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cbiAqXG4gKiBEdXJpbmcgdGhpcyB0aW1lIGl0IHdpbGwgcmVjb21wdXRlIG9ubHkgd2hlbiBvbmUgb2YgaXRzIGRpcmVjdCBkZXBlbmRlbmNpZXMgY2hhbmdlZCxcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXG4gKlxuICogSW1wbGVtZW50YXRpb24gZGVzY3JpcHRpb246XG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcbiAqICAgIGdpdmUgYmFjayByZW1lbWJlcmVkIHJlc3VsdCB1bnRpbCAyLiBoYXBwZW5zXG4gKiAyLiBGaXJzdCB0aW1lIGFueSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlLCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEUgdG8gYWxsIG9ic2VydmVycywgd2FpdCBmb3IgMy5cbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cbiAqICAgIGlmIHJlc3VsdCBjaGFuZ2VkOiBwcm9wYWdhdGUgU1RBTEUgdG8gYWxsIG9ic2VydmVycywgdGhhdCB3ZXJlIFBPU1NJQkxZX1NUQUxFIGZyb20gdGhlIGxhc3Qgc3RlcC5cbiAqICAgIGdvIHRvIHN0ZXAgMi4gZWl0aGVyIHdheVxuICpcbiAqIElmIGF0IGFueSBwb2ludCBpdCdzIG91dHNpZGUgYmF0Y2ggYW5kIGl0IGlzbid0IG9ic2VydmVkOiByZXNldCBldmVyeXRoaW5nIGFuZCBnbyB0byAxLlxuICovXG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gYSBmdW5jdGlvbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGZvciBkZWJ1ZyBwdXJwb3NlcyBvbmx5LlxuICAgKlxuICAgKiBUaGUgYGVxdWFsc2AgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBjb21wYXJlciBmdW5jdGlvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIGlmIGEgbmV3bHkgcHJvZHVjZWRcbiAgICogdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyB2YWx1ZS4gVHdvIGNvbXBhcmVycyBhcmUgcHJvdmlkZWQgaW4gdGhlIGxpYnJhcnk7IGBkZWZhdWx0Q29tcGFyZXJgXG4gICAqIGNvbXBhcmVzIGJhc2VkIG9uIGlkZW50aXR5IGNvbXBhcmlzb24gKD09PSksIGFuZCBgc3RydWN0dXJhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cbiAgICogU3RydWN0dXJhbCBjb21wYXJpc29uIGNhbiBiZSBjb252ZW5pZW50IGlmIHlvdSBhbHdheXMgcHJvZHVjZSBhIG5ldyBhZ2dyZWdhdGVkIG9iamVjdCBhbmRcbiAgICogZG9uJ3Qgd2FudCB0byBub3RpZnkgb2JzZXJ2ZXJzIGlmIGl0IGlzIHN0cnVjdHVyYWxseSB0aGUgc2FtZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXG4gICAqL1xuICBmdW5jdGlvbiBDb21wdXRlZFZhbHVlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gbnVsbDtcbiAgICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5ydW5JZF8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKG51bGwpO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyZWRCeV8gPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFnc18gPSAwO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IHZvaWQgMDtcbiAgICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcbiAgICB0aGlzLnNldHRlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5zY29wZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcXVhbHNfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gdm9pZCAwO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRpb25zLmdldCkge1xuICAgICAgZGllKDMxKTtcbiAgICB9XG4gICAgdGhpcy5kZXJpdmF0aW9uID0gb3B0aW9ucy5nZXQ7XG4gICAgdGhpcy5uYW1lXyA9IG9wdGlvbnMubmFtZSB8fCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJDb21wdXRlZFZhbHVlQFwiICsgZ2V0TmV4dElkKCkgOiBcIkNvbXB1dGVkVmFsdWVcIik7XG4gICAgaWYgKG9wdGlvbnMuc2V0KSB7XG4gICAgICB0aGlzLnNldHRlcl8gPSBjcmVhdGVBY3Rpb24ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLXNldHRlclwiIDogXCJDb21wdXRlZFZhbHVlLXNldHRlclwiLCBvcHRpb25zLnNldCk7XG4gICAgfVxuICAgIHRoaXMuZXF1YWxzXyA9IG9wdGlvbnMuZXF1YWxzIHx8IChvcHRpb25zLmNvbXBhcmVTdHJ1Y3R1cmFsIHx8IG9wdGlvbnMuc3RydWN0ID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IGNvbXBhcmVyW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5zY29wZV8gPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9IG9wdGlvbnMucmVxdWlyZXNSZWFjdGlvbjtcbiAgICB0aGlzLmtlZXBBbGl2ZV8gPSAhIW9wdGlvbnMua2VlcEFsaXZlO1xuICB9XG4gIHZhciBfcHJvdG8gPSBDb21wdXRlZFZhbHVlLnByb3RvdHlwZTtcbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKHRoaXMpO1xuICB9O1xuICBfcHJvdG8ub25CTyA9IGZ1bmN0aW9uIG9uQk8oKSB7XG4gICAgaWYgKHRoaXMub25CT0wpIHtcbiAgICAgIHRoaXMub25CT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICA7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMgY29tcHV0ZWQgdmFsdWUuXG4gICAqIFdpbGwgZXZhbHVhdGUgaXRzIGNvbXB1dGF0aW9uIGZpcnN0IGlmIG5lZWRlZC5cbiAgICovXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wdXRpbmcpIHtcbiAgICAgIGRpZSgzMiwgdGhpcy5uYW1lXywgdGhpcy5kZXJpdmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDAgJiZcbiAgICAvLyAhZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0cGlvbiAmJlxuICAgIHRoaXMub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmICF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMud2FybkFib3V0VW50cmFja2VkUmVhZF8oKTtcbiAgICAgICAgc3RhcnRCYXRjaCgpOyAvLyBTZWUgcGVyZiB0ZXN0ICdjb21wdXRlZCBtZW1vaXphdGlvbidcbiAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmNvbXB1dGVWYWx1ZV8oZmFsc2UpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnRPYnNlcnZlZCh0aGlzKTtcbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHZhciBwcmV2VHJhY2tpbmdDb250ZXh0ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVfICYmICFwcmV2VHJhY2tpbmdDb250ZXh0KSB7XG4gICAgICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja0FuZENvbXB1dGUoKSkge1xuICAgICAgICAgIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2VHJhY2tpbmdDb250ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IHJlc3VsdC5jYXVzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcl8pIHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZ1NldHRlcikge1xuICAgICAgICBkaWUoMzMsIHRoaXMubmFtZV8pO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXIgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0ZXJfLmNhbGwodGhpcy5zY29wZV8sIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZSgzNCwgdGhpcy5uYW1lXyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udHJhY2tBbmRDb21wdXRlID0gZnVuY3Rpb24gdHJhY2tBbmRDb21wdXRlKCkge1xuICAgIC8vIE4uQjogdW5taW5pZmllZCBhcyBpdCBpcyB1c2VkIGJ5IE1TVFxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHZhciB3YXNTdXNwZW5kZWQgPSAvKiBzZWUgIzEyMDggKi90aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZV8odHJ1ZSk7XG4gICAgdmFyIGNoYW5nZWQgPSB3YXNTdXNwZW5kZWQgfHwgaXNDYXVnaHRFeGNlcHRpb24ob2xkVmFsdWUpIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG5ld1ZhbHVlKSB8fCAhdGhpcy5lcXVhbHNfKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnNjb3BlXyxcbiAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuICBfcHJvdG8uY29tcHV0ZVZhbHVlXyA9IGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZV8odHJhY2spIHtcbiAgICB0aGlzLmlzQ29tcHV0aW5nID0gdHJ1ZTtcbiAgICAvLyBkb24ndCBhbGxvdyBzdGF0ZSBjaGFuZ2VzIGR1cmluZyBjb21wdXRhdGlvblxuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChmYWxzZSk7XG4gICAgdmFyIHJlcztcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZV8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgdGhpcy5pc0NvbXB1dGluZyA9IGZhbHNlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG4gIF9wcm90by5zdXNwZW5kXyA9IGZ1bmN0aW9uIHN1c3BlbmRfKCkge1xuICAgIGlmICghdGhpcy5rZWVwQWxpdmVfKSB7XG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWVfID0gdW5kZWZpbmVkOyAvLyBkb24ndCBob2xkIG9uIHRvIGNvbXB1dGVkIHZhbHVlIVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgd2FzIHN1c3BlbmRlZCBhbmQgaXQgd2lsbCByZWNvbXB1dGUgb24gdGhlIG5leHQgYWNjZXNzLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgIHZhciBwcmV2VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGF1dG9ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgaW4gYSBkaWZmZXJlbnQgcGxhY2UgdGhhbiB0aGUgc3B5UmVwb3J0KCkgZnVuY3Rpb24/IGluIGFsbCBvdGhlciBvYnNlcnZhYmxlcyBpdCdzIGNhbGxlZCBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuZ2V0KCk7XG4gICAgICBpZiAoIWZpcnN0VGltZSB8fCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcImNvbXB1dGVkXCIsXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiBfdGhpcy5uYW1lXyxcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiBfdGhpcyxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWU6IHByZXZWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVKTtcbiAgICAgIH1cbiAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgcHJldlZhbHVlID0gbmV3VmFsdWU7XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXyA9IGZ1bmN0aW9uIHdhcm5BYm91dFVudHJhY2tlZFJlYWRfKCkge1xuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgaXMgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC4gRG9pbmcgYSBmdWxsIHJlY29tcHV0ZS5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9PT0gXCJib29sZWFuXCIgPyB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fIDogZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfICsgXCJbXCIgKyB0aGlzLmRlcml2YXRpb24udG9TdHJpbmcoKSArIFwiXVwiO1xuICB9O1xuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuICBfcHJvdG9bU3ltYm9sLnRvUHJpbWl0aXZlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH07XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ29tcHV0ZWRWYWx1ZSwgW3tcbiAgICBrZXk6IFwiaXNDb21wdXRpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBDb21wdXRlZFZhbHVlLmlzQ29tcHV0aW5nTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc0NvbXB1dGluZ01hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUnVubmluZ1NldHRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNSdW5uaW5nU2V0dGVyTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgQ29tcHV0ZWRWYWx1ZS5pc1J1bm5pbmdTZXR0ZXJNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0JlaW5nT2JzZXJ2ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBDb21wdXRlZFZhbHVlLmlzQmVpbmdPYnNlcnZlZE1hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNCZWluZ09ic2VydmVkTWFza18sIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQZW5kaW5nVW5vYnNlcnZhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpZmZWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIENvbXB1dGVkVmFsdWUuZGlmZlZhbHVlTWFza18pID8gMSA6IDA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBDb21wdXRlZFZhbHVlLmRpZmZWYWx1ZU1hc2tfLCBuZXdWYWx1ZSA9PT0gMSA/IHRydWUgOiBmYWxzZSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5Db21wdXRlZFZhbHVlLmlzQ29tcHV0aW5nTWFza18gPSAxO1xuQ29tcHV0ZWRWYWx1ZS5pc1J1bm5pbmdTZXR0ZXJNYXNrXyA9IDI7XG5Db21wdXRlZFZhbHVlLmlzQmVpbmdPYnNlcnZlZE1hc2tfID0gNDtcbkNvbXB1dGVkVmFsdWUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbk1hc2tfID0gODtcbkNvbXB1dGVkVmFsdWUuZGlmZlZhbHVlTWFza18gPSAxNjtcbnZhciBpc0NvbXB1dGVkVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkNvbXB1dGVkVmFsdWVcIiwgQ29tcHV0ZWRWYWx1ZSk7XG5cbnZhciBJRGVyaXZhdGlvblN0YXRlXztcbihmdW5jdGlvbiAoSURlcml2YXRpb25TdGF0ZV8pIHtcbiAgLy8gYmVmb3JlIGJlaW5nIHJ1biBvciAob3V0c2lkZSBiYXRjaCBhbmQgbm90IGJlaW5nIG9ic2VydmVkKVxuICAvLyBhdCB0aGlzIHBvaW50IGRlcml2YXRpb24gaXMgbm90IGhvbGRpbmcgYW55IGRhdGEgYWJvdXQgZGVwZW5kZW5jeSB0cmVlXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiTk9UX1RSQUNLSU5HX1wiXSA9IC0xXSA9IFwiTk9UX1RSQUNLSU5HX1wiO1xuICAvLyBubyBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uXG4gIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cbiAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIG1vYnggZmFzdFxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlVQX1RPX0RBVEVfXCJdID0gMF0gPSBcIlVQX1RPX0RBVEVfXCI7XG4gIC8vIHNvbWUgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCBkb24ndCBrbm93IGlmIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkXG4gIC8vIHdpbGwgcmVxdWlyZSB0byBjaGVjayBmaXJzdCBpZiBVUF9UT19EQVRFIG9yIFBPU1NJQkxZX1NUQUxFXG4gIC8vIGN1cnJlbnRseSBvbmx5IENvbXB1dGVkVmFsdWUgd2lsbCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEVcbiAgLy9cbiAgLy8gaGF2aW5nIHRoaXMgc3RhdGUgaXMgc2Vjb25kIGJpZyBvcHRpbWl6YXRpb246XG4gIC8vIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIG9uIGV2ZXJ5IGRlcGVuZGVuY3kgY2hhbmdlLCBidXQgb25seSB3aGVuIGl0J3MgbmVlZGVkXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiUE9TU0lCTFlfU1RBTEVfXCJdID0gMV0gPSBcIlBPU1NJQkxZX1NUQUxFX1wiO1xuICAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJTVEFMRV9cIl0gPSAyXSA9IFwiU1RBTEVfXCI7XG59KShJRGVyaXZhdGlvblN0YXRlXyB8fCAoSURlcml2YXRpb25TdGF0ZV8gPSB7fSkpO1xudmFyIFRyYWNlTW9kZTtcbihmdW5jdGlvbiAoVHJhY2VNb2RlKSB7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkxPR1wiXSA9IDFdID0gXCJMT0dcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkJSRUFLXCJdID0gMl0gPSBcIkJSRUFLXCI7XG59KShUcmFjZU1vZGUgfHwgKFRyYWNlTW9kZSA9IHt9KSk7XG52YXIgQ2F1Z2h0RXhjZXB0aW9uID0gZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XG4gIHRoaXMuY2F1c2UgPSB2b2lkIDA7XG4gIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgLy8gRW1wdHlcbn07XG5mdW5jdGlvbiBpc0NhdWdodEV4Y2VwdGlvbihlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgQ2F1Z2h0RXhjZXB0aW9uO1xufVxuLyoqXG4gKiBGaW5kcyBvdXQgd2hldGhlciBhbnkgZGVwZW5kZW5jeSBvZiB0aGUgZGVyaXZhdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAqIElmIGRlcGVuZGVuY2llc1N0YXRlIGlzIDEgdGhlbiBpdCB3aWxsIHJlY2FsY3VsYXRlIGRlcGVuZGVuY2llcyxcbiAqIGlmIGFueSBkZXBlbmRlbmN5IGNoYW5nZWQgaXQgd2lsbCBwcm9wYWdhdGUgaXQgYnkgY2hhbmdpbmcgZGVwZW5kZW5jaWVzU3RhdGUgdG8gMi5cbiAqXG4gKiBCeSBpdGVyYXRpbmcgb3ZlciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlcG9ydGVkIGFuZFxuICogc3RvcHBpbmcgb24gdGhlIGZpcnN0IGNoYW5nZSwgYWxsIHRoZSByZWNhbGN1bGF0aW9ucyBhcmUgb25seSBjYWxsZWQgZm9yIENvbXB1dGVkVmFsdWVzXG4gKiB0aGF0IHdpbGwgYmUgdHJhY2tlZCBieSBkZXJpdmF0aW9uLiBUaGF0IGlzIGJlY2F1c2Ugd2UgYXNzdW1lIHRoYXQgaWYgdGhlIGZpcnN0IHhcbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZGVyaXZhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGVuIHRoZSBkZXJpdmF0aW9uIHNob3VsZCBydW4gdGhlIHNhbWUgd2F5XG4gKiB1cCB1bnRpbCBhY2Nlc3NpbmcgeC10aCBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiBzaG91bGRDb21wdXRlKGRlcml2YXRpb24pIHtcbiAgc3dpdGNoIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXykge1xuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV86XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfOlxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV86XG4gICAgICB7XG4gICAgICAgIC8vIHN0YXRlIHByb3BhZ2F0aW9uIGNhbiBvY2N1ciBvdXRzaWRlIG9mIGFjdGlvbi9yZWFjdGl2ZSBjb250ZXh0ICMyMTk1XG4gICAgICAgIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2VW50cmFja2VkID0gdW50cmFja2VkU3RhcnQoKTsgLy8gbm8gbmVlZCBmb3IgdGhvc2UgY29tcHV0ZWRzIHRvIGJlIHJlcG9ydGVkLCB0aGV5IHdpbGwgYmUgcGlja2VkIHVwIGluIHRyYWNrRGVyaXZlZEZ1bmN0aW9uLlxuICAgICAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfLFxuICAgICAgICAgIGwgPSBvYnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBvYmogPSBvYnNbaV07XG4gICAgICAgICAgaWYgKGlzQ29tcHV0ZWRWYWx1ZShvYmopKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcykge1xuICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5nZXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiB0aGUgdmFsdWUgKm9yKiBleGNlcHRpb24gYXQgdGhpcyBtb21lbnQsIGJ1dCBpZiB0aGVyZSBpcyBvbmUsIG5vdGlmeSBhbGxcbiAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBDb21wdXRlZFZhbHVlIGBvYmpgIGFjdHVhbGx5IGNoYW5nZWQgaXQgd2lsbCBiZSBjb21wdXRlZCBhbmQgcHJvcGFnYXRlZCB0byBpdHMgb2JzZXJ2ZXJzLlxuICAgICAgICAgICAgLy8gYW5kIGBkZXJpdmF0aW9uYCBpcyBhbiBvYnNlcnZlciBvZiBgb2JqYFxuICAgICAgICAgICAgLy8gaW52YXJpYW50U2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKVxuICAgICAgICAgICAgaWYgKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHtcbiAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wdXRpbmdEZXJpdmF0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICE9PSBudWxsOyAvLyBmaWx0ZXIgb3V0IGFjdGlvbnMgaW5zaWRlIGNvbXB1dGF0aW9uc1xufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQoYXRvbSkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYXNPYnNlcnZlcnMgPSBhdG9tLm9ic2VydmVyc18uc2l6ZSA+IDA7XG4gIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gY2hhbmdlIG9ic2VydmVkIHN0YXRlIG91dHNpZGUgc3RyaWN0IG1vZGUsIGV4Y2VwdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHNlZSAjNTYzXG4gIGlmICghZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgJiYgKGhhc09ic2VydmVycyB8fCBnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA9PT0gXCJhbHdheXNcIikpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gXCIgKyAoZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPyBcIlNpbmNlIHN0cmljdC1tb2RlIGlzIGVuYWJsZWQsIGNoYW5naW5nIChvYnNlcnZlZCkgb2JzZXJ2YWJsZSB2YWx1ZXMgd2l0aG91dCB1c2luZyBhbiBhY3Rpb24gaXMgbm90IGFsbG93ZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIgOiBcIlNpZGUgZWZmZWN0cyBsaWtlIGNoYW5naW5nIHN0YXRlIGFyZSBub3QgYWxsb3dlZCBhdCB0aGlzIHBvaW50LiBBcmUgeW91IHRyeWluZyB0byBtb2RpZnkgc3RhdGUgZnJvbSwgZm9yIGV4YW1wbGUsIGEgY29tcHV0ZWQgdmFsdWUgb3IgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudD8gWW91IGNhbiB3cmFwIHNpZGUgZWZmZWN0cyBpbiAncnVuSW5BY3Rpb24nIChvciBkZWNvcmF0ZSBmdW5jdGlvbnMgd2l0aCAnYWN0aW9uJykgaWYgbmVlZGVkLiBUcmllZCB0byBtb2RpZnk6IFwiKSArIGF0b20ubmFtZV8pO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVSZWFkc0FyZUFsbG93ZWQob2JzZXJ2YWJsZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgJiYgZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gT2JzZXJ2YWJsZSAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuXCIpO1xuICB9XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXG4gKiBUaGUgdHJhY2tpbmcgaW5mb3JtYXRpb24gaXMgc3RvcmVkIG9uIHRoZSBgZGVyaXZhdGlvbmAgb2JqZWN0IGFuZCB0aGUgZGVyaXZhdGlvbiBpcyByZWdpc3RlcmVkXG4gKiBhcyBvYnNlcnZlciBvZiBhbnkgb2YgdGhlIGFjY2Vzc2VkIG9ic2VydmFibGVzLlxuICovXG5mdW5jdGlvbiB0cmFja0Rlcml2ZWRGdW5jdGlvbihkZXJpdmF0aW9uLCBmLCBjb250ZXh0KSB7XG4gIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICAvLyBQcmVhbGxvY2F0ZSBhcnJheTsgd2lsbCBiZSB0cmltbWVkIGJ5IGJpbmREZXBlbmRlbmNpZXMuXG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG5ldyBBcnJheShcbiAgLy8gUmVzZXJ2ZSBjb25zdGFudCBzcGFjZSBmb3IgaW5pdGlhbCBkZXBlbmRlbmNpZXMsIGR5bmFtaWMgc3BhY2Ugb3RoZXJ3aXNlLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMzgzM1xuICBkZXJpdmF0aW9uLnJ1bklkXyA9PT0gMCA/IDEwMCA6IGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGgpO1xuICBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgZGVyaXZhdGlvbi5ydW5JZF8gPSArK2dsb2JhbFN0YXRlLnJ1bklkO1xuICB2YXIgcHJldlRyYWNraW5nID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBkZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaC0tO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2VHJhY2tpbmc7XG4gIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3YXJuQWJvdXREZXJpdmF0aW9uV2l0aG91dERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggIT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPT09IFwiYm9vbGVhblwiID8gZGVyaXZhdGlvbi5yZXF1aXJlc09ic2VydmFibGVfIDogZ2xvYmFsU3RhdGUucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gRGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGNyZWF0ZWQvdXBkYXRlZCB3aXRob3V0IHJlYWRpbmcgYW55IG9ic2VydmFibGUgdmFsdWUuXCIpO1xuICB9XG59XG4vKipcbiAqIGRpZmZzIG5ld09ic2VydmluZyB3aXRoIG9ic2VydmluZy5cbiAqIHVwZGF0ZSBvYnNlcnZpbmcgdG8gYmUgbmV3T2JzZXJ2aW5nIHdpdGggdW5pcXVlIG9ic2VydmFibGVzXG4gKiBub3RpZnkgb2JzZXJ2ZXJzIHRoYXQgYmVjb21lIG9ic2VydmVkL3Vub2JzZXJ2ZWRcbiAqL1xuZnVuY3Rpb24gYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSBJRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORywgXCJJTlRFUk5BTCBFUlJPUiBiaW5kRGVwZW5kZW5jaWVzIGV4cGVjdHMgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIHZhciBwcmV2T2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgb2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfID0gZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfO1xuICB2YXIgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAodGhpcyBsaXN0IGNhbiBjb250YWluIGR1cGxpY2F0ZXMpOlxuICAvLyAgIDA6IGZpcnN0IG9jY3VycmVuY2UsIGNoYW5nZSB0byAxIGFuZCBrZWVwIGl0XG4gIC8vICAgMTogZXh0cmEgb2NjdXJyZW5jZSwgZHJvcCBpdFxuICB2YXIgaTAgPSAwLFxuICAgIGwgPSBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaV07XG4gICAgaWYgKGRlcC5kaWZmVmFsdWUgPT09IDApIHtcbiAgICAgIGRlcC5kaWZmVmFsdWUgPSAxO1xuICAgICAgaWYgKGkwICE9PSBpKSB7XG4gICAgICAgIG9ic2VydmluZ1tpMF0gPSBkZXA7XG4gICAgICB9XG4gICAgICBpMCsrO1xuICAgIH1cbiAgICAvLyBVcGNhc3QgaXMgJ3NhZmUnIGhlcmUsIGJlY2F1c2UgaWYgZGVwIGlzIElPYnNlcnZhYmxlLCBgZGVwZW5kZW5jaWVzU3RhdGVgIHdpbGwgYmUgdW5kZWZpbmVkLFxuICAgIC8vIG5vdCBoaXR0aW5nIHRoZSBjb25kaXRpb25cbiAgICBpZiAoZGVwLmRlcGVuZGVuY2llc1N0YXRlXyA+IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSkge1xuICAgICAgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gZGVwLmRlcGVuZGVuY2llc1N0YXRlXztcbiAgICB9XG4gIH1cbiAgb2JzZXJ2aW5nLmxlbmd0aCA9IGkwO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBudWxsOyAvLyBuZXdPYnNlcnZpbmcgc2hvdWxkbid0IGJlIG5lZWRlZCBvdXRzaWRlIHRyYWNraW5nIChzdGF0ZW1lbnQgbW92ZWQgZG93biB0byB3b3JrIGFyb3VuZCBGRiBidWcsIHNlZSAjNjE0KVxuICAvLyBHbyB0aHJvdWdoIGFsbCBvbGQgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKGl0IGlzIHVuaXF1ZSBhZnRlciBsYXN0IGJpbmREZXBlbmRlbmNpZXMpXG4gIC8vICAgMDogaXQncyBub3QgaW4gbmV3IG9ic2VydmFibGVzLCB1bm9ic2VydmUgaXRcbiAgLy8gICAxOiBpdCBrZWVwcyBiZWluZyBvYnNlcnZlZCwgZG9uJ3Qgd2FudCB0byBub3RpZnkgaXQuIGNoYW5nZSB0byAwXG4gIGwgPSBwcmV2T2JzZXJ2aW5nLmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIHZhciBfZGVwID0gcHJldk9ic2VydmluZ1tsXTtcbiAgICBpZiAoX2RlcC5kaWZmVmFsdWUgPT09IDApIHtcbiAgICAgIHJlbW92ZU9ic2VydmVyKF9kZXAsIGRlcml2YXRpb24pO1xuICAgIH1cbiAgICBfZGVwLmRpZmZWYWx1ZSA9IDA7XG4gIH1cbiAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChub3cgaXQgc2hvdWxkIGJlIHVuaXF1ZSlcbiAgLy8gICAwOiBpdCB3YXMgc2V0IHRvIDAgaW4gbGFzdCBsb29wLiBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAvLyAgIDE6IGl0IHdhc24ndCBvYnNlcnZlZCwgbGV0J3Mgb2JzZXJ2ZSBpdC4gc2V0IGJhY2sgdG8gMFxuICB3aGlsZSAoaTAtLSkge1xuICAgIHZhciBfZGVwMiA9IG9ic2VydmluZ1tpMF07XG4gICAgaWYgKF9kZXAyLmRpZmZWYWx1ZSA9PT0gMSkge1xuICAgICAgX2RlcDIuZGlmZlZhbHVlID0gMDtcbiAgICAgIGFkZE9ic2VydmVyKF9kZXAyLCBkZXJpdmF0aW9uKTtcbiAgICB9XG4gIH1cbiAgLy8gU29tZSBuZXcgb2JzZXJ2ZWQgZGVyaXZhdGlvbnMgbWF5IGJlY29tZSBzdGFsZSBkdXJpbmcgdGhpcyBkZXJpdmF0aW9uIGNvbXB1dGF0aW9uXG4gIC8vIHNvIHRoZXkgaGF2ZSBoYWQgbm8gY2hhbmNlIHRvIHByb3BhZ2F0ZSBzdGFsZW5lc3MgKCM5MTYpXG4gIGlmIChsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGU7XG4gICAgZGVyaXZhdGlvbi5vbkJlY29tZVN0YWxlXygpO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhck9ic2VydmluZyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiBjbGVhck9ic2VydmluZyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBbXTtcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzW2ldLCBkZXJpdmF0aW9uKTtcbiAgfVxuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG59XG5mdW5jdGlvbiB1bnRyYWNrZWQoYWN0aW9uKSB7XG4gIHZhciBwcmV2ID0gdW50cmFja2VkU3RhcnQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdW50cmFja2VkRW5kKHByZXYpO1xuICB9XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRTdGFydCgpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gdW50cmFja2VkRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc1N0YXJ0KGFsbG93U3RhdGVSZWFkcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IHByZXY7XG59XG4vKipcbiAqIG5lZWRlZCB0byBrZWVwIGBsb3dlc3RPYnNlcnZlclN0YXRlYCBjb3JyZWN0LiB3aGVuIGNoYW5naW5nIGZyb20gKDIgb3IgMSkgdG8gMFxuICpcbiAqL1xuZnVuY3Rpb24gY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbikge1xuICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBpID0gb2JzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9ic1tpXS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB9XG59XG5cbi8qKlxuICogVGhlc2UgdmFsdWVzIHdpbGwgcGVyc2lzdCBpZiBnbG9iYWwgc3RhdGUgaXMgcmVzZXRcbiAqL1xudmFyIHBlcnNpc3RlbnRLZXlzID0gW1wibW9ieEd1aWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJlbmZvcmNlQWN0aW9uc1wiLCBcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJhbGxvd1N0YXRlUmVhZHNcIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwicnVuSWRcIiwgXCJVTkNIQU5HRURcIiwgXCJ1c2VQcm94aWVzXCJdO1xudmFyIE1vYlhHbG9iYWxzID0gZnVuY3Rpb24gTW9iWEdsb2JhbHMoKSB7XG4gIC8qKlxuICAgKiBNb2JYR2xvYmFscyB2ZXJzaW9uLlxuICAgKiBNb2JYIGNvbXBhdGlibGl0eSB3aXRoIG90aGVyIHZlcnNpb25zIGxvYWRlZCBpbiBtZW1vcnkgYXMgbG9uZyBhcyB0aGlzIHZlcnNpb24gbWF0Y2hlcy5cbiAgICogSXQgaW5kaWNhdGVzIHRoYXQgdGhlIGdsb2JhbCBzdGF0ZSBzdGlsbCBzdG9yZXMgc2ltaWxhciBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBOLkI6IHRoaXMgdmVyc2lvbiBpcyB1bnJlbGF0ZWQgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiBNb2JYLCBhbmQgaXMgb25seSB0aGUgdmVyc2lvbiBvZiB0aGVcbiAgICogaW50ZXJuYWwgc3RhdGUgc3RvcmFnZSBvZiBNb2JYLCBhbmQgY2FuIGJlIHRoZSBzYW1lIGFjcm9zcyBtYW55IGRpZmZlcmVudCBwYWNrYWdlIHZlcnNpb25zXG4gICAqL1xuICB0aGlzLnZlcnNpb24gPSA2O1xuICAvKipcbiAgICogZ2xvYmFsbHkgdW5pcXVlIHRva2VuIHRvIHNpZ25hbCB1bmNoYW5nZWRcbiAgICovXG4gIHRoaXMuVU5DSEFOR0VEID0ge307XG4gIC8qKlxuICAgKiBDdXJyZW50bHkgcnVubmluZyBkZXJpdmF0aW9uXG4gICAqL1xuICB0aGlzLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIC8qKlxuICAgKiBDdXJyZW50bHkgcnVubmluZyByZWFjdGlvbi4gVGhpcyBkZXRlcm1pbmVzIGlmIHdlIGN1cnJlbnRseSBoYXZlIGEgcmVhY3RpdmUgY29udGV4dC5cbiAgICogKFRyYWNraW5nIGRlcml2YXRpb24gaXMgYWxzbyBzZXQgZm9yIHRlbXBvcmFsIHRyYWNraW5nIG9mIGNvbXB1dGVkIHZhbHVlcyBpbnNpZGUgYWN0aW9ucyxcbiAgICogYnV0IHRyYWNraW5nUmVhY3Rpb24gY2FuIG9ubHkgYmUgc2V0IGJ5IGEgZm9ybSBvZiBSZWFjdGlvbilcbiAgICovXG4gIHRoaXMudHJhY2tpbmdDb250ZXh0ID0gbnVsbDtcbiAgLyoqXG4gICAqIEVhY2ggdGltZSBhIGRlcml2YXRpb24gaXMgdHJhY2tlZCwgaXQgaXMgYXNzaWduZWQgYSB1bmlxdWUgcnVuLWlkXG4gICAqL1xuICB0aGlzLnJ1bklkID0gMDtcbiAgLyoqXG4gICAqICdndWlkJyBmb3IgZ2VuZXJhbCBwdXJwb3NlLiBXaWxsIGJlIHBlcnNpc3RlZCBhbW9uZ3N0IHJlc2V0cy5cbiAgICovXG4gIHRoaXMubW9ieEd1aWQgPSAwO1xuICAvKipcbiAgICogQXJlIHdlIGluIGEgYmF0Y2ggYmxvY2s/IChhbmQgaG93IG1hbnkgb2YgdGhlbSlcbiAgICovXG4gIHRoaXMuaW5CYXRjaCA9IDA7XG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlcyB0aGF0IGRvbid0IGhhdmUgb2JzZXJ2ZXJzIGFueW1vcmUsIGFuZCBhcmUgYWJvdXQgdG8gYmVcbiAgICogc3VzcGVuZGVkLCB1bmxlc3Mgc29tZWJvZHkgZWxzZSBhY2Nlc3NlcyBpdCBpbiB0aGUgc2FtZSBiYXRjaFxuICAgKlxuICAgKiBAdHlwZSB7SU9ic2VydmFibGVbXX1cbiAgICovXG4gIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIC8qKlxuICAgKiBMaXN0IG9mIHNjaGVkdWxlZCwgbm90IHlldCBleGVjdXRlZCwgcmVhY3Rpb25zLlxuICAgKi9cbiAgdGhpcy5wZW5kaW5nUmVhY3Rpb25zID0gW107XG4gIC8qKlxuICAgKiBBcmUgd2UgY3VycmVudGx5IHByb2Nlc3NpbmcgcmVhY3Rpb25zP1xuICAgKi9cbiAgdGhpcy5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIElzIGl0IGFsbG93ZWQgdG8gY2hhbmdlIG9ic2VydmFibGVzIGF0IHRoaXMgcG9pbnQ/XG4gICAqIEluIGdlbmVyYWwsIE1vYlggZG9lc24ndCBhbGxvdyB0aGF0IHdoZW4gcnVubmluZyBjb21wdXRhdGlvbnMgYW5kIFJlYWN0LnJlbmRlci5cbiAgICogVG8gZW5zdXJlIHRoYXQgdGhvc2UgZnVuY3Rpb25zIHN0YXkgcHVyZS5cbiAgICovXG4gIHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIElzIGl0IGFsbG93ZWQgdG8gcmVhZCBvYnNlcnZhYmxlcyBhdCB0aGlzIHBvaW50P1xuICAgKiBVc2VkIHRvIGhvbGQgdGhlIHN0YXRlIG5lZWRlZCBmb3IgYG9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uYFxuICAgKi9cbiAgdGhpcy5hbGxvd1N0YXRlUmVhZHMgPSB0cnVlO1xuICAvKipcbiAgICogSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCwgc3RhdGUgY2hhbmdlcyBhcmUgYnkgZGVmYXVsdCBub3QgYWxsb3dlZFxuICAgKi9cbiAgdGhpcy5lbmZvcmNlQWN0aW9ucyA9IHRydWU7XG4gIC8qKlxuICAgKiBTcHkgY2FsbGJhY2tzXG4gICAqL1xuICB0aGlzLnNweUxpc3RlbmVycyA9IFtdO1xuICAvKipcbiAgICogR2xvYmFsbHkgYXR0YWNoZWQgZXJyb3IgaGFuZGxlcnMgdGhhdCByZWFjdCBzcGVjaWZpY2FsbHkgdG8gZXJyb3JzIGluIHJlYWN0aW9uc1xuICAgKi9cbiAgdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMgPSBbXTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgY29tcHV0ZWQgdmFsdWVzIGFyZSBhY2Nlc3NlZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dFxuICAgKi9cbiAgdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24gPSBmYWxzZTtcbiAgLyoqXG4gICAqIChFeHBlcmltZW50YWwpXG4gICAqIFdhcm4gaWYgeW91IHRyeSB0byBjcmVhdGUgdG8gZGVyaXZhdGlvbiAvIHJlYWN0aXZlIGNvbnRleHQgd2l0aG91dCBhY2Nlc3NpbmcgYW55IG9ic2VydmFibGUuXG4gICAqL1xuICB0aGlzLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlID0gZmFsc2U7XG4gIC8qKlxuICAgKiAoRXhwZXJpbWVudGFsKVxuICAgKiBXYXJuIGlmIG9ic2VydmFibGVzIGFyZSBhY2Nlc3NlZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dFxuICAgKi9cbiAgdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICAvKlxuICAgKiBEb24ndCBjYXRjaCBhbmQgcmV0aHJvdyBleGNlcHRpb25zLiBUaGlzIGlzIHVzZWZ1bCBmb3IgaW5zcGVjdGluZyB0aGUgc3RhdGUgb2ZcbiAgICogdGhlIHN0YWNrIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBkZWJ1Z2dpbmcuXG4gICAqL1xuICB0aGlzLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgLypcbiAgICogSWYgdHJ1ZSwgd2UgYXJlIGFscmVhZHkgaGFuZGxpbmcgYW4gZXhjZXB0aW9uIGluIGFuIGFjdGlvbi4gQW55IGVycm9ycyBpbiByZWFjdGlvbnMgc2hvdWxkIGJlIHN1cHByZXNzZWQsIGFzXG4gICAqIHRoZXkgYXJlIG5vdCB0aGUgY2F1c2UsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy8xODM2XG4gICAqL1xuICB0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbiAgdGhpcy51c2VQcm94aWVzID0gdHJ1ZTtcbiAgLypcbiAgICogcHJpbnQgd2FybmluZ3MgYWJvdXQgY29kZSB0aGF0IHdvdWxkIGZhaWwgaWYgcHJveGllcyB3ZXJlbid0IGF2YWlsYWJsZVxuICAgKi9cbiAgdGhpcy52ZXJpZnlQcm94aWVzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBGYWxzZSBmb3JjZXMgYWxsIG9iamVjdCdzIGRlc2NyaXB0b3JzIHRvXG4gICAqIHdyaXRhYmxlOiB0cnVlXG4gICAqIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgKi9cbiAgdGhpcy5zYWZlRGVzY3JpcHRvcnMgPSB0cnVlO1xufTtcbnZhciBjYW5NZXJnZUdsb2JhbFN0YXRlID0gdHJ1ZTtcbnZhciBpc29sYXRlQ2FsbGVkID0gZmFsc2U7XG52YXIgZ2xvYmFsU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgZ2xvYmFsID0gLyojX19QVVJFX18qL2dldEdsb2JhbCgpO1xuICBpZiAoZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPiAwICYmICFnbG9iYWwuX19tb2J4R2xvYmFscykge1xuICAgIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMgJiYgZ2xvYmFsLl9fbW9ieEdsb2JhbHMudmVyc2lvbiAhPT0gbmV3IE1vYlhHbG9iYWxzKCkudmVyc2lvbikge1xuICAgIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICAvLyBCZWNhdXNlIHRoaXMgaXMgYSBJSUZFIHdlIG5lZWQgdG8gbGV0IGlzb2xhdGVDYWxsZWQgYSBjaGFuY2UgdG8gY2hhbmdlXG4gICAgLy8gc28gd2UgcnVuIGl0IGFmdGVyIHRoZSBldmVudCBsb29wIGNvbXBsZXRlZCBhdCBsZWFzdCAxIGl0ZXJhdGlvblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc29sYXRlQ2FsbGVkKSB7XG4gICAgICAgIGRpZSgzNSk7XG4gICAgICB9XG4gICAgfSwgMSk7XG4gICAgcmV0dXJuIG5ldyBNb2JYR2xvYmFscygpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5fX21vYnhHbG9iYWxzKSB7XG4gICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgKz0gMTtcbiAgICBpZiAoIWdsb2JhbC5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRCkge1xuICAgICAgZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEID0ge307XG4gICAgfSAvLyBtYWtlIG1lcmdlIGJhY2t3YXJkIGNvbXBhdGlibGVcbiAgICByZXR1cm4gZ2xvYmFsLl9fbW9ieEdsb2JhbHM7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPSAxO1xuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscyA9IC8qI19fUFVSRV9fKi9uZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufSgpO1xuZnVuY3Rpb24gaXNvbGF0ZUdsb2JhbFN0YXRlKCkge1xuICBpZiAoZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucy5sZW5ndGggfHwgZ2xvYmFsU3RhdGUuaW5CYXRjaCB8fCBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpIHtcbiAgICBkaWUoMzYpO1xuICB9XG4gIGlzb2xhdGVDYWxsZWQgPSB0cnVlO1xuICBpZiAoY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcbiAgICBpZiAoLS1nbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9PT0gMCkge1xuICAgICAgZ2xvYmFsLl9fbW9ieEdsb2JhbHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdsb2JhbFN0YXRlID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFN0YXRlKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGU7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHk7IHRoaXMgd2lsbCBicmVhayB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgZXhpc3Rpbmcgb2JzZXJ2YWJsZXMsXG4gKiBidXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGJhY2sgYXQgYSBzdGFibGUgc3RhdGUgYWZ0ZXIgdGhyb3dpbmcgZXJyb3JzXG4gKi9cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XG4gIHZhciBkZWZhdWx0R2xvYmFscyA9IG5ldyBNb2JYR2xvYmFscygpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdEdsb2JhbHMpIHtcbiAgICBpZiAocGVyc2lzdGVudEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgZ2xvYmFsU3RhdGVba2V5XSA9IGRlZmF1bHRHbG9iYWxzW2tleV07XG4gICAgfVxuICB9XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gIWdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBoYXNPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnNfICYmIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID4gMDtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc187XG59XG4vLyBmdW5jdGlvbiBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZTogSU9ic2VydmFibGUpIHtcbi8vICAgICBjb25zdCBsaXN0ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNcbi8vICAgICBjb25zdCBtYXAgPSBvYnNlcnZhYmxlLm9ic2VydmVyc0luZGV4ZXNcbi8vICAgICBjb25zdCBsID0gbGlzdC5sZW5ndGhcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBpZCA9IGxpc3RbaV0uX19tYXBpZFxuLy8gICAgICAgICBpZiAoaSkge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KG1hcFtpZF0gPT09IGksIFwiSU5URVJOQUwgRVJST1IgbWFwcyBkZXJpdmF0aW9uLl9fbWFwaWQgdG8gaW5kZXggaW4gbGlzdFwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudCghKGlkIGluIG1hcCksIFwiSU5URVJOQUwgRVJST1Igb2JzZXJ2ZXIgb24gaW5kZXggMCBzaG91bGRuJ3QgYmUgaGVsZCBpbiBtYXAuXCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGludmFyaWFudChcbi8vICAgICAgICAgbGlzdC5sZW5ndGggPT09IDAgfHwgT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPT09IGxpc3QubGVuZ3RoIC0gMSxcbi8vICAgICAgICAgXCJJTlRFUk5BTCBFUlJPUiB0aGVyZSBpcyBubyBqdW5rIGluIG1hcFwiXG4vLyAgICAgKVxuLy8gfVxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQobm9kZS5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IsIGNhbiBhZGQgb25seSBkZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgYWRkIGFscmVhZHkgYWRkZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uYWRkKG5vZGUpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA+IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGVfKSB7XG4gICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGVfO1xuICB9XG4gIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBkaWRuJ3QgYWRkIG5vZGVcIik7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiwgcmVtb3ZlIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzX1tcImRlbGV0ZVwiXShub2RlKTtcbiAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgLy8gZGVsZXRpbmcgbGFzdCBvYnNlcnZlclxuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfVxuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlMlwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKSB7XG4gIGlmIChvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPT09IGZhbHNlKSB7XG4gICAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5sZW5ndGggPT09IDAsIFwiSU5URVJOQUwgRVJST1IsIHNob3VsZCBvbmx5IHF1ZXVlIGZvciB1bm9ic2VydmF0aW9uIHVub2JzZXJ2ZWQgb2JzZXJ2YWJsZXNcIik7XG4gICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uID0gdHJ1ZTtcbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgfVxufVxuLyoqXG4gKiBCYXRjaCBzdGFydHMgYSB0cmFuc2FjdGlvbiwgYXQgbGVhc3QgZm9yIHB1cnBvc2VzIG9mIG1lbW9pemluZyBDb21wdXRlZFZhbHVlcyB3aGVuIG5vdGhpbmcgZWxzZSBkb2VzLlxuICogRHVyaW5nIGEgYmF0Y2ggYG9uQmVjb21lVW5vYnNlcnZlZGAgd2lsbCBiZSBjYWxsZWQgYXQgbW9zdCBvbmNlIHBlciBvYnNlcnZhYmxlLlxuICogQXZvaWRzIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG59XG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgaWYgKC0tZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCkge1xuICAgIHJ1blJlYWN0aW9ucygpO1xuICAgIC8vIHRoZSBiYXRjaCBpcyBhY3R1YWxseSBhYm91dCB0byBmaW5pc2gsIGFsbCB1bm9ic2VydmluZyBzaG91bGQgaGFwcGVuIGhlcmUuXG4gICAgdmFyIGxpc3QgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGxpc3RbaV07XG4gICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSBmYWxzZTtcbiAgICAgIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAob2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWQpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIG9ic2VydmFibGUgaGFkIHJlYWN0aXZlIG9ic2VydmVycywgdHJpZ2dlciB0aGUgaG9va3NcbiAgICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZCA9IGZhbHNlO1xuICAgICAgICAgIG9ic2VydmFibGUub25CVU8oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgICAgICAvLyBjb21wdXRlZCB2YWx1ZXMgYXJlIGF1dG9tYXRpY2FsbHkgdGVhcmVkIGRvd24gd2hlbiB0aGUgbGFzdCBvYnNlcnZlciBsZWF2ZXNcbiAgICAgICAgICAvLyB0aGlzIHByb2Nlc3MgaGFwcGVucyByZWN1cnNpdmVseSwgdGhpcyBjb21wdXRlZCBtaWdodCBiZSB0aGUgbGFzdCBvYnNlcnZhYmUgb2YgYW5vdGhlciwgZXRjLi5cbiAgICAgICAgICBvYnNlcnZhYmxlLnN1c3BlbmRfKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgaWYgKGRlcml2YXRpb24gIT09IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgb3B0aW1pemF0aW9uLCBnaXZlIGVhY2ggZGVyaXZhdGlvbiBydW4gYW4gdW5pcXVlIGlkIChydW5JZClcbiAgICAgKiBDaGVjayBpZiBsYXN0IHRpbWUgdGhpcyBvYnNlcnZhYmxlIHdhcyBhY2Nlc3NlZCB0aGUgc2FtZSBydW5JZCBpcyB1c2VkXG4gICAgICogaWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlIHJlbGF0aW9uIGlzIGFscmVhZHkga25vd25cbiAgICAgKi9cbiAgICBpZiAoZGVyaXZhdGlvbi5ydW5JZF8gIT09IG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnlfKSB7XG4gICAgICBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5XyA9IGRlcml2YXRpb24ucnVuSWRfO1xuICAgICAgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuICAgICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfW2Rlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8rK10gPSBvYnNlcnZhYmxlO1xuICAgICAgaWYgKCFvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZCAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQpIHtcbiAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlLm9uQk8oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkO1xuICB9IGVsc2UgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmIGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwKSB7XG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIGZ1bmN0aW9uIGludmFyaWFudExPUyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSwgbXNnOiBzdHJpbmcpIHtcbi8vICAgICAvLyBpdCdzIGV4cGVuc2l2ZSBzbyBiZXR0ZXIgbm90IHJ1biBpdCBpbiBwcm9kdWNpdG9uLiBidXQgdGVtcG9yYXJpbHkgaGVscGZ1bCBmb3IgdGVzdGluZ1xuLy8gICAgIGNvbnN0IG1pbiA9IGdldE9ic2VydmVycyhvYnNlcnZhYmxlKS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIuZGVwZW5kZW5jaWVzU3RhdGUpLCAyKVxuLy8gICAgIGlmIChtaW4gPj0gb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlKSByZXR1cm4gLy8gPC0gdGhlIG9ubHkgYXNzdW1wdGlvbiBhYm91dCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWBcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4vLyAgICAgICAgIFwibG93ZXN0T2JzZXJ2ZXJTdGF0ZSBpcyB3cm9uZyBmb3IgXCIgK1xuLy8gICAgICAgICAgICAgbXNnICtcbi8vICAgICAgICAgICAgIFwiIGJlY2F1c2UgXCIgK1xuLy8gICAgICAgICAgICAgbWluICtcbi8vICAgICAgICAgICAgIFwiIDwgXCIgK1xuLy8gICAgICAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXG4vLyAgICAgKVxuLy8gfVxuLyoqXG4gKiBOT1RFOiBjdXJyZW50IHByb3BhZ2F0aW9uIG1lY2hhbmlzbSB3aWxsIGluIGNhc2Ugb2Ygc2VsZiByZXJ1bmluZyBhdXRvcnVucyBiZWhhdmUgdW5leHBlY3RlZGx5XG4gKiBJdCB3aWxsIHByb3BhZ2F0ZSBjaGFuZ2VzIHRvIG9ic2VydmVycyBmcm9tIHByZXZpb3VzIHJ1blxuICogSXQncyBoYXJkIG9yIG1heWJlIGltcG9zc2libGUgKHdpdGggcmVhc29uYWJsZSBwZXJmKSB0byBnZXQgaXQgcmlnaHQgd2l0aCBjdXJyZW50IGFwcHJvYWNoXG4gKiBIb3BlZnVsbHkgc2VsZiByZXJ1bmluZyBhdXRvcnVucyBhcmVuJ3QgYSBmZWF0dXJlIHBlb3BsZSBzaG91bGQgZGVwZW5kIG9uXG4gKiBBbHNvIG1vc3QgYmFzaWMgdXNlIGNhc2VzIHNob3VsZCBiZSBva1xuICovXG4vLyBDYWxsZWQgYnkgQXRvbSB3aGVuIGl0cyB2YWx1ZSBjaGFuZ2VzXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgIHJldHVybjtcbiAgfVxuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICAvLyBJZGVhbGx5IHdlIHVzZSBmb3IuLm9mIGhlcmUsIGJ1dCB0aGUgZG93bmNvbXBpbGVkIHZlcnNpb24gaXMgcmVhbGx5IHNsb3cuLi5cbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGQuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgfVxuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cbiAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgfSk7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgZW5kXCIpO1xufVxuLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgIHJldHVybjtcbiAgfVxuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8gLy8gdGhpcyBoYXBwZW5zIGR1cmluZyBjb21wdXRpbmcgb2YgYGRgLCBqdXN0IGtlZXAgbG93ZXN0T2JzZXJ2ZXJTdGF0ZSB1cCB0byBkYXRlLlxuICAgICkge1xuICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICAgIH1cbiAgfSk7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBlbmRcIik7XG59XG4vLyBVc2VkIGJ5IGNvbXB1dGVkIHdoZW4gaXRzIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IHdlIGRvbid0IHdhbid0IHRvIGltbWVkaWF0ZWx5IHJlY29tcHV0ZS5cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG4gIH0pO1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5mdW5jdGlvbiBsb2dUcmFjZUluZm8oZGVyaXZhdGlvbiwgb2JzZXJ2YWJsZSkge1xuICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGludmFsaWRhdGVkIGR1ZSB0byBhIGNoYW5nZSBpbjogJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJ1wiKTtcbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLkJSRUFLKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgcHJpbnREZXBUcmVlKGdldERlcGVuZGVuY3lUcmVlKGRlcml2YXRpb24pLCBsaW5lcywgMSk7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbmV3IEZ1bmN0aW9uKFwiZGVidWdnZXI7XFxuLypcXG5UcmFjaW5nICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIidcXG5cXG5Zb3UgYXJlIGVudGVyaW5nIHRoaXMgYnJlYWsgcG9pbnQgYmVjYXVzZSBkZXJpdmF0aW9uICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgYmVpbmcgdHJhY2VkIGFuZCAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGlzIG5vdyBmb3JjaW5nIGl0IHRvIHVwZGF0ZS5cXG5KdXN0IGZvbGxvdyB0aGUgc3RhY2t0cmFjZSB5b3Ugc2hvdWxkIG5vdyBzZWUgaW4gdGhlIGRldnRvb2xzIHRvIHNlZSBwcmVjaXNlbHkgd2hhdCBwaWVjZSBvZiB5b3VyIGNvZGUgaXMgY2F1c2luZyB0aGlzIHVwZGF0ZVxcblRoZSBzdGFja2ZyYW1lIHlvdSBhcmUgbG9va2luZyBmb3IgaXMgYXQgbGVhc3QgfjYtOCBzdGFjay1mcmFtZXMgdXAuXFxuXFxuXCIgKyAoZGVyaXZhdGlvbiBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUgPyBkZXJpdmF0aW9uLmRlcml2YXRpb24udG9TdHJpbmcoKS5yZXBsYWNlKC9bKl1cXC8vZywgXCIvXCIpIDogXCJcIikgKyBcIlxcblxcblRoZSBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgZGVyaXZhdGlvbiBhcmU6XFxuXFxuXCIgKyBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG4qL1xcbiAgICBcIikoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJpbnREZXBUcmVlKHRyZWUsIGxpbmVzLCBkZXB0aCkge1xuICBpZiAobGluZXMubGVuZ3RoID49IDEwMDApIHtcbiAgICBsaW5lcy5wdXNoKFwiKGFuZCBtYW55IG1vcmUpXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBsaW5lcy5wdXNoKFwiXCIgKyBcIlxcdFwiLnJlcGVhdChkZXB0aCAtIDEpICsgdHJlZS5uYW1lKTtcbiAgaWYgKHRyZWUuZGVwZW5kZW5jaWVzKSB7XG4gICAgdHJlZS5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBwcmludERlcFRyZWUoY2hpbGQsIGxpbmVzLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0aW9uKG5hbWVfLCBvbkludmFsaWRhdGVfLCBlcnJvckhhbmRsZXJfLCByZXF1aXJlc09ic2VydmFibGVfKSB7XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDogXCJSZWFjdGlvblwiO1xuICAgIH1cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2aW5nXyA9IFtdO1xuICAgIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAgIHRoaXMubmV3T2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy5mbGFnc18gPSAwO1xuICAgIHRoaXMuaXNUcmFjaW5nXyA9IFRyYWNlTW9kZS5OT05FO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSBvbkludmFsaWRhdGVfO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IGVycm9ySGFuZGxlcl87XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gcmVxdWlyZXNPYnNlcnZhYmxlXztcbiAgfVxuICB2YXIgX3Byb3RvID0gUmVhY3Rpb24ucHJvdG90eXBlO1xuICBfcHJvdG8ub25CZWNvbWVTdGFsZV8gPSBmdW5jdGlvbiBvbkJlY29tZVN0YWxlXygpIHtcbiAgICB0aGlzLnNjaGVkdWxlXygpO1xuICB9O1xuICBfcHJvdG8uc2NoZWR1bGVfID0gZnVuY3Rpb24gc2NoZWR1bGVfKCkge1xuICAgIGlmICghdGhpcy5pc1NjaGVkdWxlZCkge1xuICAgICAgdGhpcy5pc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICBydW5SZWFjdGlvbnMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cbiAgICovO1xuICBfcHJvdG8ucnVuUmVhY3Rpb25fID0gZnVuY3Rpb24gcnVuUmVhY3Rpb25fKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmlzVHJhY2tQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZV8oKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuaXNUcmFja1BlbmRpbmcgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIG9uSW52YWxpZGF0ZSBkaWRuJ3QgdHJpZ2dlciB0cmFjayByaWdodCBhd2F5Li5cbiAgICAgICAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgICAgIHR5cGU6IFwic2NoZWR1bGVkLXJlYWN0aW9uXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldjtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udHJhY2sgPSBmdW5jdGlvbiB0cmFjayhmbikge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIC8vIGNvbnNvbGUud2FybihcIlJlYWN0aW9uIGFscmVhZHkgZGlzcG9zZWRcIikgLy8gTm90ZTogTm90IGEgd2FybmluZyAvIGVycm9yIGluIG1vYnggNCBlaXRoZXJcbiAgICB9XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBub3RpZnkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgc3RhcnRUaW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5KSB7XG4gICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInJlYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdmFyIHByZXZSZWFjdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDsgLy8gcmVhY3Rpb25zIGNvdWxkIGNyZWF0ZSByZWFjdGlvbnMuLi5cbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCBmbiwgdW5kZWZpbmVkKTtcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2UmVhY3Rpb247XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2tQZW5kaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgLy8gZGlzcG9zZWQgZHVyaW5nIGxhc3QgcnVuLiBDbGVhbiB1cCBldmVyeXRoaW5nIHRoYXQgd2FzIGJvdW5kIGFmdGVyIHRoZSBkaXNwb3NlIGNhbGwuXG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICB9XG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHtcbiAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhyZXN1bHQuY2F1c2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeSkge1xuICAgICAgc3B5UmVwb3J0RW5kKHtcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVuZEJhdGNoKCk7XG4gIH07XG4gIF9wcm90by5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fID0gZnVuY3Rpb24gcmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlcnJvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyXykge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXJfKGVycm9yLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCIgOiBcIlttb2J4XSB1bmNhdWdodCBlcnJvciBpbiAnXCIgKyB0aGlzICsgXCInXCI7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgIC8qKiBJZiBkZWJ1Z2dpbmcgYnJvdWdodCB5b3UgaGVyZSwgcGxlYXNlLCByZWFkIHRoZSBhYm92ZSBtZXNzYWdlIDotKS4gVG54ISAqL1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gKGVycm9yIGluIHJlYWN0aW9uICdcIiArIHRoaXMubmFtZV8gKyBcIicgc3VwcHJlc3NlZCwgZml4IGVycm9yIG9mIGNhdXNpbmcgYWN0aW9uIGJlbG93KVwiKTtcbiAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IFwiXCIgKyBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZihlcnJvciwgX3RoaXMpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgIC8vIGlmIGRpc3Bvc2VkIHdoaWxlIHJ1bm5pbmcsIGNsZWFuIHVwIGxhdGVyLiBNYXliZSBub3Qgb3B0aW1hbCwgYnV0IHJhcmUgY2FzZVxuICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldERpc3Bvc2VyXyA9IGZ1bmN0aW9uIGdldERpc3Bvc2VyXyhhYm9ydFNpZ25hbCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBkaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIF90aGlzMi5kaXNwb3NlKCk7XG4gICAgICBhYm9ydFNpZ25hbCA9PSBudWxsIHx8IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT0gbnVsbCB8fCBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZGlzcG9zZSk7XG4gICAgfTtcbiAgICBhYm9ydFNpZ25hbCA9PSBudWxsIHx8IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgPT0gbnVsbCB8fCBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZGlzcG9zZSk7XG4gICAgZGlzcG9zZVskbW9ieF0gPSB0aGlzO1xuICAgIHJldHVybiBkaXNwb3NlO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJSZWFjdGlvbltcIiArIHRoaXMubmFtZV8gKyBcIl1cIjtcbiAgfTtcbiAgX3Byb3RvLnRyYWNlID0gZnVuY3Rpb24gdHJhY2UkMShlbnRlckJyZWFrUG9pbnQpIHtcbiAgICBpZiAoZW50ZXJCcmVha1BvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjZSh0aGlzLCBlbnRlckJyZWFrUG9pbnQpO1xuICB9O1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlYWN0aW9uLCBbe1xuICAgIGtleTogXCJpc0Rpc3Bvc2VkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNEaXNwb3NlZE1hc2tfKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmlzRGlzcG9zZWRNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1NjaGVkdWxlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmlzU2NoZWR1bGVkTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNTY2hlZHVsZWRNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RyYWNrUGVuZGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGdldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmlzVHJhY2tQZW5kaW5nTWFza18pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuZmxhZ3NfID0gc2V0RmxhZyh0aGlzLmZsYWdzXywgUmVhY3Rpb24uaXNUcmFja1BlbmRpbmdNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1J1bm5pbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5pc1J1bm5pbmdNYXNrXyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5mbGFnc18gPSBzZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5pc1J1bm5pbmdNYXNrXywgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaWZmVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRGbGFnKHRoaXMuZmxhZ3NfLCBSZWFjdGlvbi5kaWZmVmFsdWVNYXNrXykgPyAxIDogMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLmZsYWdzXyA9IHNldEZsYWcodGhpcy5mbGFnc18sIFJlYWN0aW9uLmRpZmZWYWx1ZU1hc2tfLCBuZXdWYWx1ZSA9PT0gMSA/IHRydWUgOiBmYWxzZSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5SZWFjdGlvbi5pc0Rpc3Bvc2VkTWFza18gPSAxO1xuUmVhY3Rpb24uaXNTY2hlZHVsZWRNYXNrXyA9IDI7XG5SZWFjdGlvbi5pc1RyYWNrUGVuZGluZ01hc2tfID0gNDtcblJlYWN0aW9uLmlzUnVubmluZ01hc2tfID0gODtcblJlYWN0aW9uLmRpZmZWYWx1ZU1hc2tfID0gMTY7XG5mdW5jdGlvbiBvblJlYWN0aW9uRXJyb3IoaGFuZGxlcikge1xuICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBNYWdpYyBudW1iZXIgYWxlcnQhXG4gKiBEZWZpbmVzIHdpdGhpbiBob3cgbWFueSB0aW1lcyBhIHJlYWN0aW9uIGlzIGFsbG93ZWQgdG8gcmUtdHJpZ2dlciBpdHNlbGZcbiAqIHVudGlsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGlzIGlzIGdvbm5hIGJlIGEgbmV2ZXIgZW5kaW5nIGxvb3AuLi5cbiAqL1xudmFyIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TID0gMTAwO1xudmFyIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICByZXR1cm4gZigpO1xufTtcbmZ1bmN0aW9uIHJ1blJlYWN0aW9ucygpIHtcbiAgLy8gVHJhbXBvbGluaW5nLCBpZiBydW5SZWFjdGlvbnMgYXJlIGFscmVhZHkgcnVubmluZywgbmV3IHJlYWN0aW9ucyB3aWxsIGJlIHBpY2tlZCB1cFxuICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XG59XG5mdW5jdGlvbiBydW5SZWFjdGlvbnNIZWxwZXIoKSB7XG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IHRydWU7XG4gIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIC8vIFdoaWxlIHJ1bm5pbmcgcmVhY3Rpb25zLCBuZXcgcmVhY3Rpb25zIG1pZ2h0IGJlIHRyaWdnZXJlZC5cbiAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcbiAgLy8gd2UgY29udmVyZ2UgdG8gbm8gcmVtYWluaW5nIHJlYWN0aW9ucyBhZnRlciBhIHdoaWxlLlxuICB3aGlsZSAoYWxsUmVhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoKytpdGVyYXRpb25zID09PSBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUykge1xuICAgICAgY29uc29sZS5lcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uIGRvZXNuJ3QgY29udmVyZ2UgdG8gYSBzdGFibGUgc3RhdGUgYWZ0ZXIgXCIgKyBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyArIFwiIGl0ZXJhdGlvbnMuXCIgKyAoXCIgUHJvYmFibHkgdGhlcmUgaXMgYSBjeWNsZSBpbiB0aGUgcmVhY3RpdmUgZnVuY3Rpb246IFwiICsgYWxsUmVhY3Rpb25zWzBdKSA6IFwiW21vYnhdIGN5Y2xlIGluIHJlYWN0aW9uOiBcIiArIGFsbFJlYWN0aW9uc1swXSk7XG4gICAgICBhbGxSZWFjdGlvbnMuc3BsaWNlKDApOyAvLyBjbGVhciByZWFjdGlvbnNcbiAgICB9XG4gICAgdmFyIHJlbWFpbmluZ1JlYWN0aW9ucyA9IGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZW1haW5pbmdSZWFjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZW1haW5pbmdSZWFjdGlvbnNbaV0ucnVuUmVhY3Rpb25fKCk7XG4gICAgfVxuICB9XG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xufVxudmFyIGlzUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIlJlYWN0aW9uXCIsIFJlYWN0aW9uKTtcbmZ1bmN0aW9uIHNldFJlYWN0aW9uU2NoZWR1bGVyKGZuKSB7XG4gIHZhciBiYXNlU2NoZWR1bGVyID0gcmVhY3Rpb25TY2hlZHVsZXI7XG4gIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICAgIHJldHVybiBmbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmFzZVNjaGVkdWxlcihmKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTcHlFbmFibGVkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEhZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNweVJlcG9ydChldmVudCkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRlYWQgY29kZSBlbGltaW5hdGlvbiBjYW4gZG8gdGhlIHJlc3RcbiAgaWYgKCFnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXShldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNweVJlcG9ydFN0YXJ0KGV2ZW50KSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoYW5nZSA9IF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgIHNweVJlcG9ydFN0YXJ0OiB0cnVlXG4gIH0pO1xuICBzcHlSZXBvcnQoY2hhbmdlKTtcbn1cbnZhciBFTkRfRVZFTlQgPSB7XG4gIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICBzcHlSZXBvcnRFbmQ6IHRydWVcbn07XG5mdW5jdGlvbiBzcHlSZXBvcnRFbmQoY2hhbmdlKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGNoYW5nZSkge1xuICAgIHNweVJlcG9ydChfZXh0ZW5kcyh7fSwgY2hhbmdlLCB7XG4gICAgICB0eXBlOiBcInJlcG9ydC1lbmRcIixcbiAgICAgIHNweVJlcG9ydEVuZDogdHJ1ZVxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBzcHlSZXBvcnQoRU5EX0VWRU5UKTtcbiAgfVxufVxuZnVuY3Rpb24gc3B5KGxpc3RlbmVyKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieC5zcHldIElzIGEgbm8tb3AgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBBQ1RJT04gPSBcImFjdGlvblwiO1xudmFyIEFDVElPTl9CT1VORCA9IFwiYWN0aW9uLmJvdW5kXCI7XG52YXIgQVVUT0FDVElPTiA9IFwiYXV0b0FjdGlvblwiO1xudmFyIEFVVE9BQ1RJT05fQk9VTkQgPSBcImF1dG9BY3Rpb24uYm91bmRcIjtcbnZhciBERUZBVUxUX0FDVElPTl9OQU1FID0gXCI8dW5uYW1lZCBhY3Rpb24+XCI7XG52YXIgYWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFDVElPTik7XG52YXIgYWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OX0JPVU5ELCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT04sIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZVxufSk7XG52YXIgYXV0b0FjdGlvbkJvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT05fQk9VTkQsIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZSxcbiAgYm91bmQ6IHRydWVcbn0pO1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uRmFjdG9yeShhdXRvQWN0aW9uKSB7XG4gIHZhciByZXMgPSBmdW5jdGlvbiBhY3Rpb24oYXJnMSwgYXJnMikge1xuICAgIC8vIGFjdGlvbihmbigpIHt9KVxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBhcmcxLCBhdXRvQWN0aW9uKTtcbiAgICB9XG4gICAgLy8gYWN0aW9uKFwibmFtZVwiLCBmbigpIHt9KVxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEsIGFyZzIsIGF1dG9BY3Rpb24pO1xuICAgIH1cbiAgICAvLyBAYWN0aW9uICgyMDIyLjMgRGVjb3JhdG9ycylcbiAgICBpZiAoaXMyMDIyM0RlY29yYXRvcihhcmcyKSkge1xuICAgICAgcmV0dXJuIChhdXRvQWN0aW9uID8gYXV0b0FjdGlvbkFubm90YXRpb24gOiBhY3Rpb25Bbm5vdGF0aW9uKS5kZWNvcmF0ZV8yMDIyM18oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIC8vIEBhY3Rpb25cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbiA/IGF1dG9BY3Rpb25Bbm5vdGF0aW9uIDogYWN0aW9uQW5ub3RhdGlvbik7XG4gICAgfVxuICAgIC8vIGFjdGlvbihcIm5hbWVcIikgJiBAYWN0aW9uKFwibmFtZVwiKVxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcxKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihhdXRvQWN0aW9uID8gQVVUT0FDVElPTiA6IEFDVElPTiwge1xuICAgICAgICBuYW1lOiBhcmcxLFxuICAgICAgICBhdXRvQWN0aW9uOiBhdXRvQWN0aW9uXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGRpZShcIkludmFsaWQgYXJndW1lbnRzIGZvciBgYWN0aW9uYFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59XG52YXIgYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkZhY3RvcnkoZmFsc2UpO1xuT2JqZWN0LmFzc2lnbihhY3Rpb24sIGFjdGlvbkFubm90YXRpb24pO1xudmFyIGF1dG9BY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeSh0cnVlKTtcbk9iamVjdC5hc3NpZ24oYXV0b0FjdGlvbiwgYXV0b0FjdGlvbkFubm90YXRpb24pO1xuYWN0aW9uLmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oYWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmF1dG9BY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIHJ1bkluQWN0aW9uKGZuKSB7XG4gIHJldHVybiBleGVjdXRlQWN0aW9uKGZuLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgZmFsc2UsIGZuLCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNBY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhpbmcpICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmFtZWQgcmVhY3RpdmUgdmlldyBhbmQga2VlcHMgaXQgYWxpdmUsIHNvIHRoYXQgdGhlIHZpZXcgaXMgYWx3YXlzXG4gKiB1cGRhdGVkIGlmIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMsIGV2ZW4gd2hlbiB0aGUgdmlldyBpcyBub3QgZnVydGhlciB1c2VkIGJ5IHNvbWV0aGluZyBlbHNlLlxuICogQHBhcmFtIHZpZXcgVGhlIHJlYWN0aXZlIHZpZXdcbiAqIEByZXR1cm5zIGRpc3Bvc2VyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzdG9wIHRoZSB2aWV3IGZyb20gYmVpbmcgdXBkYXRlZCBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiBhdXRvcnVuKHZpZXcsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUsIF9vcHRzLCBfb3B0czIsIF9vcHRzMztcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbih2aWV3KSkge1xuICAgICAgZGllKFwiQXV0b3J1biBleHBlY3RzIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmIChpc0FjdGlvbih2aWV3KSkge1xuICAgICAgZGllKFwiQXV0b3J1biBkb2VzIG5vdCBhY2NlcHQgYWN0aW9ucyBzaW5jZSBhY3Rpb25zIGFyZSB1bnRyYWNrYWJsZVwiKTtcbiAgICB9XG4gIH1cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHZpZXcubmFtZSB8fCBcIkF1dG9ydW5AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXV0b3J1blwiO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuICBpZiAocnVuU3luYykge1xuICAgIC8vIG5vcm1hbCBhdXRvcnVuXG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xuICAgIC8vIGRlYm91bmNlZCBhdXRvcnVuXG4gICAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXJlYWN0aW9uLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJlYWN0aW9uLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWN0aW9uUnVubmVyKCkge1xuICAgIHZpZXcocmVhY3Rpb24pO1xuICB9XG4gIGlmICghKChfb3B0czIgPSBvcHRzKSAhPSBudWxsICYmIChfb3B0czIgPSBfb3B0czIuc2lnbmFsKSAhPSBudWxsICYmIF9vcHRzMi5hYm9ydGVkKSkge1xuICAgIHJlYWN0aW9uLnNjaGVkdWxlXygpO1xuICB9XG4gIHJldHVybiByZWFjdGlvbi5nZXREaXNwb3Nlcl8oKF9vcHRzMyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0czMuc2lnbmFsKTtcbn1cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oZikge1xuICByZXR1cm4gZigpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMuc2NoZWR1bGVyID8gb3B0cy5zY2hlZHVsZXIgOiBvcHRzLmRlbGF5ID8gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmLCBvcHRzLmRlbGF5KTtcbiAgfSA6IHJ1bjtcbn1cbmZ1bmN0aW9uIHJlYWN0aW9uKGV4cHJlc3Npb24sIGVmZmVjdCwgb3B0cykge1xuICB2YXIgX29wdHMkbmFtZTIsIF9vcHRzNCwgX29wdHM1O1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IEVNUFRZX09CSkVDVDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGV4cHJlc3Npb24pIHx8ICFpc0Z1bmN0aW9uKGVmZmVjdCkpIHtcbiAgICAgIGRpZShcIkZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnQgdG8gcmVhY3Rpb24gc2hvdWxkIGJlIGZ1bmN0aW9uc1wiKTtcbiAgICB9XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdHMpKSB7XG4gICAgICBkaWUoXCJUaGlyZCBhcmd1bWVudCBvZiByZWFjdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICB9XG4gIH1cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZTIgPSBvcHRzLm5hbWUpICE9IG51bGwgPyBfb3B0cyRuYW1lMiA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiUmVhY3Rpb25AXCIgKyBnZXROZXh0SWQoKSA6IFwiUmVhY3Rpb25cIjtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGFjdGlvbihuYW1lLCBvcHRzLm9uRXJyb3IgPyB3cmFwRXJyb3JIYW5kbGVyKG9wdHMub25FcnJvciwgZWZmZWN0KSA6IGVmZmVjdCk7XG4gIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xuICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7XG4gIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgZXF1YWxzID0gb3B0cy5jb21wYXJlU3RydWN0dXJhbCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBvcHRzLmVxdWFscyB8fCBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gIHZhciByID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmlyc3RUaW1lIHx8IHJ1blN5bmMpIHtcbiAgICAgIHJlYWN0aW9uUnVubmVyKCk7XG4gICAgfSBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlcihyZWFjdGlvblJ1bm5lcik7XG4gICAgfVxuICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZiAoci5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG9sZFZhbHVlID0gdmFsdWU7XG4gICAgci50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ocik7XG4gICAgICB9KTtcbiAgICAgIGNoYW5nZWQgPSBmaXJzdFRpbWUgfHwgIWVxdWFscyh2YWx1ZSwgbmV4dFZhbHVlKTtcbiAgICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChmaXJzdFRpbWUgJiYgb3B0cy5maXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIH0gZWxzZSBpZiAoIWZpcnN0VGltZSAmJiBjaGFuZ2VkKSB7XG4gICAgICBlZmZlY3RBY3Rpb24odmFsdWUsIG9sZFZhbHVlLCByKTtcbiAgICB9XG4gICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gIH1cbiAgaWYgKCEoKF9vcHRzNCA9IG9wdHMpICE9IG51bGwgJiYgKF9vcHRzNCA9IF9vcHRzNC5zaWduYWwpICE9IG51bGwgJiYgX29wdHM0LmFib3J0ZWQpKSB7XG4gICAgci5zY2hlZHVsZV8oKTtcbiAgfVxuICByZXR1cm4gci5nZXREaXNwb3Nlcl8oKF9vcHRzNSA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0czUuc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIHdyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBiYXNlRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJhc2VGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ySGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE9OX0JFQ09NRV9PQlNFUlZFRCA9IFwib25CT1wiO1xudmFyIE9OX0JFQ09NRV9VTk9CU0VSVkVEID0gXCJvbkJVT1wiO1xuZnVuY3Rpb24gb25CZWNvbWVPYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cbmZ1bmN0aW9uIG9uQmVjb21lVW5vYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfVU5PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0SG9vayhob29rLCB0aGluZywgYXJnMiwgYXJnMykge1xuICB2YXIgYXRvbSA9IHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIgPyBnZXRBdG9tKHRoaW5nLCBhcmcyKSA6IGdldEF0b20odGhpbmcpO1xuICB2YXIgY2IgPSBpc0Z1bmN0aW9uKGFyZzMpID8gYXJnMyA6IGFyZzI7XG4gIHZhciBsaXN0ZW5lcnNLZXkgPSBob29rICsgXCJMXCI7XG4gIGlmIChhdG9tW2xpc3RlbmVyc0tleV0pIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0uYWRkKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0gPSBuZXcgU2V0KFtjYl0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvb2tMaXN0ZW5lcnMgPSBhdG9tW2xpc3RlbmVyc0tleV07XG4gICAgaWYgKGhvb2tMaXN0ZW5lcnMpIHtcbiAgICAgIGhvb2tMaXN0ZW5lcnNbXCJkZWxldGVcIl0oY2IpO1xuICAgICAgaWYgKGhvb2tMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgYXRvbVtsaXN0ZW5lcnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIE5FVkVSID0gXCJuZXZlclwiO1xudmFyIEFMV0FZUyA9IFwiYWx3YXlzXCI7XG52YXIgT0JTRVJWRUQgPSBcIm9ic2VydmVkXCI7XG4vLyBjb25zdCBJRl9BVkFJTEFCTEUgPSBcImlmYXZhaWxhYmxlXCJcbmZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzb2xhdGVHbG9iYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgIGlzb2xhdGVHbG9iYWxTdGF0ZSgpO1xuICB9XG4gIHZhciB1c2VQcm94aWVzID0gb3B0aW9ucy51c2VQcm94aWVzLFxuICAgIGVuZm9yY2VBY3Rpb25zID0gb3B0aW9ucy5lbmZvcmNlQWN0aW9ucztcbiAgaWYgKHVzZVByb3hpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPSB1c2VQcm94aWVzID09PSBBTFdBWVMgPyB0cnVlIDogdXNlUHJveGllcyA9PT0gTkVWRVIgPyBmYWxzZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfVxuICBpZiAodXNlUHJveGllcyA9PT0gXCJpZmF2YWlsYWJsZVwiKSB7XG4gICAgZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcyA9IHRydWU7XG4gIH1cbiAgaWYgKGVuZm9yY2VBY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZWEgPSBlbmZvcmNlQWN0aW9ucyA9PT0gQUxXQVlTID8gQUxXQVlTIDogZW5mb3JjZUFjdGlvbnMgPT09IE9CU0VSVkVEO1xuICAgIGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID0gZWE7XG4gICAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBlYSA9PT0gdHJ1ZSB8fCBlYSA9PT0gQUxXQVlTID8gZmFsc2UgOiB0cnVlO1xuICB9XG4gIFtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgZ2xvYmFsU3RhdGVba2V5XSA9ICEhb3B0aW9uc1trZXldO1xuICAgIH1cbiAgfSk7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9ICFnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiV0FSTklORzogRGVidWcgZmVhdHVyZSBvbmx5LiBNb2JYIHdpbGwgTk9UIHJlY292ZXIgZnJvbSBlcnJvcnMgd2hlbiBgZGlzYWJsZUVycm9yQm91bmRhcmllc2AgaXMgZW5hYmxlZC5cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBzZXRSZWFjdGlvblNjaGVkdWxlcihvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgcHJvcGVydGllcywgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdGVkIDItNCBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVNYXAodGFyZ2V0KSkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIHNob3VsZCBub3QgYmUgdXNlZCBvbiBtYXBzLCB1c2UgbWFwLm1lcmdlIGluc3RlYWRcIik7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSB8fCBpc09ic2VydmFibGUoYW5ub3RhdGlvbnMpKSB7XG4gICAgICBkaWUoXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICB9XG4gIC8vIFB1bGwgZGVzY3JpcHRvcnMgZmlyc3QsIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHByb3BzIGFkZGVkIGJ5IGFkbWluaXN0cmF0aW9uICgkbW9ieClcbiAgdmFyIGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwcm9wZXJ0aWVzKTtcbiAgaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gICAgb3duS2V5cyhkZXNjcmlwdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBhZG0uZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3JzW2tleV0sXG4gICAgICAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhYW5ub3RhdGlvbnMgPyB0cnVlIDoga2V5IGluIGFubm90YXRpb25zID8gYW5ub3RhdGlvbnNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHJldHVybiBub2RlVG9EZXBlbmRlbmN5VHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuZnVuY3Rpb24gbm9kZVRvRGVwZW5kZW5jeVRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKG5vZGUub2JzZXJ2aW5nXyAmJiBub2RlLm9ic2VydmluZ18ubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMgPSB1bmlxdWUobm9kZS5vYnNlcnZpbmdfKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlclRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHJldHVybiBub2RlVG9PYnNlcnZlclRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cbmZ1bmN0aW9uIG5vZGVUb09ic2VydmVyVHJlZShub2RlKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbmFtZTogbm9kZS5uYW1lX1xuICB9O1xuICBpZiAoaGFzT2JzZXJ2ZXJzKG5vZGUpKSB7XG4gICAgcmVzdWx0Lm9ic2VydmVycyA9IEFycmF5LmZyb20oZ2V0T2JzZXJ2ZXJzKG5vZGUpKS5tYXAobm9kZVRvT2JzZXJ2ZXJUcmVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsaXN0KSk7XG59XG5cbnZhciBnZW5lcmF0b3JJZCA9IDA7XG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHRoaXMubWVzc2FnZSA9IFwiRkxPV19DQU5DRUxMRURcIjtcbn1cbkZsb3dDYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xufVxudmFyIGZsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvd1wiKTtcbnZhciBmbG93Qm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvdy5ib3VuZFwiLCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBmbG93ID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oZnVuY3Rpb24gZmxvdyhhcmcxLCBhcmcyKSB7XG4gIC8vIEBmbG93ICgyMDIyLjMgRGVjb3JhdG9ycylcbiAgaWYgKGlzMjAyMjNEZWNvcmF0b3IoYXJnMikpIHtcbiAgICByZXR1cm4gZmxvd0Fubm90YXRpb24uZGVjb3JhdGVfMjAyMjNfKGFyZzEsIGFyZzIpO1xuICB9XG4gIC8vIEBmbG93XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgZmxvd0Fubm90YXRpb24pO1xuICB9XG4gIC8vIGZsb3coZm4pXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIGRpZShcIkZsb3cgZXhwZWN0cyBzaW5nbGUgYXJndW1lbnQgd2l0aCBnZW5lcmF0b3IgZnVuY3Rpb25cIik7XG4gIH1cbiAgdmFyIGdlbmVyYXRvciA9IGFyZzE7XG4gIHZhciBuYW1lID0gZ2VuZXJhdG9yLm5hbWUgfHwgXCI8dW5uYW1lZCBmbG93PlwiO1xuICAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdGovY28vYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIHJlcygpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcnVuSWQgPSArK2dlbmVyYXRvcklkO1xuICAgIHZhciBnZW4gPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGluaXRcIiwgZ2VuZXJhdG9yKS5hcHBseShjdHgsIGFyZ3MpO1xuICAgIHZhciByZWplY3RvcjtcbiAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3RlcElkID0gMDtcbiAgICAgIHJlamVjdG9yID0gcmVqZWN0O1xuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblJlamVjdGVkKGVycikge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbltcInRocm93XCJdKS5jYWxsKGdlbiwgZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbmV4dChyZXQpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmV0ID09IG51bGwgPyB2b2lkIDAgOiByZXQudGhlbikpIHtcbiAgICAgICAgICAvLyBhbiBhc3luYyBpdGVyYXRvclxuICAgICAgICAgIHJldC50aGVuKG5leHQsIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQuZG9uZSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmV0LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdQcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgfVxuICAgICAgb25GdWxmaWxsZWQodW5kZWZpbmVkKTsgLy8ga2ljayBvZmYgdGhlIHByb2Nlc3NcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICAgIGNhbmNlbFByb21pc2UocGVuZGluZ1Byb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHkgYmxvY2sgY2FuIHJldHVybiAob3IgeWllbGQpIHN0dWZmLi5cbiAgICAgICAgdmFyIF9yZXMgPSBnZW5bXCJyZXR1cm5cIl0odW5kZWZpbmVkKTtcbiAgICAgICAgLy8gZWF0IGFueXRoaW5nIHRoYXQgcHJvbWlzZSB3b3VsZCBkbywgaXQncyBjYW5jZWxsZWQhXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG4gICAgICAgIHJlamVjdG9yKG5ldyBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdG9yKGUpOyAvLyB0aGVyZSBjb3VsZCBiZSBhIHRocm93aW5nIGZpbmFsbHkgYmxvY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgcmVzLmlzTW9iWEZsb3cgPSB0cnVlO1xuICByZXR1cm4gcmVzO1xufSwgZmxvd0Fubm90YXRpb24pO1xuZmxvdy5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGZsb3dCb3VuZEFubm90YXRpb24pO1xuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZShwcm9taXNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb21pc2UuY2FuY2VsKSkge1xuICAgIHByb21pc2UuY2FuY2VsKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsb3dSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQ7IC8vIGp1c3QgdHJpY2tpbmcgVHlwZVNjcmlwdCA6KVxufVxuZnVuY3Rpb24gaXNGbG93KGZuKSB7XG4gIHJldHVybiAoZm4gPT0gbnVsbCA/IHZvaWQgMCA6IGZuLmlzTW9iWEZsb3cpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRSZWFkcyh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICB2YXIgdGFyZ2V0O1xuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVBcnJheSh0aGluZykgfHwgaXNPYnNlcnZhYmxlVmFsdWUodGhpbmcpKSB7XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc1N0cmluZ2lzaChwcm9wT3JIYW5kbGVyKSkge1xuICAgICAgcmV0dXJuIGRpZShcIkludGVyY2VwdFJlYWRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHNwZWNpZmljIHByb3BlcnR5LCBub3Qgd2l0aCBhbiBvYmplY3QgaW4gZ2VuZXJhbFwiKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BPckhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBkaWUoXCJFeHBlY3RlZCBvYnNlcnZhYmxlIG1hcCwgb2JqZWN0IG9yIGFycmF5IGFzIGZpcnN0IGFycmF5XCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGFyZ2V0LmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGllKFwiQW4gaW50ZXJjZXB0IHJlYWRlciB3YXMgYWxyZWFkeSBlc3RhYmxpc2hlZFwiKTtcbiAgfVxuICB0YXJnZXQuZGVoYW5jZXIgPSB0eXBlb2YgcHJvcE9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8gcHJvcE9ySGFuZGxlciA6IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmRlaGFuY2VyID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHQodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICByZXR1cm4gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkuaW50ZXJjZXB0XyhoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYXRvbSA9IGdldEF0b20odmFsdWUsIHByb3BlcnR5KTtcbiAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZShhdG9tKTtcbn1cbmZ1bmN0aW9uIGlzQ29tcHV0ZWQodmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNDb21wdXRlZFByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICB9XG4gIHJldHVybiBfaXNDb21wdXRlZCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSB7XG4gICAgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgfVxuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGlzT2JzZXJ2YWJsZU1hcCh2YWx1ZSkgfHwgaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIGRpZShcImlzT2JzZXJ2YWJsZShvYmplY3QsIHByb3BlcnR5TmFtZSkgaXMgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXlzIGFuZCBtYXBzLiBVc2UgbWFwLmhhcyBvciBhcnJheS5sZW5ndGggaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcbiAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkgfHwgISF2YWx1ZVskbW9ieF0gfHwgaXNBdG9tKHZhbHVlKSB8fCBpc1JlYWN0aW9uKHZhbHVlKSB8fCBpc0NvbXB1dGVkVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIGRpZShcImlzT2JzZXJ2YWJsZSBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzT2JzZXJ2YWJsZVByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICB9XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZVByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzU3RyaW5naXNoKHByb3BOYW1lKSkge1xuICAgIHJldHVybiBkaWUoXCJleHBlY3RlZCBhIHByb3BlcnR5IG5hbWUgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICB9XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmtleXNfKCk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopIHx8IGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmtleXMoKSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9KTtcbiAgfVxuICBkaWUoNSk7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai52YWx1ZXMoKSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH1cbiAgZGllKDYpO1xufVxuZnVuY3Rpb24gZW50cmllcyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9ialtrZXldXTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqLmdldChrZXkpXTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmouZW50cmllcygpKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBrZXldO1xuICAgIH0pO1xuICB9XG4gIGRpZSg3KTtcbn1cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBfdmFsdWVzID0ga2V5O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIF92YWx1ZXMpIHtcbiAgICAgICAgc2V0KG9iaiwgX2tleSwgX3ZhbHVlc1tfa2V5XSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLnNldF8oa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICBvYmouc2V0KGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikge1xuICAgICAga2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuICAgIGlmIChrZXkgPCAwKSB7XG4gICAgICBkaWUoXCJJbnZhbGlkIGluZGV4OiAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgfVxuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICBpZiAoa2V5ID49IG9iai5sZW5ndGgpIHtcbiAgICAgIG9iai5sZW5ndGggPSBrZXkgKyAxO1xuICAgIH1cbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIGVuZEJhdGNoKCk7XG4gIH0gZWxzZSB7XG4gICAgZGllKDgpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmUob2JqLCBrZXkpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgb2JqWyRtb2J4XS5kZWxldGVfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIG9ialtcImRlbGV0ZVwiXShrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikge1xuICAgICAga2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuICAgIG9iai5zcGxpY2Uoa2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBkaWUoOSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5oYXNfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGtleSA+PSAwICYmIGtleSA8IG9iai5sZW5ndGg7XG4gIH1cbiAgZGllKDEwKTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIGtleSkge1xuICBpZiAoIWhhcyhvYmosIGtleSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmdldF8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICBkaWUoMTEpO1xufVxuZnVuY3Rpb24gYXBpRGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvcik7XG4gIH1cbiAgZGllKDM5KTtcbn1cbmZ1bmN0aW9uIGFwaU93bktleXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLm93bktleXNfKCk7XG4gIH1cbiAgZGllKDM4KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgaWYgKGlzRnVuY3Rpb24oY2JPckZpcmUpKSB7XG4gICAgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gY2FjaGUobWFwLCBrZXksIHZhbHVlKSB7XG4gIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSlNIZWxwZXIoc291cmNlLCBfX2FscmVhZHlTZWVuKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIERhdGUgfHwgIWlzT2JzZXJ2YWJsZShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlVmFsdWUoc291cmNlKSB8fCBpc0NvbXB1dGVkVmFsdWUoc291cmNlKSkge1xuICAgIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZS5nZXQoKSwgX19hbHJlYWR5U2Vlbik7XG4gIH1cbiAgaWYgKF9fYWxyZWFkeVNlZW4uaGFzKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gX19hbHJlYWR5U2Vlbi5nZXQoc291cmNlKTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoc291cmNlKSkge1xuICAgIHZhciByZXMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKSk7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgIHJlc1tpZHhdID0gdG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2Vlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IFNldCgpKTtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIF9yZXMuYWRkKHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlcztcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlczIgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBNYXAoKSk7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIF9yZXMyLnNldChrZXksIHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczI7XG4gIH0gZWxzZSB7XG4gICAgLy8gbXVzdCBiZSBvYnNlcnZhYmxlIG9iamVjdFxuICAgIHZhciBfcmVzMyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwge30pO1xuICAgIGFwaU93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChvYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgX3JlczNba2V5XSA9IHRvSlNIZWxwZXIoc291cmNlW2tleV0sIF9fYWxyZWFkeVNlZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfcmVzMztcbiAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb252ZXJ0cyBhbiBvYnNlcnZhYmxlIHRvIGl0J3Mgbm9uLW9ic2VydmFibGUgbmF0aXZlIGNvdW50ZXJwYXJ0LlxuICogSXQgZG9lcyBOT1QgcmVjdXJzZSBpbnRvIG5vbi1vYnNlcnZhYmxlcywgdGhlc2UgYXJlIGxlZnQgYXMgdGhleSBhcmUsIGV2ZW4gaWYgdGhleSBjb250YWluIG9ic2VydmFibGVzLlxuICogQ29tcHV0ZWQgYW5kIG90aGVyIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbXBsZXRlbHkgaWdub3JlZC5cbiAqIENvbXBsZXggc2NlbmFyaW9zIHJlcXVpcmUgY3VzdG9tIHNvbHV0aW9uLCBlZyBpbXBsZW1lbnRpbmcgYHRvSlNPTmAgb3IgdXNpbmcgYHNlcmlhbGl6cmAgbGliLlxuICovXG5mdW5jdGlvbiB0b0pTKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG9wdGlvbnMpIHtcbiAgICBkaWUoXCJ0b0pTIG5vIGxvbmdlciBzdXBwb3J0cyBvcHRpb25zXCIpO1xuICB9XG4gIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZSwgbmV3IE1hcCgpKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImJvb2xlYW5cIikge1xuICAgIGVudGVyQnJlYWtQb2ludCA9IGFyZ3MucG9wKCk7XG4gIH1cbiAgdmFyIGRlcml2YXRpb24gPSBnZXRBdG9tRnJvbUFyZ3MoYXJncyk7XG4gIGlmICghZGVyaXZhdGlvbikge1xuICAgIHJldHVybiBkaWUoXCIndHJhY2UoYnJlYWs/KScgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYSB0cmFja2VkIGNvbXB1dGVkIHZhbHVlIG9yIGEgUmVhY3Rpb24uIENvbnNpZGVyIHBhc3NpbmcgaW4gdGhlIGNvbXB1dGVkIHZhbHVlIG9yIHJlYWN0aW9uIGV4cGxpY2l0bHlcIik7XG4gIH1cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIHRyYWNpbmcgZW5hYmxlZFwiKTtcbiAgfVxuICBkZXJpdmF0aW9uLmlzVHJhY2luZ18gPSBlbnRlckJyZWFrUG9pbnQgPyBUcmFjZU1vZGUuQlJFQUsgOiBUcmFjZU1vZGUuTE9HO1xufVxuZnVuY3Rpb24gZ2V0QXRvbUZyb21BcmdzKGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEdXJpbmcgYSB0cmFuc2FjdGlvbiBubyB2aWV3cyBhcmUgdXBkYXRlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxuICpcbiAqIEBwYXJhbSBhY3Rpb24gYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgc29tZSByZWFjdGl2ZSBzdGF0ZVxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGFjdGlvbiwgdGhpc0FyZykge1xuICBpZiAodGhpc0FyZyA9PT0gdm9pZCAwKSB7XG4gICAgdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdGFydEJhdGNoKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFjdGlvbi5hcHBseSh0aGlzQXJnKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdoZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGFyZzEgJiYgdHlwZW9mIGFyZzEgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gd2hlblByb21pc2UocHJlZGljYXRlLCBhcmcxKTtcbiAgfVxuICByZXR1cm4gX3doZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyIHx8IHt9KTtcbn1cbmZ1bmN0aW9uIF93aGVuKHByZWRpY2F0ZSwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciB0aW1lb3V0SGFuZGxlO1xuICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtcbiAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRpc3Bvc2VyWyRtb2J4XS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChvcHRzLm9uRXJyb3IpIHtcbiAgICAgICAgICBvcHRzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgfVxuICBvcHRzLm5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgfHwgXCJXaGVuQFwiICsgZ2V0TmV4dElkKCkgOiBcIldoZW5cIjtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGNyZWF0ZUFjdGlvbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgKyBcIi1lZmZlY3RcIiA6IFwiV2hlbi1lZmZlY3RcIiwgZWZmZWN0KTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHZhciBkaXNwb3NlciA9IGF1dG9ydW4oZnVuY3Rpb24gKHIpIHtcbiAgICAvLyBwcmVkaWNhdGUgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdGVcbiAgICB2YXIgY29uZCA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBwcmVkaWNhdGUpO1xuICAgIGlmIChjb25kKSB7XG4gICAgICByLmRpc3Bvc2UoKTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIGVmZmVjdEFjdGlvbigpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIHJldHVybiBkaXNwb3Nlcjtcbn1cbmZ1bmN0aW9uIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgb3B0cykge1xuICB2YXIgX29wdHMkc2lnbmFsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG9wdHMgJiYgb3B0cy5vbkVycm9yKSB7XG4gICAgcmV0dXJuIGRpZShcInRoZSBvcHRpb25zICdvbkVycm9yJyBhbmQgJ3Byb21pc2UnIGNhbm5vdCBiZSBjb21iaW5lZFwiKTtcbiAgfVxuICBpZiAob3B0cyAhPSBudWxsICYmIChfb3B0cyRzaWduYWwgPSBvcHRzLnNpZ25hbCkgIT0gbnVsbCAmJiBfb3B0cyRzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldIRU5fQUJPUlRFRFwiKSksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB2YXIgY2FuY2VsO1xuICB2YXIgYWJvcnQ7XG4gIHZhciByZXMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIF9vcHRzJHNpZ25hbDI7XG4gICAgdmFyIGRpc3Bvc2VyID0gX3doZW4ocHJlZGljYXRlLCByZXNvbHZlLCBfZXh0ZW5kcyh7fSwgb3B0cywge1xuICAgICAgb25FcnJvcjogcmVqZWN0XG4gICAgfSkpO1xuICAgIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV0hFTl9DQU5DRUxMRURcIikpO1xuICAgIH07XG4gICAgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV0hFTl9BQk9SVEVEXCIpKTtcbiAgICB9O1xuICAgIG9wdHMgPT0gbnVsbCB8fCAoX29wdHMkc2lnbmFsMiA9IG9wdHMuc2lnbmFsKSA9PSBudWxsIHx8IF9vcHRzJHNpZ25hbDIuYWRkRXZlbnRMaXN0ZW5lciA9PSBudWxsIHx8IF9vcHRzJHNpZ25hbDIuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdHMkc2lnbmFsMztcbiAgICByZXR1cm4gb3B0cyA9PSBudWxsIHx8IChfb3B0cyRzaWduYWwzID0gb3B0cy5zaWduYWwpID09IG51bGwgfHwgX29wdHMkc2lnbmFsMy5yZW1vdmVFdmVudExpc3RlbmVyID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cyRzaWduYWwzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCk7XG4gIH0pO1xuICByZXMuY2FuY2VsID0gY2FuY2VsO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRBZG0odGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRbJG1vYnhdO1xufVxuLy8gT3B0aW1pemF0aW9uOiB3ZSBkb24ndCBuZWVkIHRoZSBpbnRlcm1lZGlhdGUgb2JqZWN0cyBhbmQgY291bGQgaGF2ZSBhIGNvbXBsZXRlbHkgY3VzdG9tIGFkbWluaXN0cmF0aW9uIGZvciBEeW5hbWljT2JqZWN0cyxcbi8vIGFuZCBza2lwIGVpdGhlciB0aGUgaW50ZXJuYWwgdmFsdWVzIG1hcCwgb3IgdGhlIGJhc2Ugb2JqZWN0IHdpdGggaXRzIHByb3BlcnR5IGRlc2NyaXB0b3JzIVxudmFyIG9iamVjdFByb3h5VHJhcHMgPSB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgbmFtZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGV0ZWN0IG5ldyBwcm9wZXJ0aWVzIHVzaW5nIHRoZSAnaW4nIG9wZXJhdG9yLiBVc2UgJ2hhcycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5oYXNfKG5hbWUpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkuZ2V0XyhuYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfZ2V0QWRtJHNldF87XG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFnZXRBZG0odGFyZ2V0KS52YWx1ZXNfLmhhcyhuYW1lKSkge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImFkZCBhIG5ldyBvYnNlcnZhYmxlIHByb3BlcnR5IHRocm91Z2ggZGlyZWN0IGFzc2lnbm1lbnQuIFVzZSAnc2V0JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG4gICAgcmV0dXJuIChfZ2V0QWRtJHNldF8gPSBnZXRBZG0odGFyZ2V0KS5zZXRfKG5hbWUsIHZhbHVlLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kc2V0XyA6IHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgX2dldEFkbSRkZWxldGVfO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWxldGUgcHJvcGVydGllcyBmcm9tIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ3JlbW92ZScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlbGV0ZV8gPSBnZXRBZG0odGFyZ2V0KS5kZWxldGVfKG5hbWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRkZWxldGVfIDogdHJ1ZTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBfZ2V0QWRtJGRlZmluZVByb3BlcnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlZmluZSBwcm9wZXJ0eSBvbiBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdkZWZpbmVQcm9wZXJ0eScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuICAgIHJldHVybiAoX2dldEFkbSRkZWZpbmVQcm9wZXJ0ID0gZ2V0QWRtKHRhcmdldCkuZGVmaW5lUHJvcGVydHlfKG5hbWUsIGRlc2NyaXB0b3IpKSAhPSBudWxsID8gX2dldEFkbSRkZWZpbmVQcm9wZXJ0IDogdHJ1ZTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcIml0ZXJhdGUga2V5cyB0byBkZXRlY3QgYWRkZWQgLyByZW1vdmVkIHByb3BlcnRpZXMuIFVzZSAna2V5cycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5vd25LZXlzXygpO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgZGllKDEzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGFzRHluYW1pY09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBfdGFyZ2V0JCRtb2J4LCBfdGFyZ2V0JCRtb2J4JHByb3h5XztcbiAgYXNzZXJ0UHJveGllcygpO1xuICB0YXJnZXQgPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgcmV0dXJuIChfdGFyZ2V0JCRtb2J4JHByb3h5XyA9IChfdGFyZ2V0JCRtb2J4ID0gdGFyZ2V0WyRtb2J4XSkucHJveHlfKSAhPSBudWxsID8gX3RhcmdldCQkbW9ieCRwcm94eV8gOiBfdGFyZ2V0JCRtb2J4LnByb3h5XyA9IG5ldyBQcm94eSh0YXJnZXQsIG9iamVjdFByb3h5VHJhcHMpO1xufVxuXG5mdW5jdGlvbiBoYXNJbnRlcmNlcHRvcnMoaW50ZXJjZXB0YWJsZSkge1xuICByZXR1cm4gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfICE9PSB1bmRlZmluZWQgJiYgaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3RlckludGVyY2VwdG9yKGludGVyY2VwdGFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGludGVyY2VwdG9ycyA9IGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCAoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfID0gW10pO1xuICBpbnRlcmNlcHRvcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBpbnRlcmNlcHRvcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRDaGFuZ2UoaW50ZXJjZXB0YWJsZSwgY2hhbmdlKSB7XG4gIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gIHRyeSB7XG4gICAgLy8gSW50ZXJjZXB0b3IgY2FuIG1vZGlmeSB0aGUgYXJyYXksIGNvcHkgaXQgdG8gYXZvaWQgY29uY3VycmVudCBtb2RpZmljYXRpb24sIHNlZSAjMTk1MFxuICAgIHZhciBpbnRlcmNlcHRvcnMgPSBbXS5jb25jYXQoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfIHx8IFtdKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGludGVyY2VwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoYW5nZSA9IGludGVyY2VwdG9yc1tpXShjaGFuZ2UpO1xuICAgICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgZGllKDE0KTtcbiAgICAgIH1cbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTGlzdGVuZXJzKGxpc3RlbmFibGUpIHtcbiAgcmV0dXJuIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXy5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5hYmxlLCBoYW5kbGVyKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gfHwgKGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyA9IFtdKTtcbiAgbGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gbGlzdGVuZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGxpc3RlbmFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGNoYW5nZSk7XG4gIH1cbiAgdW50cmFja2VkRW5kKHByZXZVKTtcbn1cblxuZnVuY3Rpb24gbWFrZU9ic2VydmFibGUodGFyZ2V0LCBhbm5vdGF0aW9ucywgb3B0aW9ucykge1xuICBpbml0T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcbiAgICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucylbJG1vYnhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYW5ub3RhdGlvbnMgJiYgdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkge1xuICAgICAgZGllKFwibWFrZU9ic2VydmFibGUgc2Vjb25kIGFyZyBtdXN0IGJlIG51bGxpc2ggd2hlbiB1c2luZyBkZWNvcmF0b3JzLiBNaXhpbmcgQGRlY29yYXRvciBzeW50YXggd2l0aCBhbm5vdGF0aW9ucyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgLy8gRGVmYXVsdCB0byBkZWNvcmF0b3JzXG4gICAgKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSAhPSBudWxsID8gX2Fubm90YXRpb25zIDogYW5ub3RhdGlvbnMgPSBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KTtcbiAgICAvLyBBbm5vdGF0ZVxuICAgIG93bktleXMoYW5ub3RhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksIGFubm90YXRpb25zW2tleV0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIHByb3RvW2tleXNTeW1ib2xdID0gbmV3IFNldDxQcm9wZXJ0eUtleT4oKVxudmFyIGtleXNTeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieC1rZXlzXCIpO1xuZnVuY3Rpb24gbWFrZUF1dG9PYnNlcnZhYmxlKHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiAhaXNQbGFpbk9iamVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIGRpZShcIidtYWtlQXV0b09ic2VydmFibGUnIGNhbiBvbmx5IGJlIHVzZWQgZm9yIGNsYXNzZXMgdGhhdCBkb24ndCBoYXZlIGEgc3VwZXJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgICBkaWUoXCJtYWtlQXV0b09ic2VydmFibGUgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYmplY3RzIG5vdCBhbHJlYWR5IG1hZGUgb2JzZXJ2YWJsZVwiKTtcbiAgICB9XG4gIH1cbiAgLy8gT3B0aW1pemF0aW9uOiBhdm9pZCB2aXNpdGluZyBwcm90b3NcbiAgLy8gQXNzdW1lcyB0aGF0IGFubm90YXRpb24ubWFrZV8vLmV4dGVuZF8gd29ya3MgdGhlIHNhbWUgZm9yIHBsYWluIG9iamVjdHNcbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgdGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpO1xuICB9XG4gIGluaXRPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucylbJG1vYnhdO1xuICAgIC8vIE9wdGltaXphdGlvbjogY2FjaGUga2V5cyBvbiBwcm90b1xuICAgIC8vIEFzc3VtZXMgbWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBvYmplY3QgYW5kIGNhbid0IGJlIHVzZWQgaW4gc3ViY2xhc3NcbiAgICBpZiAoIXRhcmdldFtrZXlzU3ltYm9sXSkge1xuICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICB2YXIga2V5cyA9IG5ldyBTZXQoW10uY29uY2F0KG93bktleXModGFyZ2V0KSwgb3duS2V5cyhwcm90bykpKTtcbiAgICAgIGtleXNbXCJkZWxldGVcIl0oXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgIGtleXNbXCJkZWxldGVcIl0oJG1vYngpO1xuICAgICAgYWRkSGlkZGVuUHJvcChwcm90bywga2V5c1N5bWJvbCwga2V5cyk7XG4gICAgfVxuICAgIHRhcmdldFtrZXlzU3ltYm9sXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LFxuICAgICAgLy8gbXVzdCBwYXNzIFwidW5kZWZpbmVkXCIgZm9yIHsga2V5OiB1bmRlZmluZWQgfVxuICAgICAgIW92ZXJyaWRlcyA/IHRydWUgOiBrZXkgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzW2tleV0gOiB0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBTUExJQ0UgPSBcInNwbGljZVwiO1xudmFyIFVQREFURSA9IFwidXBkYXRlXCI7XG52YXIgTUFYX1NQTElDRV9TSVpFID0gMTAwMDA7IC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvODU5XG52YXIgYXJyYXlUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG4gICAgaWYgKG5hbWUgPT09ICRtb2J4KSB7XG4gICAgICByZXR1cm4gYWRtO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgcmV0dXJuIGFkbS5nZXRBcnJheUxlbmd0aF8oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmICFpc05hTihuYW1lKSkge1xuICAgICAgcmV0dXJuIGFkbS5nZXRfKHBhcnNlSW50KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb3AoYXJyYXlFeHRlbnNpb25zLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGFycmF5RXh0ZW5zaW9uc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0YXJnZXRbJG1vYnhdO1xuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBhZG0uc2V0QXJyYXlMZW5ndGhfKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiIHx8IGlzTmFOKG5hbWUpKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbnVtZXJpYyBzdHJpbmdcbiAgICAgIGFkbS5zZXRfKHBhcnNlSW50KG5hbWUpLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoKSB7XG4gICAgZGllKDE1KTtcbiAgfVxufTtcbnZhciBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZF8sIGxlZ2FjeU1vZGVfKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVBcnJheVwiO1xuICAgIH1cbiAgICB0aGlzLm93bmVkXyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gdm9pZCAwO1xuICAgIHRoaXMuYXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gW107XG4gICAgLy8gdGhpcyBpcyB0aGUgcHJvcCB0aGF0IGdldHMgcHJveGllZCwgc28gY2FuJ3QgcmVwbGFjZSBpdCFcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0S25vd25MZW5ndGhfID0gMDtcbiAgICB0aGlzLm93bmVkXyA9IG93bmVkXztcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gbGVnYWN5TW9kZV87XG4gICAgdGhpcy5hdG9tXyA9IG5ldyBBdG9tKG5hbWUpO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuYW1lICsgXCJbLi5dXCIgOiBcIk9ic2VydmFibGVBcnJheVsuLl1cIik7XG4gICAgfTtcbiAgfVxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZXNfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlc18odmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgICAgdHlwZTogXCJzcGxpY2VcIixcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGFkZGVkOiB0aGlzLnZhbHVlc18uc2xpY2UoKSxcbiAgICAgICAgYWRkZWRDb3VudDogdGhpcy52YWx1ZXNfLmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgIHJlbW92ZWRDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmdldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIGdldEFycmF5TGVuZ3RoXygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gIH07XG4gIF9wcm90by5zZXRBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiBzZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdMZW5ndGggIT09IFwibnVtYmVyXCIgfHwgaXNOYU4obmV3TGVuZ3RoKSB8fCBuZXdMZW5ndGggPCAwKSB7XG4gICAgICBkaWUoXCJPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICAgIGlmIChuZXdMZW5ndGggPT09IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0l0ZW1zW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBObyBBcnJheS5maWxsIGV2ZXJ5d2hlcmUuLi5cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhuZXdMZW5ndGgsIGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnVwZGF0ZUFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHVwZGF0ZUFycmF5TGVuZ3RoXyhvbGRMZW5ndGgsIGRlbHRhKSB7XG4gICAgaWYgKG9sZExlbmd0aCAhPT0gdGhpcy5sYXN0S25vd25MZW5ndGhfKSB7XG4gICAgICBkaWUoMTYpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgZGVsdGEgPiAwKSB7XG4gICAgICByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5zcGxpY2VXaXRoQXJyYXlfID0gZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIGxlbmd0aCArIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gbGVuZ3RoIC0gaW5kZXg7XG4gICAgfSBlbHNlIGlmIChkZWxldGVDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUNvdW50ID09PSBudWxsKSB7XG4gICAgICBkZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XG4gICAgfVxuICAgIGlmIChuZXdJdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdJdGVtcyA9IEVNUFRZX0FSUkFZO1xuICAgIH1cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWRDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICAgIGFkZGVkOiBuZXdJdGVtc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgICB9XG4gICAgICBkZWxldGVDb3VudCA9IGNoYW5nZS5yZW1vdmVkQ291bnQ7XG4gICAgICBuZXdJdGVtcyA9IGNoYW5nZS5hZGRlZDtcbiAgICB9XG4gICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF90aGlzLmVuaGFuY2VyXyh2LCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFyIGxlbmd0aERlbHRhID0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG4gICAgICB0aGlzLnVwZGF0ZUFycmF5TGVuZ3RoXyhsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY2hlY2tzIGlmIGludGVybmFsIGFycmF5IHdhc24ndCBtb2RpZmllZFxuICAgIH1cbiAgICB2YXIgcmVzID0gdGhpcy5zcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICAgIGlmIChkZWxldGVDb3VudCAhPT0gMCB8fCBuZXdJdGVtcy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMubm90aWZ5QXJyYXlTcGxpY2VfKGluZGV4LCBuZXdJdGVtcywgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlc18ocmVzKTtcbiAgfTtcbiAgX3Byb3RvLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18gPSBmdW5jdGlvbiBzcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBpZiAobmV3SXRlbXMubGVuZ3RoIDwgTUFYX1NQTElDRV9TSVpFKSB7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVzXztcbiAgICAgIHJldHVybiAoX3RoaXMkdmFsdWVzXyA9IHRoaXMudmFsdWVzXykuc3BsaWNlLmFwcGx5KF90aGlzJHZhbHVlc18sIFtpbmRleCwgZGVsZXRlQ291bnRdLmNvbmNhdChuZXdJdGVtcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgaXRlbXMgcmVtb3ZlZCBieSB0aGUgc3BsaWNlXG4gICAgICB2YXIgcmVzID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4LCBpbmRleCArIGRlbGV0ZUNvdW50KTtcbiAgICAgIC8vIFRoZSBpdGVtcyB0aGF0IHRoYXQgc2hvdWxkIHJlbWFpbiBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgLy8gTmV3IGxlbmd0aCBpcyB0aGUgcHJldmlvdXMgbGVuZ3RoICsgYWRkaXRpb24gY291bnQgLSBkZWxldGlvbiBjb3VudFxuICAgICAgdGhpcy52YWx1ZXNfLmxlbmd0aCArPSBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgaV0gPSBuZXdJdGVtc1tpXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvbGRJdGVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgbmV3SXRlbXMubGVuZ3RoICsgX2ldID0gb2xkSXRlbXNbX2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG4gIF9wcm90by5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgIH0gOiBudWxsO1xuICAgIC8vIFRoZSByZWFzb24gd2h5IHRoaXMgaXMgb24gcmlnaHQgaGFuZCBzaWRlIGhlcmUgKGFuZCBub3QgYWJvdmUpLCBpcyB0aGlzIHdheSB0aGUgdWdsaWZpZXIgd2lsbCBkcm9wIGl0LCBidXQgaXQgd29uJ3RcbiAgICAvLyBjYXVzZSBhbnkgcnVudGltZSBvdmVyaGVhZCBpbiBkZXZlbG9wbWVudCBtb2RlIHdpdGhvdXQgTk9ERV9FTlYgc2V0LCB1bmxlc3Mgc3B5aW5nIGlzIGVuYWJsZWRcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgaWYgKG5vdGlmeSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5ub3RpZnlBcnJheVNwbGljZV8gPSBmdW5jdGlvbiBub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgdmFyIG5vdGlmeVNweSA9ICF0aGlzLm93bmVkXyAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMuYXRvbV8ubmFtZV8sXG4gICAgICB0eXBlOiBTUExJQ0UsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgcmVtb3ZlZENvdW50OiByZW1vdmVkLmxlbmd0aCxcbiAgICAgIGFkZGVkQ291bnQ6IGFkZGVkLmxlbmd0aFxuICAgIH0gOiBudWxsO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAvLyBjb25mb3JtOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9vYnNlcnZlXG4gICAgaWYgKG5vdGlmeSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhpbmRleCkge1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfICYmIGluZGV4ID49IHRoaXMudmFsdWVzXy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2Fybihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlttb2J4LmFycmF5XSBBdHRlbXB0IHRvIHJlYWQgYW4gYXJyYXkgaW5kZXggKFwiICsgaW5kZXggKyBcIikgdGhhdCBpcyBvdXQgb2YgYm91bmRzIChcIiArIHRoaXMudmFsdWVzXy5sZW5ndGggKyBcIikuIFBsZWFzZSBjaGVjayBsZW5ndGggZmlyc3QuIE91dCBvZiBib3VuZCBpbmRpY2VzIHdpbGwgbm90IGJlIHRyYWNrZWQgYnkgTW9iWFwiIDogXCJbbW9ieF0gT3V0IG9mIGJvdW5kcyByZWFkOiBcIiArIGluZGV4KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMudmFsdWVzX1tpbmRleF0pO1xuICB9O1xuICBfcHJvdG8uc2V0XyA9IGZ1bmN0aW9uIHNldF8oaW5kZXgsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzXztcbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyAmJiBpbmRleCA+IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIC8vIG91dCBvZiBib3VuZHNcbiAgICAgIGRpZSgxNywgaW5kZXgsIHZhbHVlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgYXQgaW5kZXggaW4gcmFuZ2VcbiAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgICAgLy8gc2luY2UgXCJ0aGlzXCIgaXMgdGhlIHJlYWwgYXJyYXkgd2UgbmVlZCB0byBwYXNzIGl0cyBwcm94eVxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyXyhuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgdmFyIGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gb2xkVmFsdWU7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdXQgb2YgYm91bmQgaW5kZXgsIHdlIGRvbid0IGNyZWF0ZSBhbiBhY3R1YWwgc3BhcnNlIGFycmF5LFxuICAgICAgLy8gYnV0IHJhdGhlciBmaWxsIHRoZSBob2xlcyB3aXRoIHVuZGVmaW5lZCAoc2FtZSBhcyBzZXRBcnJheUxlbmd0aF8pLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBjb25zaWRlcmVkIGEgYnVnLlxuICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KGluZGV4ICsgMSAtIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuICAgICAgbmV3SXRlbXNbbmV3SXRlbXMubGVuZ3RoIC0gMV0gPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5Xyh2YWx1ZXMubGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb247XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUsIG93bmVkKSB7XG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gIH1cbiAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICBvd25lZCA9IGZhbHNlO1xuICB9XG4gIGFzc2VydFByb3hpZXMoKTtcbiAgcmV0dXJuIGluaXRPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgZmFsc2UpO1xuICAgIGFkZEhpZGRlbkZpbmFsUHJvcChhZG0udmFsdWVzXywgJG1vYngsIGFkbSk7XG4gICAgdmFyIHByb3h5ID0gbmV3IFByb3h5KGFkbS52YWx1ZXNfLCBhcnJheVRyYXBzKTtcbiAgICBhZG0ucHJveHlfID0gcHJveHk7XG4gICAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG4gIH0pO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgYXJyYXlFeHRlbnNpb25zID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xuICB9LFxuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5ld0l0ZW1zKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCBhZG0udmFsdWVzXy5sZW5ndGgsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgpO1xuICB9LFxuICAvKlxuICAgKiBmdW5jdGlvbnMgdGhhdCBkbyBhbHRlciB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgKGJhc2VkIG9uIGxpYi5lczYuZC50cylcbiAgICogc2luY2UgdGhlc2UgZnVuY3Rpb25zIGFsdGVyIHRoZSBpbm5lciBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqIEJlY2F1c2UgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLCB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBpbiBjb21wdXRlZCBmdW5jdGlvbixcbiAgICogYW5kIGZvciB0aGF0IHJlYXNvbiB0aGUgZG8gbm90IGNhbGwgZGVwZW5kZW5jeVN0YXRlLm5vdGlmeU9ic2VydmVkXG4gICAqL1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3SXRlbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3SXRlbXNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4KTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgc3BsaWNlV2l0aEFycmF5OiBmdW5jdGlvbiBzcGxpY2VXaXRoQXJyYXkoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHJldHVybiB0aGlzWyRtb2J4XS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XyhhZG0udmFsdWVzXy5sZW5ndGgsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICBwb3A6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoTWF0aC5tYXgodGhpc1skbW9ieF0udmFsdWVzXy5sZW5ndGggLSAxLCAwKSwgMSlbMF07XG4gIH0sXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCwgMSlbMF07XG4gIH0sXG4gIHVuc2hpZnQ6IGZ1bmN0aW9uIHVuc2hpZnQoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGl0ZW1zW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIHJldmVyc2UgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIG1ha2VzIGl0IGJvdGggYSAnZGVyaXZhdGlvbicgYW5kIGEgJ211dGF0aW9uJy5cbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwicmV2ZXJzZVwiKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlKHRoaXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xuICAgIC8vIHNvcnQgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIGdvZXMgYWdhaW5zdCBhbGwgZ29vZCBwcmFjdGljZXMuIExldCdzIG5vdCBjaGFuZ2UgdGhlIGFycmF5IGluIHBsYWNlIVxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJzb3J0XCIpO1xuICAgIH1cbiAgICB2YXIgY29weSA9IHRoaXMuc2xpY2UoKTtcbiAgICBjb3B5LnNvcnQuYXBwbHkoY29weSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlcGxhY2UoY29weSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHZhbHVlKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHZhciBpZHggPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vKipcbiAqIFdyYXAgZnVuY3Rpb24gZnJvbSBwcm90b3R5cGVcbiAqIFdpdGhvdXQgdGhpcywgZXZlcnl0aGluZyB3b3JrcyBhcyB3ZWxsLCBidXQgdGhpcyB3b3Jrc1xuICogZmFzdGVyIGFzIGV2ZXJ5dGhpbmcgd29ya3Mgb24gdW5wcm94aWVkIHZhbHVlc1xuICovXG5hZGRBcnJheUV4dGVuc2lvbihcImF0XCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJjb25jYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluY2x1ZGVzXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJpbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJqb2luXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJsYXN0SW5kZXhPZlwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic2xpY2VcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvU3RyaW5nXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b0xvY2FsZVN0cmluZ1wiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9Tb3J0ZWRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvU3BsaWNlZFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwid2l0aFwiLCBzaW1wbGVGdW5jKTtcbi8vIG1hcFxuYWRkQXJyYXlFeHRlbnNpb24oXCJldmVyeVwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbHRlclwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kSW5kZXhcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kTGFzdFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRMYXN0SW5kZXhcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmbGF0TWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZm9yRWFjaFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcIm1hcFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInNvbWVcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b1JldmVyc2VkXCIsIG1hcExpa2VGdW5jKTtcbi8vIHJlZHVjZVxuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VSaWdodFwiLCByZWR1Y2VMaWtlRnVuYyk7XG5mdW5jdGlvbiBhZGRBcnJheUV4dGVuc2lvbihmdW5jTmFtZSwgZnVuY0ZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbZnVuY05hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBhcnJheUV4dGVuc2lvbnNbZnVuY05hbWVdID0gZnVuY0ZhY3RvcnkoZnVuY05hbWUpO1xuICB9XG59XG4vLyBSZXBvcnQgYW5kIGRlbGVnYXRlIHRvIGRlaGFuY2VkIGFycmF5XG5mdW5jdGlvbiBzaW1wbGVGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbi8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjZWl2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuZnVuY3Rpb24gbWFwTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0oZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBlbGVtZW50LCBpbmRleCwgX3RoaXMyKTtcbiAgICB9KTtcbiAgfTtcbn1cbi8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjZWl2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuZnVuY3Rpb24gcmVkdWNlTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICAvLyAjMjQzMiAtIHJlZHVjZSBiZWhhdmlvciBkZXBlbmRzIG9uIGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgYXJndW1lbnRzWzBdID0gZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgsIF90aGlzMyk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKTtcbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBpc09iamVjdCh0aGluZykgJiYgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbih0aGluZ1skbW9ieF0pO1xufVxuXG52YXIgT2JzZXJ2YWJsZU1hcE1hcmtlciA9IHt9O1xudmFyIEFERCA9IFwiYWRkXCI7XG52YXIgREVMRVRFID0gXCJkZWxldGVcIjtcbi8vIGp1c3QgZXh0ZW5kIE1hcD8gU2VlIGFsc28gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbmVzdGhhcnVzLzEzYjRkNzRmMmVmNGEyZjQzNTdkYmQzZmMyM2MxZTU0XG4vLyBCdXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTU1NlxudmFyIE9ic2VydmFibGVNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlTWFwKGluaXRpYWxEYXRhLCBlbmhhbmNlcl8sIG5hbWVfKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoZW5oYW5jZXJfID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyXyA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVNYXBcIjtcbiAgICB9XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVNYXBNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc01hcF8gPSB2b2lkIDA7XG4gICAgLy8gaGFzTWFwLCBub3QgaGFzaE1hcCA+LSkuXG4gICAgdGhpcy5rZXlzQXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gZW5oYW5jZXJfO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICBpZiAoIWlzRnVuY3Rpb24oTWFwKSkge1xuICAgICAgZGllKDE4KTtcbiAgICB9XG4gICAgaW5pdE9ic2VydmFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMua2V5c0F0b21fID0gY3JlYXRlQXRvbShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfdGhpcy5uYW1lXyArIFwiLmtleXMoKVwiIDogXCJPYnNlcnZhYmxlTWFwLmtleXMoKVwiKTtcbiAgICAgIF90aGlzLmRhdGFfID0gbmV3IE1hcCgpO1xuICAgICAgX3RoaXMuaGFzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgICBfdGhpcy5tZXJnZShpbml0aWFsRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVNYXAucHJvdG90eXBlO1xuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKGtleSk7XG4gIH07XG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc18oa2V5KTtcbiAgICB9XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oYXNNYXBfLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZSh0aGlzLmhhc18oa2V5KSwgcmVmZXJlbmNlRW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgOiBcIk9ic2VydmFibGVNYXAua2V5P1wiLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhc01hcF8uc2V0KGtleSwgbmV3RW50cnkpO1xuICAgICAgb25CZWNvbWVVbm9ic2VydmVkKG5ld0VudHJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuaGFzTWFwX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfTtcbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGhhc0tleSA9IHRoaXMuaGFzXyhrZXkpO1xuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBoYXNLZXkgPyBVUERBVEUgOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0tleSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5oYXNfKGtleSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdGhpcy5kYXRhXy5nZXQoa2V5KS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIH0gLy8gVE9ETyBmaXggdHlwZVxuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMzJGhhc01hcF8kZ2V0O1xuICAgICAgICBfdGhpczMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgKF90aGlzMyRoYXNNYXBfJGdldCA9IF90aGlzMy5oYXNNYXBfLmdldChrZXkpKSA9PSBudWxsIHx8IF90aGlzMyRoYXNNYXBfJGdldC5zZXROZXdWYWx1ZV8oZmFsc2UpO1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IF90aGlzMy5kYXRhXy5nZXQoa2V5KTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8odW5kZWZpbmVkKTtcbiAgICAgICAgX3RoaXMzLmRhdGFfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8udXBkYXRlVmFsdWVfID0gZnVuY3Rpb24gdXBkYXRlVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuZGF0YV8uZ2V0KGtleSk7XG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICB9IC8vIFRPRE8gZml4IHR5cGVcbiAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5hZGRWYWx1ZV8gPSBmdW5jdGlvbiBhZGRWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXM0JGhhc01hcF8kZ2V0O1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKG5ld1ZhbHVlLCBfdGhpczQuZW5oYW5jZXJfLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfdGhpczQubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpIDogXCJPYnNlcnZhYmxlTWFwLmtleVwiLCBmYWxzZSk7XG4gICAgICBfdGhpczQuZGF0YV8uc2V0KGtleSwgb2JzZXJ2YWJsZSk7XG4gICAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUudmFsdWVfOyAvLyB2YWx1ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZFxuICAgICAgKF90aGlzNCRoYXNNYXBfJGdldCA9IF90aGlzNC5oYXNNYXBfLmdldChrZXkpKSA9PSBudWxsIHx8IF90aGlzNCRoYXNNYXBfJGdldC5zZXROZXdWYWx1ZV8odHJ1ZSk7XG4gICAgICBfdGhpczQua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICB9KTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgdHlwZTogQURELFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgbmFtZToga2V5LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgfSAvLyBUT0RPIGZpeCB0eXBlXG4gICAgaWYgKG5vdGlmeSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy5kYXRhXy5nZXQoa2V5KS5nZXQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odW5kZWZpbmVkKTtcbiAgfTtcbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIF9wcm90by5rZXlzID0gZnVuY3Rpb24ga2V5cygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmtleXMoKTtcbiAgfTtcbiAgX3Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlRm9yTWFwKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0ID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQuZG9uZSxcbiAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQudmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IHNlbGYuZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZUZvck1hcCh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dDIgPSBrZXlzLm5leHQoKSxcbiAgICAgICAgICBkb25lID0gX2tleXMkbmV4dDIuZG9uZSxcbiAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQyLnZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBbdmFsdWUsIHNlbGYuZ2V0KHZhbHVlKV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9O1xuICBfcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIE1lcmdlIGFub3RoZXIgb2JqZWN0IGludG8gdGhpcyBvYmplY3QsIHJldHVybnMgdGhpcy4gKi87XG4gIF9wcm90by5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvdGhlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IE1hcChvdGhlcik7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG90aGVyKSkge1xuICAgICAgICBnZXRQbGFpbk9iamVjdEtleXMob3RoZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuc2V0KGtleSwgb3RoZXJba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkge1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9yZWZbMV07XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNk1hcChvdGhlcikpIHtcbiAgICAgICAgaWYgKCFpc1BsYWluRVM2TWFwKG90aGVyKSkge1xuICAgICAgICAgIGRpZSgxOSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKDIwLCBvdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNi5rZXlzKCkpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgX3RoaXM2W1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gcmVxdWlyZW1lbnRzOlxuICAgIC8vIC0gcmVzcGVjdCBvcmRlcmluZyBvZiByZXBsYWNlbWVudCBtYXBcbiAgICAvLyAtIGFsbG93IGludGVyY2VwdG9ycyB0byBydW4gYW5kIHBvdGVudGlhbGx5IHByZXZlbnQgaW5kaXZpZHVhbCBvcGVyYXRpb25zXG4gICAgLy8gLSBkb24ndCByZWNyZWF0ZSBvYnNlcnZhYmxlcyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gb3JpZ2luYWwgbWFwIChzbyB3ZSBkb24ndCBkZXN0cm95IGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMpXG4gICAgLy8gLSBkb24ndCBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCBpZiB0aGUga2V5cyBvZiByZXN1bHRpbmcgbWFwIGFyZSBpbmRlbnRpY2FsIChvcmRlciBtYXR0ZXJzISlcbiAgICAvLyAtIG5vdGUgdGhhdCByZXN1bHQgbWFwIG1heSBkaWZmZXIgZnJvbSByZXBsYWNlbWVudCBtYXAgZHVlIHRvIHRoZSBpbnRlcmNlcHRvcnNcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIG1hcCBzbyB3ZSBjYW4gZG8gcXVpY2sga2V5IGxvb2t1cHNcbiAgICAgIHZhciByZXBsYWNlbWVudE1hcCA9IGNvbnZlcnRUb01hcCh2YWx1ZXMpO1xuICAgICAgdmFyIG9yZGVyZWREYXRhID0gbmV3IE1hcCgpO1xuICAgICAgLy8gVXNlZCBmb3Igb3B0aW1pemF0aW9uXG4gICAgICB2YXIga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSBmYWxzZTtcbiAgICAgIC8vIERlbGV0ZSBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gcmVwbGFjZW1lbnQgbWFwXG4gICAgICAvLyBpZiB0aGUga2V5IGRlbGV0aW9uIGlzIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgLy8gYWRkIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlc3VsdCBtYXBcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNy5kYXRhXy5rZXlzKCkpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAvLyBDb25jdXJyZW50bHkgaXRlcmF0aW5nL2RlbGV0aW5nIGtleXNcbiAgICAgICAgLy8gaXRlcmF0b3Igc2hvdWxkIGhhbmRsZSB0aGlzIGNvcnJlY3RseVxuICAgICAgICBpZiAoIXJlcGxhY2VtZW50TWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZWQgPSBfdGhpczdbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgICAvLyBXYXMgdGhlIGtleSByZW1vdmVkP1xuICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczcuZGF0YV8uZ2V0KGtleSk7XG4gICAgICAgICAgICBvcmRlcmVkRGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBlbnRyaWVzXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZXBsYWNlbWVudE1hcC5lbnRyaWVzKCkpLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3N0ZXA0LnZhbHVlLFxuICAgICAgICAgIF9rZXkgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgX3ZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuICAgICAgICAvLyBXZSB3aWxsIHdhbnQgdG8ga25vdyB3aGV0aGVyIGEgbmV3IGtleSBpcyBhZGRlZFxuICAgICAgICB2YXIga2V5RXhpc3RlZCA9IF90aGlzNy5kYXRhXy5oYXMoX2tleSk7XG4gICAgICAgIC8vIEFkZCBvciB1cGRhdGUgdmFsdWVcbiAgICAgICAgX3RoaXM3LnNldChfa2V5LCBfdmFsdWUpO1xuICAgICAgICAvLyBUaGUgYWRkaXRpb24gY291bGQgaGF2ZSBiZWVuIHByZXZlbnQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgaWYgKF90aGlzNy5kYXRhXy5oYXMoX2tleSkpIHtcbiAgICAgICAgICAvLyBUaGUgdXBkYXRlIGNvdWxkIGhhdmUgYmVlbiBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAvLyBhbmQgYWxzbyB3ZSB3YW50IHRvIHByZXNlcnZlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgIC8vIHNvIHVzZSB2YWx1ZSBmcm9tIF9kYXRhIG1hcCAoaW5zdGVhZCBvZiByZXBsYWNlbWVudCBtYXApXG4gICAgICAgICAgdmFyIF92YWx1ZTIgPSBfdGhpczcuZGF0YV8uZ2V0KF9rZXkpO1xuICAgICAgICAgIG9yZGVyZWREYXRhLnNldChfa2V5LCBfdmFsdWUyKTtcbiAgICAgICAgICAvLyBXYXMgYSBuZXcga2V5IGFkZGVkP1xuICAgICAgICAgIGlmICgha2V5RXhpc3RlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBwb3NzaWJsZSBrZXkgb3JkZXIgY2hhbmdlXG4gICAgICBpZiAoIWtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkKSB7XG4gICAgICAgIGlmIChfdGhpczcuZGF0YV8uc2l6ZSAhPT0gb3JkZXJlZERhdGEuc2l6ZSkge1xuICAgICAgICAgIC8vIElmIHNpemUgZGlmZmVycywga2V5cyBhcmUgZGVmaW5pdGVseSBtb2RpZmllZFxuICAgICAgICAgIF90aGlzNy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpdGVyMSA9IF90aGlzNy5kYXRhXy5rZXlzKCk7XG4gICAgICAgICAgdmFyIGl0ZXIyID0gb3JkZXJlZERhdGEua2V5cygpO1xuICAgICAgICAgIHZhciBuZXh0MSA9IGl0ZXIxLm5leHQoKTtcbiAgICAgICAgICB2YXIgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgd2hpbGUgKCFuZXh0MS5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dDEudmFsdWUgIT09IG5leHQyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgICAgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVc2UgY29ycmVjdGx5IG9yZGVyZWQgbWFwXG4gICAgICBfdGhpczcuZGF0YV8gPSBvcmRlcmVkRGF0YTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlTWFwXVwiO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcbiAgICogZm9yIGNhbGxiYWNrIGRldGFpbHNcbiAgICovXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZpcmVJbW1lZGlhdGVseSA9PT0gdHJ1ZSkge1xuICAgICAgZGllKFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCBmaXJlSW1tZWRpYXRlbHk9dHJ1ZSBpbiBjb21iaW5hdGlvbiB3aXRoIG1hcHMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZU1hcCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJNYXBcIjtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIGlzT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU1hcFwiLCBPYnNlcnZhYmxlTWFwKTtcbmZ1bmN0aW9uIG1ha2VJdGVyYWJsZUZvck1hcChpdGVyYXRvcikge1xuICBpdGVyYXRvcltTeW1ib2wudG9TdHJpbmdUYWddID0gXCJNYXBJdGVyYXRvclwiO1xuICByZXR1cm4gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb01hcChkYXRhU3RydWN0dXJlKSB7XG4gIGlmIChpc0VTNk1hcChkYXRhU3RydWN0dXJlKSB8fCBpc09ic2VydmFibGVNYXAoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICByZXR1cm4gZGF0YVN0cnVjdHVyZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZGF0YVN0cnVjdHVyZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChkYXRhU3RydWN0dXJlKSkge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWUoMjEsIGRhdGFTdHJ1Y3R1cmUpO1xuICB9XG59XG5cbnZhciBPYnNlcnZhYmxlU2V0TWFya2VyID0ge307XG52YXIgT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVTZXQoaW5pdGlhbERhdGEsIGVuaGFuY2VyLCBuYW1lXykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGVuaGFuY2VyID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVTZXRAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZVNldFwiO1xuICAgIH1cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZVNldE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuYXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICBpZiAoIWlzRnVuY3Rpb24oU2V0KSkge1xuICAgICAgZGllKDIyKTtcbiAgICB9XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBmdW5jdGlvbiAobmV3Viwgb2xkVikge1xuICAgICAgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsIG5hbWVfKTtcbiAgICB9O1xuICAgIGluaXRPYnNlcnZhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmF0b21fID0gY3JlYXRlQXRvbShfdGhpcy5uYW1lXyk7XG4gICAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgICAgX3RoaXMucmVwbGFjZShpbml0aWFsRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVTZXQucHJvdG90eXBlO1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpczIuZGF0YV8udmFsdWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIF90aGlzMltcImRlbGV0ZVwiXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgY2FsbGJhY2tGbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBpbXBsZW1lbnRlZCByZWFzc2lnbm1lbnQgc2FtZSBhcyBpdCdzIGRvbmUgZm9yIE9ic2VydmFibGVNYXBcbiAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuZGF0YV8uYWRkKF90aGlzMy5lbmhhbmNlcl8odmFsdWUsIHVuZGVmaW5lZCkpO1xuICAgICAgICBfdGhpczMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBfY2hhbmdlMiA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICBfdGhpczQuZGF0YV9bXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICB9XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXModmFsdWUpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKHRoaXMuZGVoYW5jZVZhbHVlXyh2YWx1ZSkpO1xuICB9O1xuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZUZvclNldCh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX3ZhbHVlcyRuZXh0ID0gdmFsdWVzLm5leHQoKSxcbiAgICAgICAgICB2YWx1ZSA9IF92YWx1ZXMkbmV4dC52YWx1ZSxcbiAgICAgICAgICBkb25lID0gX3ZhbHVlcyRuZXh0LmRvbmU7XG4gICAgICAgIHJldHVybiAhZG9uZSA/IHtcbiAgICAgICAgICB2YWx1ZTogW3ZhbHVlLCB2YWx1ZV0sXG4gICAgICAgICAgZG9uZTogZG9uZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogZG9uZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhXy52YWx1ZXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlRm9yU2V0KHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfdmFsdWVzJG5leHQyID0gdmFsdWVzLm5leHQoKSxcbiAgICAgICAgICB2YWx1ZSA9IF92YWx1ZXMkbmV4dDIudmFsdWUsXG4gICAgICAgICAgZG9uZSA9IF92YWx1ZXMkbmV4dDIuZG9uZTtcbiAgICAgICAgcmV0dXJuICFkb25lID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmLmRlaGFuY2VWYWx1ZV8odmFsdWUpLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbihvdGhlclNldCkge1xuICAgIGlmIChpc0VTNlNldChvdGhlclNldCkgJiYgIWlzT2JzZXJ2YWJsZVNldChvdGhlclNldCkpIHtcbiAgICAgIHJldHVybiBvdGhlclNldC5pbnRlcnNlY3Rpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZWhhbmNlZFNldCA9IG5ldyBTZXQodGhpcyk7XG4gICAgICByZXR1cm4gZGVoYW5jZWRTZXQuaW50ZXJzZWN0aW9uKG90aGVyU2V0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uKG90aGVyU2V0KSB7XG4gICAgaWYgKGlzRVM2U2V0KG90aGVyU2V0KSAmJiAhaXNPYnNlcnZhYmxlU2V0KG90aGVyU2V0KSkge1xuICAgICAgcmV0dXJuIG90aGVyU2V0LnVuaW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVoYW5jZWRTZXQgPSBuZXcgU2V0KHRoaXMpO1xuICAgICAgcmV0dXJuIGRlaGFuY2VkU2V0LnVuaW9uKG90aGVyU2V0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5kaWZmZXJlbmNlID0gZnVuY3Rpb24gZGlmZmVyZW5jZShvdGhlclNldCkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMpLmRpZmZlcmVuY2Uob3RoZXJTZXQpO1xuICB9O1xuICBfcHJvdG8uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXJTZXQpIHtcbiAgICBpZiAoaXNFUzZTZXQob3RoZXJTZXQpICYmICFpc09ic2VydmFibGVTZXQob3RoZXJTZXQpKSB7XG4gICAgICByZXR1cm4gb3RoZXJTZXQuc3ltbWV0cmljRGlmZmVyZW5jZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlaGFuY2VkU2V0ID0gbmV3IFNldCh0aGlzKTtcbiAgICAgIHJldHVybiBkZWhhbmNlZFNldC5zeW1tZXRyaWNEaWZmZXJlbmNlKG90aGVyU2V0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5pc1N1YnNldE9mID0gZnVuY3Rpb24gaXNTdWJzZXRPZihvdGhlclNldCkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMpLmlzU3Vic2V0T2Yob3RoZXJTZXQpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBlcnNldE9mID0gZnVuY3Rpb24gaXNTdXBlcnNldE9mKG90aGVyU2V0KSB7XG4gICAgcmV0dXJuIG5ldyBTZXQodGhpcykuaXNTdXBlcnNldE9mKG90aGVyU2V0KTtcbiAgfTtcbiAgX3Byb3RvLmlzRGlzam9pbnRGcm9tID0gZnVuY3Rpb24gaXNEaXNqb2ludEZyb20ob3RoZXJTZXQpIHtcbiAgICBpZiAoaXNFUzZTZXQob3RoZXJTZXQpICYmICFpc09ic2VydmFibGVTZXQob3RoZXJTZXQpKSB7XG4gICAgICByZXR1cm4gb3RoZXJTZXQuaXNEaXNqb2ludEZyb20odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZWhhbmNlZFNldCA9IG5ldyBTZXQodGhpcyk7XG4gICAgICByZXR1cm4gZGVoYW5jZWRTZXQuaXNEaXNqb2ludEZyb20ob3RoZXJTZXQpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldChvdGhlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNldChvdGhlcik7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkge1xuICAgICAgICBfdGhpczUuY2xlYXIoKTtcbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNlNldChvdGhlcikpIHtcbiAgICAgICAgX3RoaXM1LmNsZWFyKCk7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWUoXCJDYW5ub3QgaW5pdGlhbGl6ZSBzZXQgZnJvbSBcIiArIG90aGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIC8vIC4uLiAnZmlyZUltbWVkaWF0ZWx5JyBjb3VsZCBhbHNvIGJlIHRydWU/XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIHtcbiAgICAgIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBzZXRzLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCI7XG4gIH07XG4gIF9wcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIGlzT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVNldFwiLCBPYnNlcnZhYmxlU2V0KTtcbmZ1bmN0aW9uIG1ha2VJdGVyYWJsZUZvclNldChpdGVyYXRvcikge1xuICBpdGVyYXRvcltTeW1ib2wudG9TdHJpbmdUYWddID0gXCJTZXRJdGVyYXRvclwiO1xuICByZXR1cm4gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKTtcbn1cblxudmFyIGRlc2NyaXB0b3JDYWNoZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIFJFTU9WRSA9IFwicmVtb3ZlXCI7XG52YXIgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldF8sIHZhbHVlc18sIG5hbWVfLFxuICAvLyBVc2VkIGFueXRpbWUgYW5ub3RhdGlvbiBpcyBub3QgZXhwbGljaXRlbHkgcHJvdmlkZWRcbiAgZGVmYXVsdEFubm90YXRpb25fKSB7XG4gICAgaWYgKHZhbHVlc18gPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWVzXyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRBbm5vdGF0aW9uXyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0QW5ub3RhdGlvbl8gPSBhdXRvQW5ub3RhdGlvbjtcbiAgICB9XG4gICAgdGhpcy50YXJnZXRfID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wZW5kaW5nS2V5c18gPSB2b2lkIDA7XG4gICAgdGhpcy50YXJnZXRfID0gdGFyZ2V0XztcbiAgICB0aGlzLnZhbHVlc18gPSB2YWx1ZXNfO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IGRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB0aGlzLmtleXNBdG9tXyA9IG5ldyBBdG9tKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5rZXlzXCIgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5c1wiKTtcbiAgICAvLyBPcHRpbWl6YXRpb246IHdlIHVzZSB0aGlzIGZyZXF1ZW50bHlcbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gaXNQbGFpbk9iamVjdCh0aGlzLnRhcmdldF8pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQW5ub3RhdGlvbih0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXykpIHtcbiAgICAgIGRpZShcImRlZmF1bHRBbm5vdGF0aW9uIG11c3QgYmUgdmFsaWQgYW5ub3RhdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gUHJlcGFyZSBzdHJ1Y3R1cmUgZm9yIHRyYWNraW5nIHdoaWNoIGZpZWxkcyB3ZXJlIGFscmVhZHkgYW5ub3RhdGVkXG4gICAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB7fTtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG4gIF9wcm90by5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyA9IGZ1bmN0aW9uIGdldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc18uZ2V0KGtleSkuZ2V0KCk7XG4gIH07XG4gIF9wcm90by5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyA9IGZ1bmN0aW9uIHNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTtcbiAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgIG9ic2VydmFibGUuc2V0KG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBpbnRlcmNlcHRcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgIC8vIG5vdGlmeSBzcHkgJiBvYnNlcnZlcnNcbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLmdldF8gPSBmdW5jdGlvbiBnZXRfKGtleSkge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gJiYgIWhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBLZXkgZG9lc24ndCBleGlzdCB5ZXQsIHN1YnNjcmliZSBmb3IgaXQgaW4gY2FzZSBpdCdzIGFkZGVkIGxhdGVyXG4gICAgICB0aGlzLmhhc18oa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0X1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxuICAgKi87XG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhrZXksIHZhbHVlLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBEb24ndCB1c2UgLmhhcyhrZXkpIC0gd2UgY2FyZSBhYm91dCBvd25cbiAgICBpZiAoaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIC8vIEV4aXN0aW5nIHByb3BcbiAgICAgIGlmICh0aGlzLnZhbHVlc18uaGFzKGtleSkpIHtcbiAgICAgICAgLy8gT2JzZXJ2YWJsZSAoY2FuIGJlIGludGVyY2VwdGVkKVxuICAgICAgICByZXR1cm4gdGhpcy5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIC8vIE5vbi1vYnNlcnZhYmxlIC0gcHJveHlcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRoaXMudGFyZ2V0Xywga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLnRhcmdldF9ba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IHByb3BcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZF8oa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSwgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8sIHByb3h5VHJhcCk7XG4gICAgfVxuICB9XG4gIC8vIFRyYXAgZm9yIFwiaW5cIlxuICA7XG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgLy8gU2tpcCBrZXkgc3Vic2NyaXB0aW9uIG91dHNpZGUgZGVyaXZhdGlvblxuICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnRhcmdldF87XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0tleXNfIHx8ICh0aGlzLnBlbmRpbmdLZXlzXyA9IG5ldyBNYXAoKSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nS2V5c18uZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKGtleSBpbiB0aGlzLnRhcmdldF8sIHJlZmVyZW5jZUVuaGFuY2VyLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleT9cIiwgZmFsc2UpO1xuICAgICAgdGhpcy5wZW5kaW5nS2V5c18uc2V0KGtleSwgZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuZ2V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBpZ25vcmUgcHJvcFxuICAgKi87XG4gIF9wcm90by5tYWtlXyA9IGZ1bmN0aW9uIG1ha2VfKGtleSwgYW5ub3RhdGlvbikge1xuICAgIGlmIChhbm5vdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBhbm5vdGF0aW9uID0gdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICBpZiAoIShrZXkgaW4gdGhpcy50YXJnZXRfKSkge1xuICAgICAgdmFyIF90aGlzJHRhcmdldF8kc3RvcmVkQTtcbiAgICAgIC8vIFRocm93IG9uIG1pc3Npbmcga2V5LCBleGNlcHQgZm9yIGRlY29yYXRvcnM6XG4gICAgICAvLyBEZWNvcmF0b3IgYW5ub3RhdGlvbnMgYXJlIGNvbGxlY3RlZCBmcm9tIHdob2xlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gc3VwZXIoKSBzb21lIHByb3BzIG1heSBub3QgZXhpc3QgeWV0LlxuICAgICAgLy8gSG93ZXZlciB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG1pc3NpbmcgcHJvcCxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGRlY29yYXRvciBtdXN0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHNvbWV0aGluZy5cbiAgICAgIGlmICgoX3RoaXMkdGFyZ2V0XyRzdG9yZWRBID0gdGhpcy50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgIT0gbnVsbCAmJiBfdGhpcyR0YXJnZXRfJHN0b3JlZEFba2V5XSkge1xuICAgICAgICByZXR1cm47IC8vIHdpbGwgYmUgYW5ub3RhdGVkIGJ5IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWUoMSwgYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8sIHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMudGFyZ2V0XztcbiAgICB3aGlsZSAoc291cmNlICYmIHNvdXJjZSAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3Ioc291cmNlLCBrZXkpO1xuICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLm1ha2VfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDAgLyogTWFrZVJlc3VsdC5DYW5jZWwgKi8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDEgLyogTWFrZVJlc3VsdC5CcmVhayAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgICB9XG4gICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxuICAgKi87XG4gIF9wcm90by5leHRlbmRfID0gZnVuY3Rpb24gZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3IsIGFubm90YXRpb24sIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBhbm5vdGF0aW9uID0gdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICB9XG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLmV4dGVuZF8odGhpcywga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICAgIGlmIChvdXRjb21lKSB7XG4gICAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZCh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0Y29tZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcbiAgICovO1xuICBfcHJvdG8uZGVmaW5lUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH1cbiAgICAgIC8vIEFERCBpbnRlcmNlcHRvclxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZGVzY3JpcHRvciA9IF9leHRlbmRzKHt9LCBkZXNjcmlwdG9yLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGVmaW5lXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGlmeVxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcbiAgX3Byb3RvLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgdmFsdWUsIGVuaGFuY2VyLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIC8vIERlbGV0ZVxuICAgICAgdmFyIGRlbGV0ZU91dGNvbWUgPSB0aGlzLmRlbGV0ZV8oa2V5KTtcbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfVxuICAgICAgLy8gQUREIGludGVyY2VwdG9yXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGNhY2hlZERlc2NyaXB0b3IuZ2V0LFxuICAgICAgICBzZXQ6IGNhY2hlZERlc2NyaXB0b3Iuc2V0XG4gICAgICB9O1xuICAgICAgLy8gRGVmaW5lXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiLCBmYWxzZSk7XG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgb2JzZXJ2YWJsZSk7XG4gICAgICAvLyBOb3RpZnkgKHZhbHVlIHBvc3NpYmx5IGNoYW5nZWQgYnkgT2JzZXJ2YWJsZVZhbHVlKVxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIG9ic2VydmFibGUudmFsdWVfKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG4gIF9wcm90by5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkUHJvcGVydHlfKGtleSwgb3B0aW9ucywgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH1cbiAgICAgIC8vIEFERCBpbnRlcmNlcHRvclxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMubmFtZSB8fCAob3B0aW9ucy5uYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0ID0gdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfO1xuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTtcbiAgICAgIC8vIERlZmluZVxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucykpO1xuICAgICAgLy8gTm90aWZ5XG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdW5kZWZpbmVkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXG4gICAqLztcbiAgX3Byb3RvLmRlbGV0ZV8gPSBmdW5jdGlvbiBkZWxldGVfKGtleSwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIC8vIE5vIHN1Y2ggcHJvcFxuICAgIGlmICghaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJbnRlcmNlcHRcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgdHlwZTogUkVNT1ZFXG4gICAgICB9KTtcbiAgICAgIC8vIENhbmNlbGxlZFxuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERlbGV0ZVxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfO1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTtcbiAgICAgIC8vIFZhbHVlIG5lZWRlZCBmb3Igc3BpZXMvbGlzdGVuZXJzXG4gICAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBPcHRpbWl6YXRpb246IGRvbid0IHB1bGwgdGhlIHZhbHVlIHVubGVzcyB3ZSB3aWxsIG5lZWQgaXRcbiAgICAgIGlmICghb2JzZXJ2YWJsZSAmJiAobm90aWZ5IHx8IG5vdGlmeVNweSkpIHtcbiAgICAgICAgdmFyIF9nZXREZXNjcmlwdG9yO1xuICAgICAgICB2YWx1ZSA9IChfZ2V0RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodGhpcy50YXJnZXRfLCBrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBkZWxldGUgcHJvcCAoZG8gZmlyc3QsIG1heSBmYWlsKVxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRfW2tleV07XG4gICAgICB9XG4gICAgICAvLyBBbGxvdyByZS1hbm5vdGF0aW5nIHRoaXMgZmllbGRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwbGllZEFubm90YXRpb25zX1trZXldO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb2JzZXJ2YWJsZVxuICAgICAgaWYgKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RpZnk6IGF1dG9ydW4oKCkgPT4gb2JqW2tleV0pLCBzZWUgIzE3OTZcbiAgICAgICAgcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIC8vIE5vdGlmeSBcImhhc1wiIG9ic2VydmVyc1xuICAgICAgLy8gXCJpblwiIGFzIGl0IG1heSBzdGlsbCBleGlzdCBpbiBwcm90b1xuICAgICAgKF90aGlzJHBlbmRpbmdLZXlzXyA9IHRoaXMucGVuZGluZ0tleXNfKSA9PSBudWxsIHx8IChfdGhpcyRwZW5kaW5nS2V5c18gPSBfdGhpcyRwZW5kaW5nS2V5c18uZ2V0KGtleSkpID09IG51bGwgfHwgX3RoaXMkcGVuZGluZ0tleXNfLnNldChrZXkgaW4gdGhpcy50YXJnZXRfKTtcbiAgICAgIC8vIE5vdGlmeSBzcGllcy9saXN0ZW5lcnNcbiAgICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICAgIHZhciBfY2hhbmdlMiA9IHtcbiAgICAgICAgICB0eXBlOiBSRU1PVkUsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcbiAgICogZm9yIGNhbGxiYWNrIGRldGFpbHNcbiAgICovO1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhjYWxsYmFjaywgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIHtcbiAgICAgIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZpcmUgaW1tZWRpYXRlbHkgcHJvcGVydHkgZm9yIG9ic2VydmFibGUgb2JqZWN0cy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fID0gZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18yO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuICAgIChfdGhpcyRwZW5kaW5nS2V5c18yID0gdGhpcy5wZW5kaW5nS2V5c18pID09IG51bGwgfHwgKF90aGlzJHBlbmRpbmdLZXlzXzIgPSBfdGhpcyRwZW5kaW5nS2V5c18yLmdldChrZXkpKSA9PSBudWxsIHx8IF90aGlzJHBlbmRpbmdLZXlzXzIuc2V0KHRydWUpO1xuICAgIC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gIH07XG4gIF9wcm90by5vd25LZXlzXyA9IGZ1bmN0aW9uIG93bktleXNfKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIG93bktleXModGhpcy50YXJnZXRfKTtcbiAgfTtcbiAgX3Byb3RvLmtleXNfID0gZnVuY3Rpb24ga2V5c18oKSB7XG4gICAgLy8gUmV0dXJucyBlbnVtZXJhYmxlICYmIG93biwgYnV0IHVuZm9ydHVuYXRlbHkga2V5c0F0b20gd2lsbCByZXBvcnQgb24gQU5ZIGtleSBjaGFuZ2UuXG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gT2JqZWN0LmtleXMob2JqZWN0KSBhbmQgUmVmbGVjdC5vd25LZXlzKG9iamVjdCkgLSBib3RoIGFyZSBoYW5kbGVkIGJ5IG93bktleXMgdHJhcC5cbiAgICAvLyBXZSBjYW4gZWl0aGVyIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCkgb3IgdW5kZXItcmVwb3J0IGluIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpXG4gICAgLy8gV2UgY2hvb3NlIHRvIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCksIGJlY2F1c2U6XG4gICAgLy8gLSB0eXBpY2FsbHkgaXQncyB1c2VkIHdpdGggc2ltcGxlIGRhdGEgb2JqZWN0c1xuICAgIC8vIC0gd2hlbiBzeW1ib2xpYy9ub24tZW51bWVyYWJsZSBrZXlzIGFyZSByZWxldmFudCBSZWZsZWN0Lm93bktleXMgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRhcmdldF8pO1xuICB9O1xuICByZXR1cm4gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uO1xufSgpO1xuZnVuY3Rpb24gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkbmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRpb25zICYmIGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgZGllKFwiT3B0aW9ucyBjYW4ndCBiZSBwcm92aWRlZCBmb3IgYWxyZWFkeSBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICB9XG4gIGlmIChoYXNQcm9wKHRhcmdldCwgJG1vYngpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKGdldEFkbWluaXN0cmF0aW9uKHRhcmdldCkgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pKSB7XG4gICAgICBkaWUoXCJDYW5ub3QgY29udmVydCAnXCIgKyBnZXREZWJ1Z05hbWUodGFyZ2V0KSArIFwiJyBpbnRvIG9ic2VydmFibGUgb2JqZWN0OlwiICsgXCJcXG5UaGUgdGFyZ2V0IGlzIGFscmVhZHkgb2JzZXJ2YWJsZSBvZiBkaWZmZXJlbnQgdHlwZS5cIiArIFwiXFxuRXh0ZW5kaW5nIGJ1aWx0aW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkge1xuICAgIGRpZShcIkNhbm5vdCBtYWtlIHRoZSBkZXNpZ25hdGVkIG9iamVjdCBvYnNlcnZhYmxlOyBpdCBpcyBub3QgZXh0ZW5zaWJsZVwiKTtcbiAgfVxuICB2YXIgbmFtZSA9IChfb3B0aW9ucyRuYW1lID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPSBudWxsID8gX29wdGlvbnMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IChpc1BsYWluT2JqZWN0KHRhcmdldCkgPyBcIk9ic2VydmFibGVPYmplY3RcIiA6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lKSArIFwiQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVPYmplY3RcIjtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuZXcgTWFwKCksIFN0cmluZyhuYW1lKSwgZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsICRtb2J4LCBhZG0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKTtcbmZ1bmN0aW9uIGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3JDYWNoZVtrZXldIHx8IChkZXNjcmlwdG9yQ2FjaGVba2V5XSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB7XG4gIGlmIChpc09iamVjdCh0aGluZykpIHtcbiAgICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIGFubm90YXRpb24sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XSA9IGFubm90YXRpb247XG4gIH1cbiAgLy8gUmVtb3ZlIGFwcGxpZWQgZGVjb3JhdG9yIGFubm90YXRpb24gc28gd2UgZG9uJ3QgdHJ5IHRvIGFwcGx5IGl0IGFnYWluIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gIChfYWRtJHRhcmdldF8kc3RvcmVkQW4gPSBhZG0udGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgfHwgZGVsZXRlIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldO1xufVxuZnVuY3Rpb24gYXNzZXJ0QW5ub3RhYmxlKGFkbSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIC8vIFZhbGlkIGFubm90YXRpb25cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBbm5vdGF0aW9uKGFubm90YXRpb24pKSB7XG4gICAgZGllKFwiQ2Fubm90IGFubm90YXRlICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEludmFsaWQgYW5ub3RhdGlvbi5cIik7XG4gIH1cbiAgLypcbiAgLy8gQ29uZmlndXJhYmxlLCBub3Qgc2VhbGVkLCBub3QgZnJvemVuXG4gIC8vIFBvc3NpYmx5IG5vdCBuZWVkZWQsIGp1c3QgYSBsaXR0bGUgYmV0dGVyIGVycm9yIHRoZW4gdGhlIG9uZSB0aHJvd24gYnkgZW5naW5lLlxuICAvLyBDYXNlcyB3aGVyZSB0aGlzIHdvdWxkIGJlIHVzZWZ1bCB0aGUgbW9zdCAoc3ViY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXIpIGFyZSBub3QgaW50ZXJjZXB0YWJsZSBieSB0aGlzLlxuICBpZiAoX19ERVZfXykge1xuICAgICAgY29uc3QgY29uZmlndXJhYmxlID0gZ2V0RGVzY3JpcHRvcihhZG0udGFyZ2V0Xywga2V5KT8uY29uZmlndXJhYmxlXG4gICAgICBjb25zdCBmcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4oYWRtLnRhcmdldF8pXG4gICAgICBjb25zdCBzZWFsZWQgPSBPYmplY3QuaXNTZWFsZWQoYWRtLnRhcmdldF8pXG4gICAgICBpZiAoIWNvbmZpZ3VyYWJsZSB8fCBmcm96ZW4gfHwgc2VhbGVkKSB7XG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7YWRtLm5hbWVffS4ke2tleS50b1N0cmluZygpfWBcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfXG4gICAgICAgICAgbGV0IGVycm9yID0gYENhbm5vdCBhcHBseSAnJHtyZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZX0nIHRvICcke2ZpZWxkTmFtZX0nOmBcbiAgICAgICAgICBpZiAoZnJvemVuKSB7XG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5PYmplY3QgaXMgZnJvemVuLmBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIHNlYWxlZC5gXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5wcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlLmBcbiAgICAgICAgICAgICAgLy8gTWVudGlvbiBvbmx5IGlmIGNhdXNlZCBieSB1cyB0byBhdm9pZCBjb25mdXNpb25cbiAgICAgICAgICAgICAgaWYgKGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9ucyEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBcXG5UbyBwcmV2ZW50IGFjY2lkZW50YWwgcmUtZGVmaW5pdGlvbiBvZiBhIGZpZWxkIGJ5IGEgc3ViY2xhc3MsIGBcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBhbGwgYW5ub3RhdGVkIGZpZWxkcyBvZiBub24tcGxhaW4gb2JqZWN0cyAoY2xhc3NlcykgYXJlIG5vdCBjb25maWd1cmFibGUuYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpZShlcnJvcilcbiAgICAgIH1cbiAgfVxuICAqL1xuICAvLyBOb3QgYW5ub3RhdGVkXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zXywga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpO1xuICAgIHZhciBjdXJyZW50QW5ub3RhdGlvblR5cGUgPSBhZG0uYXBwbGllZEFubm90YXRpb25zX1trZXldLmFubm90YXRpb25UeXBlXztcbiAgICB2YXIgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXztcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsgZmllbGROYW1lICsgXCInOlwiICsgKFwiXFxuVGhlIGZpZWxkIGlzIGFscmVhZHkgYW5ub3RhdGVkIHdpdGggJ1wiICsgY3VycmVudEFubm90YXRpb25UeXBlICsgXCInLlwiKSArIFwiXFxuUmUtYW5ub3RhdGluZyBmaWVsZHMgaXMgbm90IGFsbG93ZWQuXCIgKyBcIlxcblVzZSAnb3ZlcnJpZGUnIGFubm90YXRpb24gZm9yIG1ldGhvZHMgb3ZlcnJpZGRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cblxuLy8gQnVnIGluIHNhZmFyaSA5LiogKG9yIGlPUyA5IHNhZmFyaSBtb2JpbGUpLiBTZWUgIzM2NFxudmFyIEVOVFJZXzAgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoMCk7XG52YXIgc2FmYXJpUHJvdG90eXBlU2V0dGVySW5oZXJpdGFuY2VCdWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgdiA9IGZhbHNlO1xuICB2YXIgcCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCIwXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgIHYgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKHApW1wiMFwiXSA9IDE7XG4gIHJldHVybiB2ID09PSBmYWxzZTtcbn0oKTtcbi8qKlxuICogVGhpcyBhcnJheSBidWZmZXIgY29udGFpbnMgdHdvIGxpc3RzIG9mIHByb3BlcnRpZXMsIHNvIHRoYXQgYWxsIGFycmF5c1xuICogY2FuIHJlY3ljbGUgdGhlaXIgcHJvcGVydHkgZGVmaW5pdGlvbnMsIHdoaWNoIHNpZ25pZmljYW50bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb2YgY3JlYXRpbmdcbiAqIHByb3BlcnRpZXMgb24gdGhlIGZseS5cbiAqL1xudmFyIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSAwO1xuLy8gVHlwZXNjcmlwdCB3b3JrYXJvdW5kIHRvIG1ha2Ugc3VyZSBPYnNlcnZhYmxlQXJyYXkgZXh0ZW5kcyBBcnJheVxudmFyIFN0dWJBcnJheSA9IGZ1bmN0aW9uIFN0dWJBcnJheSgpIHt9O1xuZnVuY3Rpb24gaW5oZXJpdChjdG9yLCBwcm90bykge1xuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlLCBwcm90byk7XG4gIH0gZWxzZSBpZiAoY3Rvci5wcm90b3R5cGUuX19wcm90b19fICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBwcm90bztcbiAgfSBlbHNlIHtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICB9XG59XG5pbmhlcml0KFN0dWJBcnJheSwgQXJyYXkucHJvdG90eXBlKTtcbi8vIFdlZXggcHJvdG8gZnJlZXplIHByb3RlY3Rpb24gd2FzIGhlcmUsXG4vLyBidXQgaXQgaXMgdW5jbGVhciB3aHkgdGhlIGhhY2sgaXMgbmVlZCBhcyBNb2JYIG5ldmVyIGNoYW5nZWQgdGhlIHByb3RvdHlwZVxuLy8gYW55d2F5LCBzbyByZW1vdmVkIGl0IGluIFY2XG52YXIgTGVnYWN5T2JzZXJ2YWJsZUFycmF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R1YkFycmF5KSB7XG4gIGZ1bmN0aW9uIExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVBcnJheVwiO1xuICAgIH1cbiAgICBpZiAob3duZWQgPT09IHZvaWQgMCkge1xuICAgICAgb3duZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgX3RoaXMgPSBfU3R1YkFycmF5LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBpbml0T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgdHJ1ZSk7XG4gICAgICBhZG0ucHJveHlfID0gX3RoaXM7XG4gICAgICBhZGRIaWRkZW5GaW5hbFByb3AoX3RoaXMsICRtb2J4LCBhZG0pO1xuICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfdGhpcy5zcGxpY2VXaXRoQXJyYXkoMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoc2FmYXJpUHJvdG90eXBlU2V0dGVySW5oZXJpdGFuY2VCdWcpIHtcbiAgICAgICAgLy8gU2VlbXMgdGhhdCBTYWZhcmkgd29uJ3QgdXNlIG51bWVyaWMgcHJvdG90eXBlIHNldHRlciB1bnRpbCBhbnkgKiBudW1lcmljIHByb3BlcnR5IGlzXG4gICAgICAgIC8vIGRlZmluZWQgb24gdGhlIGluc3RhbmNlLiBBZnRlciB0aGF0IGl0IHdvcmtzIGZpbmUsIGV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSBpcyBkZWxldGVkLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiMFwiLCBFTlRSWV8wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzTG9vc2UoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBfU3R1YkFycmF5KTtcbiAgdmFyIF9wcm90byA9IExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGU7XG4gIF9wcm90by5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdGhpc1skbW9ieF0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJyYXlzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJyYXlzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksXG4gICAgLy9AdHMtaWdub3JlXG4gICAgYXJyYXlzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGlzT2JzZXJ2YWJsZUFycmF5KGEpID8gYS5zbGljZSgpIDogYTtcbiAgICB9KSk7XG4gIH07XG4gIF9wcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBzZWxmLmxlbmd0aCA/IHtcbiAgICAgICAgICB2YWx1ZTogc2VsZltuZXh0SW5kZXgrK10sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMZWdhY3lPYnNlcnZhYmxlQXJyYXksIFt7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldEFycmF5TGVuZ3RoXygpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG59KFN0dWJBcnJheSk7XG5PYmplY3QuZW50cmllcyhhcnJheUV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHByb3AgPSBfcmVmWzBdLFxuICAgIGZuID0gX3JlZlsxXTtcbiAgaWYgKHByb3AgIT09IFwiY29uY2F0XCIpIHtcbiAgICBhZGRIaWRkZW5Qcm9wKExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIHByb3AsIGZuKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcihpbmRleCkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRfKGluZGV4KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRfKGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXlCdWZmZXJJdGVtKGluZGV4KSB7XG4gIGRlZmluZVByb3BlcnR5KExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIFwiXCIgKyBpbmRleCwgY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlc2VydmVBcnJheUJ1ZmZlcihtYXgpIHtcbiAgaWYgKG1heCA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkU7IGluZGV4IDwgbWF4ICsgMTAwOyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xuICAgIH1cbiAgICBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gbWF4O1xuICB9XG59XG5yZXNlcnZlQXJyYXlCdWZmZXIoMTAwMCk7XG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0b20odGhpbmcsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWUoMjMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XS5hdG9tXztcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZy5hdG9tXztcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGluZy5rZXlzQXRvbV87XG4gICAgICB9XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaW5nLmRhdGFfLmdldChwcm9wZXJ0eSkgfHwgdGhpbmcuaGFzTWFwXy5nZXQocHJvcGVydHkpO1xuICAgICAgaWYgKCFvYnNlcnZhYmxlKSB7XG4gICAgICAgIGRpZSgyNSwgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkaWUoMjYpO1xuICAgICAgfVxuICAgICAgdmFyIF9vYnNlcnZhYmxlID0gdGhpbmdbJG1vYnhdLnZhbHVlc18uZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICghX29ic2VydmFibGUpIHtcbiAgICAgICAgZGllKDI3LCBwcm9wZXJ0eSwgZ2V0RGVidWdOYW1lKHRoaW5nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29ic2VydmFibGU7XG4gICAgfVxuICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGluZykpIHtcbiAgICBpZiAoaXNSZWFjdGlvbih0aGluZ1skbW9ieF0pKSB7XG4gICAgICAvLyBkaXNwb3NlciBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG4gIH1cbiAgZGllKDI4KTtcbn1cbmZ1bmN0aW9uIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkge1xuICBpZiAoIXRoaW5nKSB7XG4gICAgZGllKDI5KTtcbiAgfVxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xuICB9XG4gIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgIHJldHVybiB0aGluZztcbiAgfVxuICBpZiAodGhpbmdbJG1vYnhdKSB7XG4gICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgfVxuICBkaWUoMjQsIHRoaW5nKTtcbn1cbmZ1bmN0aW9uIGdldERlYnVnTmFtZSh0aGluZywgcHJvcGVydHkpIHtcbiAgdmFyIG5hbWVkO1xuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpO1xuICB9IGVsc2UgaWYgKGlzQWN0aW9uKHRoaW5nKSkge1xuICAgIHJldHVybiB0aGluZy5uYW1lO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykgfHwgaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgbmFtZWQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdmFsaWQgZm9yIGFycmF5cyBhcyB3ZWxsXG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nKTtcbiAgfVxuICByZXR1cm4gbmFtZWQubmFtZV87XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgaW5pdGlhbGl6aW5nIG9ic2VydmFibGUgc3RydWN0dXJlcywgaXQgYXBwbGllczpcbiAqIDEuIGFsbG93U3RhdGVDaGFuZ2VzIHNvIHdlIGRvbid0IHZpb2xhdGUgZW5mb3JjZUFjdGlvbnMuXG4gKiAyLiB1bnRyYWNrZWQgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbHkgc3Vic2NyaWJlIHRvIGFueXRoaW5nIG9ic2VydmFibGUgYWNjZXNzZWQgZHVyaW5nIGluaXQgaW4gY2FzZSB0aGUgb2JzZXJ2YWJsZSBpcyBjcmVhdGVkIGluc2lkZSBkZXJpdmF0aW9uLlxuICogMy4gYmF0Y2ggdG8gYXZvaWQgc3RhdGUgdmVyc2lvbiB1cGRhdGVzXG4gKi9cbmZ1bmN0aW9uIGluaXRPYnNlcnZhYmxlKGNiKSB7XG4gIHZhciBkZXJpdmF0aW9uID0gdW50cmFja2VkU3RhcnQoKTtcbiAgdmFyIGFsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgc3RhcnRCYXRjaCgpO1xuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQoYWxsb3dTdGF0ZUNoYW5nZXMpO1xuICAgIHVudHJhY2tlZEVuZChkZXJpdmF0aW9uKTtcbiAgfVxufVxuXG52YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9XG4gIHJldHVybiBlcShhLCBiLCBkZXB0aCk7XG59XG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi81YzIzN2E3YzY4MmZiNjhmZDUzNzgyMDNmMGJmMjJkY2UxNjI0ODU0L3VuZGVyc2NvcmUuanMjTDExODYtTDEyODlcbi8vIE1vZGlmaWVkOiBcIkRlZXAgY29tcGFyZSBvYmplY3RzXCIgcGFydCB0byBpdGVyYXRlIG92ZXIga2V5cyBpbiBmb3J3YXJkIG9yZGVyIGluc3RlYWQgb2YgcmV2ZXJzZSBvcmRlci5cbi8vXG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuZnVuY3Rpb24gZXEoYSwgYiwgZGVwdGgsIGFTdGFjaywgYlN0YWNrKSB7XG4gIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICB9XG4gIC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICBpZiAoYSAhPT0gYSkge1xuICAgIHJldHVybiBiICE9PSBiO1xuICB9XG4gIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICBpZiAodHlwZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjpcbiAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTi5cbiAgICAgIGlmICgrYSAhPT0gK2EpIHtcbiAgICAgICAgcmV0dXJuICtiICE9PSArYjtcbiAgICAgIH1cbiAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgY2FzZSBcIltvYmplY3QgU3ltYm9sXVwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sLnZhbHVlT2YuY2FsbChiKTtcbiAgICBjYXNlIFwiW29iamVjdCBNYXBdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgU2V0XVwiOlxuICAgICAgLy8gTWFwcyBhbmQgU2V0cyBhcmUgdW53cmFwcGVkIHRvIGFycmF5cyBvZiBlbnRyeS1wYWlycywgYWRkaW5nIGFuIGluY2lkZW50YWwgbGV2ZWwuXG4gICAgICAvLyBIaWRlIHRoaXMgZXh0cmEgbGV2ZWwgYnkgaW5jcmVhc2luZyB0aGUgZGVwdGguXG4gICAgICBpZiAoZGVwdGggPj0gMCkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gIGEgPSB1bndyYXAoYSk7XG4gIGIgPSB1bndyYXAoYik7XG4gIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZGVwdGggPCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfVxuICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSB7XG4gICAgICByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgYVN0YWNrLnB1c2goYSk7XG4gIGJTdGFjay5wdXNoKGIpO1xuICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgaWYgKGFyZUFycmF5cykge1xuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIF9sZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgaWYgKE9iamVjdC5rZXlzKGIpLmxlbmd0aCAhPT0gX2xlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sZW5ndGg7IGkrKykge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIGFTdGFjay5wb3AoKTtcbiAgYlN0YWNrLnBvcCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcChhKSB7XG4gIGlmIChpc09ic2VydmFibGVBcnJheShhKSkge1xuICAgIHJldHVybiBhLnNsaWNlKCk7XG4gIH1cbiAgaWYgKGlzRVM2TWFwKGEpIHx8IGlzT2JzZXJ2YWJsZU1hcChhKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgfVxuICBpZiAoaXNFUzZTZXQoYSkgfHwgaXNPYnNlcnZhYmxlU2V0KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG52YXIgX2dldEdsb2JhbCRJdGVyYXRvcjtcbi8vIHNhZmVseSBnZXQgaXRlcmF0b3IgcHJvdG90eXBlIGlmIGF2YWlsYWJsZVxudmFyIG1heWJlSXRlcmF0b3JQcm90b3R5cGUgPSAoKF9nZXRHbG9iYWwkSXRlcmF0b3IgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCkuSXRlcmF0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0R2xvYmFsJEl0ZXJhdG9yLnByb3RvdHlwZSkgfHwge307XG5mdW5jdGlvbiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGdldFNlbGY7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobWF5YmVJdGVyYXRvclByb3RvdHlwZSksIGl0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGYoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBpc0Fubm90YXRpb24odGhpbmcpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBDYW4gYmUgZnVuY3Rpb25cbiAgICB0aGluZyBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgdGhpbmcuYW5ub3RhdGlvblR5cGVfID09PSBcInN0cmluZ1wiICYmIGlzRnVuY3Rpb24odGhpbmcubWFrZV8pICYmIGlzRnVuY3Rpb24odGhpbmcuZXh0ZW5kXylcbiAgKTtcbn1cblxuLyoqXG4gKiAoYykgTWljaGVsIFdlc3RzdHJhdGUgMjAxNSAtIDIwMjBcbiAqIE1JVCBMaWNlbnNlZFxuICpcbiAqIFdlbGNvbWUgdG8gdGhlIG1vYnggc291cmNlcyEgVG8gZ2V0IGEgZ2xvYmFsIG92ZXJ2aWV3IG9mIGhvdyBNb2JYIGludGVybmFsbHkgd29ya3MsXG4gKiB0aGlzIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydDpcbiAqIGh0dHBzOi8vbWVkaXVtLmNvbS9AbXdlc3RzdHJhdGUvYmVjb21pbmctZnVsbHktcmVhY3RpdmUtYW4taW4tZGVwdGgtZXhwbGFuYXRpb24tb2YtbW9ic2VydmFibGUtNTU5OTUyNjJhMjU0Iy54dmJoNnFkNzRcbiAqXG4gKiBTb3VyY2UgZm9sZGVyczpcbiAqID09PT09PT09PT09PT09PVxuICpcbiAqIC0gYXBpLyAgICAgTW9zdCBvZiB0aGUgcHVibGljIHN0YXRpYyBtZXRob2RzIGV4cG9zZWQgYnkgdGhlIG1vZHVsZSBjYW4gYmUgZm91bmQgaGVyZS5cbiAqIC0gY29yZS8gICAgSW1wbGVtZW50YXRpb24gb2YgdGhlIE1vYlggYWxnb3JpdGhtOyBhdG9tcywgZGVyaXZhdGlvbnMsIHJlYWN0aW9ucywgZGVwZW5kZW5jeSB0cmVlcywgb3B0aW1pemF0aW9ucy4gQ29vbCBzdHVmZiBjYW4gYmUgZm91bmQgaGVyZS5cbiAqIC0gdHlwZXMvICAgQWxsIHRoZSBtYWdpYyB0aGF0IGlzIG5lZWQgdG8gaGF2ZSBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgdmFsdWVzIGlzIGluIHRoaXMgZm9sZGVyLiBJbmNsdWRpbmcgdGhlIG1vZGlmaWVycyBsaWtlIGBhc0ZsYXRgLlxuICogLSB1dGlscy8gICBVdGlsaXR5IHN0dWZmLlxuICpcbiAqL1xuW1wiU3ltYm9sXCIsIFwiTWFwXCIsIFwiU2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgdmFyIGcgPSBnZXRHbG9iYWwoKTtcbiAgaWYgKHR5cGVvZiBnW21dID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGllKFwiTW9iWCByZXF1aXJlcyBnbG9iYWwgJ1wiICsgbSArIFwiJyB0byBiZSBhdmFpbGFibGUgb3IgcG9seWZpbGxlZFwiKTtcbiAgfVxufSk7XG5pZiAodHlwZW9mIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSBcIm9iamVjdFwiKSB7XG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZHlrb2cvbW9ieC1kZXZ0b29scy9cbiAgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0TW9ieCh7XG4gICAgc3B5OiBzcHksXG4gICAgZXh0cmFzOiB7XG4gICAgICBnZXREZWJ1Z05hbWU6IGdldERlYnVnTmFtZVxuICAgIH0sXG4gICAgJG1vYng6ICRtb2J4XG4gIH0pO1xufVxuXG5leHBvcnQgeyAkbW9ieCwgRmxvd0NhbmNlbGxhdGlvbkVycm9yLCBPYnNlcnZhYmxlTWFwLCBPYnNlcnZhYmxlU2V0LCBSZWFjdGlvbiwgYWxsb3dTdGF0ZUNoYW5nZXMgYXMgX2FsbG93U3RhdGVDaGFuZ2VzLCBydW5JbkFjdGlvbiBhcyBfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCwgYWxsb3dTdGF0ZVJlYWRzRW5kIGFzIF9hbGxvd1N0YXRlUmVhZHNFbmQsIGFsbG93U3RhdGVSZWFkc1N0YXJ0IGFzIF9hbGxvd1N0YXRlUmVhZHNTdGFydCwgYXV0b0FjdGlvbiBhcyBfYXV0b0FjdGlvbiwgX2VuZEFjdGlvbiwgZ2V0QWRtaW5pc3RyYXRpb24gYXMgX2dldEFkbWluaXN0cmF0aW9uLCBnZXRHbG9iYWxTdGF0ZSBhcyBfZ2V0R2xvYmFsU3RhdGUsIGludGVyY2VwdFJlYWRzIGFzIF9pbnRlcmNlcHRSZWFkcywgaXNDb21wdXRpbmdEZXJpdmF0aW9uIGFzIF9pc0NvbXB1dGluZ0Rlcml2YXRpb24sIHJlc2V0R2xvYmFsU3RhdGUgYXMgX3Jlc2V0R2xvYmFsU3RhdGUsIF9zdGFydEFjdGlvbiwgYWN0aW9uLCBhdXRvcnVuLCBjb21wYXJlciwgY29tcHV0ZWQsIGNvbmZpZ3VyZSwgY3JlYXRlQXRvbSwgYXBpRGVmaW5lUHJvcGVydHkgYXMgZGVmaW5lUHJvcGVydHksIGVudHJpZXMsIGV4dGVuZE9ic2VydmFibGUsIGZsb3csIGZsb3dSZXN1bHQsIGdldCwgZ2V0QXRvbSwgZ2V0RGVidWdOYW1lLCBnZXREZXBlbmRlbmN5VHJlZSwgZ2V0T2JzZXJ2ZXJUcmVlLCBoYXMsIGludGVyY2VwdCwgaXNBY3Rpb24sIGlzT2JzZXJ2YWJsZVZhbHVlIGFzIGlzQm94ZWRPYnNlcnZhYmxlLCBpc0NvbXB1dGVkLCBpc0NvbXB1dGVkUHJvcCwgaXNGbG93LCBpc0Zsb3dDYW5jZWxsYXRpb25FcnJvciwgaXNPYnNlcnZhYmxlLCBpc09ic2VydmFibGVBcnJheSwgaXNPYnNlcnZhYmxlTWFwLCBpc09ic2VydmFibGVPYmplY3QsIGlzT2JzZXJ2YWJsZVByb3AsIGlzT2JzZXJ2YWJsZVNldCwga2V5cywgbWFrZUF1dG9PYnNlcnZhYmxlLCBtYWtlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgb2JzZXJ2ZSwgb25CZWNvbWVPYnNlcnZlZCwgb25CZWNvbWVVbm9ic2VydmVkLCBvblJlYWN0aW9uRXJyb3IsIG92ZXJyaWRlLCBhcGlPd25LZXlzIGFzIG93bktleXMsIHJlYWN0aW9uLCByZW1vdmUsIHJ1bkluQWN0aW9uLCBzZXQsIHNweSwgdG9KUywgdHJhY2UsIHRyYW5zYWN0aW9uLCB1bnRyYWNrZWQsIHZhbHVlcywgd2hlbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ieC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsibmljZUVycm9ycyIsIl8iLCJhbm5vdGF0aW9uVHlwZSIsImtleSIsInRvU3RyaW5nIiwiaW5kZXgiLCJsZW5ndGgiLCJvdGhlciIsImNvbnN0cnVjdG9yIiwibmFtZSIsImRhdGFTdHJ1Y3R1cmUiLCJ0aGluZyIsInByb3BlcnR5IiwiZGVyaXZhdGlvbiIsIm1ldGhvZCIsImVycm9ycyIsInByb2Nlc3MiLCJkaWUiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiZSIsImFwcGx5IiwiRXJyb3IiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwibW9ja0dsb2JhbCIsImdldEdsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiYXNzaWduIiwiT2JqZWN0IiwiZ2V0RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5Iiwib2JqZWN0UHJvdG90eXBlIiwicHJvdG90eXBlIiwiRU1QVFlfQVJSQVkiLCJmcmVlemUiLCJFTVBUWV9PQkpFQ1QiLCJoYXNQcm94eSIsIlByb3h5IiwicGxhaW5PYmplY3RTdHJpbmciLCJhc3NlcnRQcm94aWVzIiwid2FybkFib3V0UHJveHlSZXF1aXJlbWVudCIsIm1zZyIsImdsb2JhbFN0YXRlIiwidmVyaWZ5UHJveGllcyIsImdldE5leHRJZCIsIm1vYnhHdWlkIiwib25jZSIsImZ1bmMiLCJpbnZva2VkIiwibm9vcCIsImlzRnVuY3Rpb24iLCJmbiIsImlzU3RyaW5naXNoIiwidmFsdWUiLCJ0IiwiaXNPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInByb3RvQ29uc3RydWN0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpc0dlbmVyYXRvciIsIm9iaiIsImRpc3BsYXlOYW1lIiwiYWRkSGlkZGVuUHJvcCIsIm9iamVjdCIsInByb3BOYW1lIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYWRkSGlkZGVuRmluYWxQcm9wIiwiY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZSIsInRoZUNsYXNzIiwieCIsImlzRVM2TWFwIiwiaXNQbGFpbkVTNk1hcCIsIm1hcFByb3RvIiwib2JqZWN0UHJvdG8iLCJudWxsUHJvdG8iLCJpc0VTNlNldCIsImhhc0dldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFBsYWluT2JqZWN0S2V5cyIsImtleXMiLCJzeW1ib2xzIiwiY29uY2F0IiwiZmlsdGVyIiwicyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib3duS2V5cyIsIlJlZmxlY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3RyaW5naWZ5S2V5IiwidG9QcmltaXRpdmUiLCJoYXNQcm9wIiwidGFyZ2V0IiwicHJvcCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJyZXMiLCJmb3JFYWNoIiwiZ2V0RmxhZyIsImZsYWdzIiwibWFzayIsInNldEZsYWciLCJuZXdWYWx1ZSIsIl9hcnJheUxpa2VUb0FycmF5IiwiciIsImEiLCJuIiwiX2RlZmluZVByb3BlcnRpZXMiLCJvIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuZXh0IiwiYmluZCIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJkb25lIiwiVHlwZUVycm9yIiwiX2V4dGVuZHMiLCJfaW5oZXJpdHNMb29zZSIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX3RvUHJpbWl0aXZlIiwiaSIsIk51bWJlciIsInNsaWNlIiwiZnJvbSIsInRlc3QiLCJzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCIsImNyZWF0ZURlY29yYXRvckFubm90YXRpb24iLCJhbm5vdGF0aW9uIiwiZGVjb3JhdG9yIiwiaXMyMDIyM0RlY29yYXRvciIsImRlY29yYXRlXzIwMjIzXyIsInN0b3JlQW5ub3RhdGlvbiIsImlzT3ZlcnJpZGUiLCJmaWVsZE5hbWUiLCJhc3NlcnROb3REZWNvcmF0ZWQiLCJjdXJyZW50QW5ub3RhdGlvblR5cGUiLCJhbm5vdGF0aW9uVHlwZV8iLCJyZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSIsImNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyIsImNvbnRleHQiLCJhc3NlcnQyMDIyM0RlY29yYXRvclR5cGUiLCJ0eXBlcyIsImluY2x1ZGVzIiwia2luZCIsIiRtb2J4IiwiQXRvbSIsIm5hbWVfIiwiZmxhZ3NfIiwib2JzZXJ2ZXJzXyIsIlNldCIsImxhc3RBY2Nlc3NlZEJ5XyIsImxvd2VzdE9ic2VydmVyU3RhdGVfIiwiSURlcml2YXRpb25TdGF0ZV8iLCJOT1RfVFJBQ0tJTkdfIiwib25CT0wiLCJvbkJVT0wiLCJfcHJvdG8iLCJvbkJPIiwibGlzdGVuZXIiLCJvbkJVTyIsInJlcG9ydE9ic2VydmVkIiwicmVwb3J0T2JzZXJ2ZWQkMSIsInJlcG9ydENoYW5nZWQiLCJzdGFydEJhdGNoIiwicHJvcGFnYXRlQ2hhbmdlZCIsImVuZEJhdGNoIiwiZ2V0IiwiaXNCZWluZ09ic2VydmVkTWFza18iLCJzZXQiLCJpc1BlbmRpbmdVbm9ic2VydmF0aW9uTWFza18iLCJkaWZmVmFsdWVNYXNrXyIsImlzQXRvbSIsImNyZWF0ZUF0b20iLCJvbkJlY29tZU9ic2VydmVkSGFuZGxlciIsIm9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIiLCJhdG9tIiwib25CZWNvbWVPYnNlcnZlZCIsIm9uQmVjb21lVW5vYnNlcnZlZCIsImlkZW50aXR5Q29tcGFyZXIiLCJiIiwic3RydWN0dXJhbENvbXBhcmVyIiwiZGVlcEVxdWFsIiwic2hhbGxvd0NvbXBhcmVyIiwiZGVmYXVsdENvbXBhcmVyIiwiaXMiLCJjb21wYXJlciIsImlkZW50aXR5Iiwic3RydWN0dXJhbCIsInNoYWxsb3ciLCJkZWVwRW5oYW5jZXIiLCJ2IiwiaXNPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsImFycmF5IiwidW5kZWZpbmVkIiwiaXNBY3Rpb24iLCJpc0Zsb3ciLCJmbG93IiwiYXV0b0FjdGlvbiIsInNoYWxsb3dFbmhhbmNlciIsImlzT2JzZXJ2YWJsZU9iamVjdCIsImlzT2JzZXJ2YWJsZUFycmF5IiwiaXNPYnNlcnZhYmxlTWFwIiwiaXNPYnNlcnZhYmxlU2V0IiwiZGVlcCIsInJlZmVyZW5jZUVuaGFuY2VyIiwicmVmU3RydWN0RW5oYW5jZXIiLCJvbGRWYWx1ZSIsIk9WRVJSSURFIiwib3ZlcnJpZGUiLCJtYWtlXyIsImV4dGVuZF8iLCJhZG0iLCJpc1BsYWluT2JqZWN0XyIsImFwcGxpZWRBbm5vdGF0aW9uc18iLCJkZXNjcmlwdG9yIiwicHJveHlUcmFwIiwiZGVzYyIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlQWN0aW9uQW5ub3RhdGlvbiIsIm9wdGlvbnMiLCJvcHRpb25zXyIsIm1ha2VfJDEiLCJleHRlbmRfJDEiLCJkZWNvcmF0ZV8yMDIyM18kMSIsInNvdXJjZSIsIl90aGlzJG9wdGlvbnNfIiwiYm91bmQiLCJ0YXJnZXRfIiwiYWN0aW9uRGVzY3JpcHRvciIsImNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eV8iLCJtdGhkIiwiYWRkSW5pdGlhbGl6ZXIiLCJhbm4iLCJfY3JlYXRlQWN0aW9uIiwibSIsIl9hbm4kb3B0aW9uc18kbmFtZSIsIl9hbm4kb3B0aW9uc18iLCJfYW5uJG9wdGlvbnNfJGF1dG9BY3QiLCJfYW5uJG9wdGlvbnNfMiIsImNyZWF0ZUFjdGlvbiIsImluaXRNdGhkIiwiX2FubiRvcHRpb25zXzMiLCJpc01vYnhBY3Rpb24iLCJfdGhpcyRvcHRpb25zXzIiLCJhc3NlcnRBY3Rpb25EZXNjcmlwdG9yIiwiX3JlZiIsIl9yZWYyIiwic2FmZURlc2NyaXB0b3JzIiwiX2Fubm90YXRpb24kb3B0aW9uc18iLCJfYW5ub3RhdGlvbiRvcHRpb25zXyQiLCJfYW5ub3RhdGlvbiRvcHRpb25zXzIiLCJfYW5ub3RhdGlvbiRvcHRpb25zXyQyIiwiX2Fubm90YXRpb24kb3B0aW9uc18zIiwiX2Fubm90YXRpb24kb3B0aW9uc180IiwiX2FkbSRwcm94eV8yIiwiX2FkbSRwcm94eV8iLCJwcm94eV8iLCJjcmVhdGVGbG93QW5ub3RhdGlvbiIsIm1ha2VfJDIiLCJleHRlbmRfJDIiLCJkZWNvcmF0ZV8yMDIyM18kMiIsImZsb3dEZXNjcmlwdG9yIiwiY3JlYXRlRmxvd0Rlc2NyaXB0b3IiLCJfdGhpcyRvcHRpb25zXzMiLCJpc01vYlhGbG93IiwiYXNzZXJ0Rmxvd0Rlc2NyaXB0b3IiLCJjcmVhdGVDb21wdXRlZEFubm90YXRpb24iLCJtYWtlXyQzIiwiZXh0ZW5kXyQzIiwiZGVjb3JhdGVfMjAyMjNfJDMiLCJhc3NlcnRDb21wdXRlZERlc2NyaXB0b3IiLCJkZWZpbmVDb21wdXRlZFByb3BlcnR5XyIsImFzT2JzZXJ2YWJsZU9iamVjdCIsInZhbHVlc18iLCJDb21wdXRlZFZhbHVlIiwiZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8iLCJjcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbiIsIm1ha2VfJDQiLCJleHRlbmRfJDQiLCJkZWNvcmF0ZV8yMDIyM18kNCIsIl90aGlzJG9wdGlvbnNfJGVuaGFuYyIsImFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yIiwiZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyIsImVuaGFuY2VyIiwiaW5pdGlhbGl6ZWRPYmplY3RzIiwiV2Vha1NldCIsImluaXRpYWxpemVPYnNlcnZhYmxlIiwiX2FubiRvcHRpb25zXyRlbmhhbmNlIiwiT2JzZXJ2YWJsZVZhbHVlIiwiYWRkIiwiaGFzIiwic2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8iLCJpbml0IiwiQVVUTyIsImF1dG9Bbm5vdGF0aW9uIiwiY3JlYXRlQXV0b0Fubm90YXRpb24iLCJtYWtlXyQ1IiwiZXh0ZW5kXyQ1IiwiZGVjb3JhdGVfMjAyMjNfJDUiLCJfdGhpcyRvcHRpb25zXzQiLCJjb21wdXRlZCIsImZsb3dBbm5vdGF0aW9uIiwiYXV0b0JpbmQiLCJhY3Rpb25Bbm5vdGF0aW9uIiwib2JzZXJ2YWJsZUFubm90YXRpb24iLCJyZWYiLCJfdGhpcyRvcHRpb25zXzUiLCJfdGhpcyRvcHRpb25zXzYiLCJPQlNFUlZBQkxFIiwiT0JTRVJWQUJMRV9SRUYiLCJPQlNFUlZBQkxFX1NIQUxMT1ciLCJPQlNFUlZBQkxFX1NUUlVDVCIsImRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyIsImRlZmF1bHREZWNvcmF0b3IiLCJwcm94eSIsImFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMiLCJvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiIsIm9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiIsIm9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uIiwib2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24iLCJnZXRFbmhhbmNlckZyb21PcHRpb25zIiwiZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbiIsImdldEFubm90YXRpb25Gcm9tT3B0aW9ucyIsIl9vcHRpb25zJGRlZmF1bHREZWNvciIsImNyZWF0ZU9ic2VydmFibGUiLCJhcmcyIiwiYXJnMyIsImJveCIsIm9ic2VydmFibGVGYWN0b3JpZXMiLCJlcXVhbHMiLCJpbml0aWFsVmFsdWVzIiwidXNlUHJveGllcyIsImNyZWF0ZUxlZ2FjeUFycmF5IiwiY3JlYXRlT2JzZXJ2YWJsZUFycmF5IiwiT2JzZXJ2YWJsZU1hcCIsIk9ic2VydmFibGVTZXQiLCJwcm9wcyIsImRlY29yYXRvcnMiLCJpbml0T2JzZXJ2YWJsZSIsImV4dGVuZE9ic2VydmFibGUiLCJhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0Iiwic3RydWN0IiwiQ09NUFVURUQiLCJDT01QVVRFRF9TVFJVQ1QiLCJjb21wdXRlZEFubm90YXRpb24iLCJjb21wdXRlZFN0cnVjdEFubm90YXRpb24iLCJhcmcxIiwib3B0cyIsIl9nZXREZXNjcmlwdG9yJGNvbmZpZyIsIl9nZXREZXNjcmlwdG9yIiwiY3VycmVudEFjdGlvbklkIiwibmV4dEFjdGlvbklkIiwiaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUiLCJ0bXBOYW1lRGVzY3JpcHRvciIsImFjdGlvbk5hbWUiLCJleGVjdXRlQWN0aW9uIiwiY2FuUnVuQXNEZXJpdmF0aW9uIiwic2NvcGUiLCJydW5JbmZvIiwiX3N0YXJ0QWN0aW9uIiwiZXJyIiwiZXJyb3JfIiwiX2VuZEFjdGlvbiIsIm5vdGlmeVNweV8iLCJpc1NweUVuYWJsZWQiLCJzdGFydFRpbWVfIiwiRGF0ZSIsIm5vdyIsImZsYXR0ZW5lZEFyZ3MiLCJzcHlSZXBvcnRTdGFydCIsInR5cGUiLCJBQ1RJT04iLCJwcmV2RGVyaXZhdGlvbl8iLCJ0cmFja2luZ0Rlcml2YXRpb24iLCJydW5Bc0FjdGlvbiIsInByZXZBbGxvd1N0YXRlQ2hhbmdlc18iLCJhbGxvd1N0YXRlQ2hhbmdlcyIsInVudHJhY2tlZFN0YXJ0IiwiYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCIsInByZXZBbGxvd1N0YXRlUmVhZHNfIiwiYWxsb3dTdGF0ZVJlYWRzU3RhcnQiLCJydW5Bc0FjdGlvbl8iLCJhY3Rpb25JZF8iLCJwYXJlbnRBY3Rpb25JZF8iLCJzdXBwcmVzc1JlYWN0aW9uRXJyb3JzIiwiYWxsb3dTdGF0ZUNoYW5nZXNFbmQiLCJhbGxvd1N0YXRlUmVhZHNFbmQiLCJ1bnRyYWNrZWRFbmQiLCJzcHlSZXBvcnRFbmQiLCJ0aW1lIiwicHJldiIsIkNSRUFURSIsIl9BdG9tIiwibm90aWZ5U3B5IiwiX3RoaXMiLCJoYXNVbnJlcG9ydGVkQ2hhbmdlXyIsImludGVyY2VwdG9yc18iLCJjaGFuZ2VMaXN0ZW5lcnNfIiwidmFsdWVfIiwiZGVoYW5jZXIiLCJzcHlSZXBvcnQiLCJvYnNlcnZhYmxlS2luZCIsImRlYnVnT2JqZWN0TmFtZSIsImRlaGFuY2VWYWx1ZSIsInByZXBhcmVOZXdWYWx1ZV8iLCJVTkNIQU5HRUQiLCJVUERBVEUiLCJzZXROZXdWYWx1ZV8iLCJjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCIsImhhc0ludGVyY2VwdG9ycyIsImNoYW5nZSIsImludGVyY2VwdENoYW5nZSIsImhhc0xpc3RlbmVycyIsIm5vdGlmeUxpc3RlbmVycyIsImludGVyY2VwdF8iLCJoYW5kbGVyIiwicmVnaXN0ZXJJbnRlcmNlcHRvciIsIm9ic2VydmVfIiwiZmlyZUltbWVkaWF0ZWx5IiwicmVnaXN0ZXJMaXN0ZW5lciIsInJhdyIsInRvSlNPTiIsInZhbHVlT2YiLCJpc09ic2VydmFibGVWYWx1ZSIsImRlcGVuZGVuY2llc1N0YXRlXyIsIm9ic2VydmluZ18iLCJuZXdPYnNlcnZpbmdfIiwicnVuSWRfIiwiVVBfVE9fREFURV8iLCJ1bmJvdW5kRGVwc0NvdW50XyIsIkNhdWdodEV4Y2VwdGlvbiIsInRyaWdnZXJlZEJ5XyIsInNldHRlcl8iLCJpc1RyYWNpbmdfIiwiVHJhY2VNb2RlIiwiTk9ORSIsInNjb3BlXyIsImVxdWFsc18iLCJyZXF1aXJlc1JlYWN0aW9uXyIsImtlZXBBbGl2ZV8iLCJjb21wYXJlU3RydWN0dXJhbCIsInJlcXVpcmVzUmVhY3Rpb24iLCJrZWVwQWxpdmUiLCJvbkJlY29tZVN0YWxlXyIsInByb3BhZ2F0ZU1heWJlQ2hhbmdlZCIsImlzQ29tcHV0aW5nIiwiaW5CYXRjaCIsInNpemUiLCJzaG91bGRDb21wdXRlIiwid2FybkFib3V0VW50cmFja2VkUmVhZF8iLCJjb21wdXRlVmFsdWVfIiwicHJldlRyYWNraW5nQ29udGV4dCIsInRyYWNraW5nQ29udGV4dCIsInRyYWNrQW5kQ29tcHV0ZSIsInByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCIsInJlc3VsdCIsImlzQ2F1Z2h0RXhjZXB0aW9uIiwiY2F1c2UiLCJpc1J1bm5pbmdTZXR0ZXIiLCJ3YXNTdXNwZW5kZWQiLCJjaGFuZ2VkIiwidHJhY2siLCJ0cmFja0Rlcml2ZWRGdW5jdGlvbiIsImRpc2FibGVFcnJvckJvdW5kYXJpZXMiLCJzdXNwZW5kXyIsImNsZWFyT2JzZXJ2aW5nIiwibG9nIiwiZmlyc3RUaW1lIiwicHJldlZhbHVlIiwiYXV0b3J1biIsInByZXZVIiwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uIiwiaXNDb21wdXRpbmdNYXNrXyIsImlzUnVubmluZ1NldHRlck1hc2tfIiwiaXNDb21wdXRlZFZhbHVlIiwiU1RBTEVfIiwiUE9TU0lCTFlfU1RBTEVfIiwicHJldkFsbG93U3RhdGVSZWFkcyIsInByZXZVbnRyYWNrZWQiLCJvYnMiLCJsIiwiY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAiLCJpc0NvbXB1dGluZ0Rlcml2YXRpb24iLCJoYXNPYnNlcnZlcnMiLCJlbmZvcmNlQWN0aW9ucyIsImNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZCIsImFsbG93U3RhdGVSZWFkcyIsIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uIiwiZiIsInJ1bklkIiwicHJldlRyYWNraW5nIiwiYmluZERlcGVuZGVuY2llcyIsIndhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzIiwicmVxdWlyZXNPYnNlcnZhYmxlXyIsInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlIiwicHJldk9ic2VydmluZyIsIm9ic2VydmluZyIsImxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSIsImkwIiwiZGVwIiwiZGlmZlZhbHVlIiwiX2RlcCIsInJlbW92ZU9ic2VydmVyIiwiX2RlcDIiLCJhZGRPYnNlcnZlciIsInVudHJhY2tlZCIsImFjdGlvbiIsInBlcnNpc3RlbnRLZXlzIiwiTW9iWEdsb2JhbHMiLCJ2ZXJzaW9uIiwicGVuZGluZ1Vub2JzZXJ2YXRpb25zIiwicGVuZGluZ1JlYWN0aW9ucyIsImlzUnVubmluZ1JlYWN0aW9ucyIsInNweUxpc3RlbmVycyIsImdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycyIsImNhbk1lcmdlR2xvYmFsU3RhdGUiLCJpc29sYXRlQ2FsbGVkIiwiX19tb2J4SW5zdGFuY2VDb3VudCIsIl9fbW9ieEdsb2JhbHMiLCJzZXRUaW1lb3V0IiwiaXNvbGF0ZUdsb2JhbFN0YXRlIiwiZ2V0R2xvYmFsU3RhdGUiLCJyZXNldEdsb2JhbFN0YXRlIiwiZGVmYXVsdEdsb2JhbHMiLCJpbmRleE9mIiwiZ2V0T2JzZXJ2ZXJzIiwibm9kZSIsInF1ZXVlRm9yVW5vYnNlcnZhdGlvbiIsImlzUGVuZGluZ1Vub2JzZXJ2YXRpb24iLCJwdXNoIiwicnVuUmVhY3Rpb25zIiwibGlzdCIsImlzQmVpbmdPYnNlcnZlZCIsImQiLCJsb2dUcmFjZUluZm8iLCJCUkVBSyIsImxpbmVzIiwicHJpbnREZXBUcmVlIiwiZ2V0RGVwZW5kZW5jeVRyZWUiLCJGdW5jdGlvbiIsInJlcGxhY2UiLCJ0cmVlIiwiZGVwdGgiLCJyZXBlYXQiLCJkZXBlbmRlbmNpZXMiLCJjaGlsZCIsIlJlYWN0aW9uIiwib25JbnZhbGlkYXRlXyIsImVycm9ySGFuZGxlcl8iLCJzY2hlZHVsZV8iLCJpc1NjaGVkdWxlZCIsInJ1blJlYWN0aW9uXyIsImlzRGlzcG9zZWQiLCJpc1RyYWNrUGVuZGluZyIsInJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8iLCJub3RpZnkiLCJzdGFydFRpbWUiLCJpc1J1bm5pbmciLCJwcmV2UmVhY3Rpb24iLCJtZXNzYWdlIiwiZGlzcG9zZSIsImdldERpc3Bvc2VyXyIsImFib3J0U2lnbmFsIiwiX3RoaXMyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0cmFjZSIsInRyYWNlJDEiLCJlbnRlckJyZWFrUG9pbnQiLCJpc0Rpc3Bvc2VkTWFza18iLCJpc1NjaGVkdWxlZE1hc2tfIiwiaXNUcmFja1BlbmRpbmdNYXNrXyIsImlzUnVubmluZ01hc2tfIiwib25SZWFjdGlvbkVycm9yIiwiaWR4Iiwic3BsaWNlIiwiTUFYX1JFQUNUSU9OX0lURVJBVElPTlMiLCJyZWFjdGlvblNjaGVkdWxlciIsInJ1blJlYWN0aW9uc0hlbHBlciIsImFsbFJlYWN0aW9ucyIsIml0ZXJhdGlvbnMiLCJyZW1haW5pbmdSZWFjdGlvbnMiLCJpc1JlYWN0aW9uIiwic2V0UmVhY3Rpb25TY2hlZHVsZXIiLCJiYXNlU2NoZWR1bGVyIiwiZXZlbnQiLCJsaXN0ZW5lcnMiLCJFTkRfRVZFTlQiLCJzcHkiLCJBQ1RJT05fQk9VTkQiLCJBVVRPQUNUSU9OIiwiQVVUT0FDVElPTl9CT1VORCIsIkRFRkFVTFRfQUNUSU9OX05BTUUiLCJhY3Rpb25Cb3VuZEFubm90YXRpb24iLCJhdXRvQWN0aW9uQW5ub3RhdGlvbiIsImF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24iLCJjcmVhdGVBY3Rpb25GYWN0b3J5IiwicnVuSW5BY3Rpb24iLCJ2aWV3IiwiX29wdHMkbmFtZSIsIl9vcHRzIiwiX29wdHMyIiwiX29wdHMzIiwicnVuU3luYyIsInNjaGVkdWxlciIsImRlbGF5IiwicmVhY3Rpb24iLCJyZWFjdGlvblJ1bm5lciIsIm9uRXJyb3IiLCJyZXF1aXJlc09ic2VydmFibGUiLCJjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyIsInNpZ25hbCIsImFib3J0ZWQiLCJydW4iLCJleHByZXNzaW9uIiwiZWZmZWN0IiwiX29wdHMkbmFtZTIiLCJfb3B0czQiLCJfb3B0czUiLCJlZmZlY3RBY3Rpb24iLCJ3cmFwRXJyb3JIYW5kbGVyIiwibmV4dFZhbHVlIiwiZXJyb3JIYW5kbGVyIiwiYmFzZUZuIiwiT05fQkVDT01FX09CU0VSVkVEIiwiT05fQkVDT01FX1VOT0JTRVJWRUQiLCJpbnRlcmNlcHRIb29rIiwiaG9vayIsImdldEF0b20iLCJjYiIsImxpc3RlbmVyc0tleSIsImhvb2tMaXN0ZW5lcnMiLCJORVZFUiIsIkFMV0FZUyIsIk9CU0VSVkVEIiwiY29uZmlndXJlIiwiZWEiLCJwcm9wZXJ0aWVzIiwiYW5ub3RhdGlvbnMiLCJkZXNjcmlwdG9ycyIsIm5vZGVUb0RlcGVuZGVuY3lUcmVlIiwidW5pcXVlIiwiZ2V0T2JzZXJ2ZXJUcmVlIiwibm9kZVRvT2JzZXJ2ZXJUcmVlIiwib2JzZXJ2ZXJzIiwiZ2VuZXJhdG9ySWQiLCJGbG93Q2FuY2VsbGF0aW9uRXJyb3IiLCJpc0Zsb3dDYW5jZWxsYXRpb25FcnJvciIsImZsb3dCb3VuZEFubm90YXRpb24iLCJnZW5lcmF0b3IiLCJjdHgiLCJnZW4iLCJyZWplY3RvciIsInBlbmRpbmdQcm9taXNlIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3RlcElkIiwib25GdWxmaWxsZWQiLCJyZXQiLCJvblJlamVjdGVkIiwidGhlbiIsImNhbmNlbCIsImNhbmNlbFByb21pc2UiLCJfcmVzIiwieWllbGRlZFByb21pc2UiLCJmbG93UmVzdWx0IiwiaW50ZXJjZXB0UmVhZHMiLCJwcm9wT3JIYW5kbGVyIiwiZ2V0QWRtaW5pc3RyYXRpb24iLCJpbnRlcmNlcHQiLCJpbnRlcmNlcHRQcm9wZXJ0eSIsImludGVyY2VwdEludGVyY2VwdGFibGUiLCJfaXNDb21wdXRlZCIsImlzQ29tcHV0ZWQiLCJpc0NvbXB1dGVkUHJvcCIsIl9pc09ic2VydmFibGUiLCJpc09ic2VydmFibGVQcm9wIiwia2V5c18iLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiX3ZhbHVlcyIsInNldF8iLCJwYXJzZUludCIsInJlbW92ZSIsImRlbGV0ZV8iLCJoYXNfIiwiZ2V0XyIsImFwaURlZmluZVByb3BlcnR5IiwiYXBpT3duS2V5cyIsIm93bktleXNfIiwib2JzZXJ2ZSIsInByb3BPckNiIiwiY2JPckZpcmUiLCJvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5Iiwib2JzZXJ2ZU9ic2VydmFibGUiLCJjYWNoZSIsInRvSlNIZWxwZXIiLCJfX2FscmVhZHlTZWVuIiwiX3JlczIiLCJNYXAiLCJfcmVzMyIsInRvSlMiLCJwb3AiLCJnZXRBdG9tRnJvbUFyZ3MiLCJMT0ciLCJ0cmFuc2FjdGlvbiIsInRoaXNBcmciLCJ3aGVuIiwicHJlZGljYXRlIiwid2hlblByb21pc2UiLCJfd2hlbiIsInRpbWVvdXRIYW5kbGUiLCJ0aW1lb3V0IiwiZGlzcG9zZXIiLCJjb25kIiwiY2xlYXJUaW1lb3V0IiwiX29wdHMkc2lnbmFsIiwiYWJvcnQiLCJfb3B0cyRzaWduYWwyIiwiX29wdHMkc2lnbmFsMyIsImdldEFkbSIsIm9iamVjdFByb3h5VHJhcHMiLCJfZ2V0QWRtJHNldF8iLCJkZWxldGVQcm9wZXJ0eSIsIl9nZXRBZG0kZGVsZXRlXyIsIl9nZXRBZG0kZGVmaW5lUHJvcGVydCIsInByZXZlbnRFeHRlbnNpb25zIiwiX3RhcmdldCQkbW9ieCIsIl90YXJnZXQkJG1vYngkcHJveHlfIiwiaW50ZXJjZXB0YWJsZSIsImludGVyY2VwdG9ycyIsImxpc3RlbmFibGUiLCJtYWtlT2JzZXJ2YWJsZSIsIl9hbm5vdGF0aW9ucyIsImtleXNTeW1ib2wiLCJtYWtlQXV0b09ic2VydmFibGUiLCJvdmVycmlkZXMiLCJTUExJQ0UiLCJNQVhfU1BMSUNFX1NJWkUiLCJhcnJheVRyYXBzIiwiZ2V0QXJyYXlMZW5ndGhfIiwiaXNOYU4iLCJhcnJheUV4dGVuc2lvbnMiLCJzZXRBcnJheUxlbmd0aF8iLCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiIsIm93bmVkXyIsImxlZ2FjeU1vZGVfIiwiYXRvbV8iLCJlbmhhbmNlcl8iLCJsYXN0S25vd25MZW5ndGhfIiwibmV3ViIsIm9sZFYiLCJkZWhhbmNlVmFsdWVfIiwiZGVoYW5jZVZhbHVlc18iLCJhZGRlZCIsImFkZGVkQ291bnQiLCJyZW1vdmVkIiwicmVtb3ZlZENvdW50IiwibmV3TGVuZ3RoIiwiY3VycmVudExlbmd0aCIsIm5ld0l0ZW1zIiwic3BsaWNlV2l0aEFycmF5XyIsInVwZGF0ZUFycmF5TGVuZ3RoXyIsIm9sZExlbmd0aCIsImRlbHRhIiwicmVzZXJ2ZUFycmF5QnVmZmVyIiwiZGVsZXRlQ291bnQiLCJNYXRoIiwibWF4IiwibWluIiwibGVuZ3RoRGVsdGEiLCJzcGxpY2VJdGVtc0ludG9WYWx1ZXNfIiwibm90aWZ5QXJyYXlTcGxpY2VfIiwiX3RoaXMkdmFsdWVzXyIsIm9sZEl0ZW1zIiwiX2kiLCJub3RpZnlBcnJheUNoaWxkVXBkYXRlXyIsIm93bmVkIiwiY2xlYXIiLCJzcGxpY2VXaXRoQXJyYXkiLCJfbGVuMiIsIml0ZW1zIiwiX2tleTIiLCJzaGlmdCIsInVuc2hpZnQiLCJfbGVuMyIsIl9rZXkzIiwicmV2ZXJzZSIsInNvcnQiLCJjb3B5IiwiYWRkQXJyYXlFeHRlbnNpb24iLCJzaW1wbGVGdW5jIiwibWFwTGlrZUZ1bmMiLCJyZWR1Y2VMaWtlRnVuYyIsImZ1bmNOYW1lIiwiZnVuY0ZhY3RvcnkiLCJkZWhhbmNlZFZhbHVlcyIsImNhbGxiYWNrIiwiZWxlbWVudCIsIl90aGlzMyIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiIsIk9ic2VydmFibGVNYXBNYXJrZXIiLCJBREQiLCJERUxFVEUiLCJpbml0aWFsRGF0YSIsImRhdGFfIiwiaGFzTWFwXyIsImtleXNBdG9tXyIsIm1lcmdlIiwiZW50cnkiLCJuZXdFbnRyeSIsImhhc0tleSIsInVwZGF0ZVZhbHVlXyIsImFkZFZhbHVlXyIsIl9kZWxldGUiLCJfY2hhbmdlIiwiX3RoaXMzJGhhc01hcF8kZ2V0IiwiX3RoaXM0IiwiX3RoaXM0JGhhc01hcF8kZ2V0IiwibWFrZUl0ZXJhYmxlRm9yTWFwIiwiX2tleXMkbmV4dCIsIl9rZXlzJG5leHQyIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfc3RlcCR2YWx1ZSIsIl90aGlzNSIsIl90aGlzNiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJfdGhpczciLCJyZXBsYWNlbWVudE1hcCIsImNvbnZlcnRUb01hcCIsIm9yZGVyZWREYXRhIiwia2V5c1JlcG9ydENoYW5nZWRDYWxsZWQiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiZGVsZXRlZCIsIl9pdGVyYXRvcjQiLCJfc3RlcDQiLCJfc3RlcDQkdmFsdWUiLCJfdmFsdWUiLCJrZXlFeGlzdGVkIiwiX3ZhbHVlMiIsIml0ZXIxIiwiaXRlcjIiLCJuZXh0MSIsIm5leHQyIiwidG9TdHJpbmdUYWciLCJtYWtlSXRlcmFibGUiLCJPYnNlcnZhYmxlU2V0TWFya2VyIiwiY2FsbGJhY2tGbiIsIl9jaGFuZ2UyIiwibWFrZUl0ZXJhYmxlRm9yU2V0IiwiX3ZhbHVlcyRuZXh0IiwiX3ZhbHVlcyRuZXh0MiIsImludGVyc2VjdGlvbiIsIm90aGVyU2V0IiwiZGVoYW5jZWRTZXQiLCJ1bmlvbiIsImRpZmZlcmVuY2UiLCJzeW1tZXRyaWNEaWZmZXJlbmNlIiwiaXNTdWJzZXRPZiIsImlzU3VwZXJzZXRPZiIsImlzRGlzam9pbnRGcm9tIiwiZGVzY3JpcHRvckNhY2hlIiwiUkVNT1ZFIiwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uIiwiZGVmYXVsdEFubm90YXRpb25fIiwicGVuZGluZ0tleXNfIiwiaXNBbm5vdGF0aW9uIiwiYXNzZXJ0QW5ub3RhYmxlIiwiX3RoaXMkdGFyZ2V0XyRzdG9yZWRBIiwib3V0Y29tZSIsInJlY29yZEFubm90YXRpb25BcHBsaWVkIiwiZGVsZXRlT3V0Y29tZSIsIm5vdGlmeVByb3BlcnR5QWRkaXRpb25fIiwiY2FjaGVkRGVzY3JpcHRvciIsImdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvciIsIl90aGlzJHBlbmRpbmdLZXlzXyIsIl90aGlzJHBlbmRpbmdLZXlzXzIiLCJfb3B0aW9ucyRuYW1lIiwiZ2V0RGVidWdOYW1lIiwiaXNFeHRlbnNpYmxlIiwiaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24iLCJfYWRtJHRhcmdldF8kc3RvcmVkQW4iLCJFTlRSWV8wIiwiY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IiLCJzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1ZyIsInAiLCJPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFIiwiU3R1YkFycmF5IiwiaW5oZXJpdCIsImN0b3IiLCJMZWdhY3lPYnNlcnZhYmxlQXJyYXkiLCJfU3R1YkFycmF5IiwiYXJyYXlzIiwibmV4dEluZGV4IiwiY3JlYXRlQXJyYXlCdWZmZXJJdGVtIiwiX29ic2VydmFibGUiLCJuYW1lZCIsImVxIiwiYVN0YWNrIiwiYlN0YWNrIiwiY2xhc3NOYW1lIiwidW53cmFwIiwiYXJlQXJyYXlzIiwiYUN0b3IiLCJiQ3RvciIsIl9sZW5ndGgiLCJfZ2V0R2xvYmFsJEl0ZXJhdG9yIiwibWF5YmVJdGVyYXRvclByb3RvdHlwZSIsIkl0ZXJhdG9yIiwiZ2V0U2VsZiIsImciLCJfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImluamVjdE1vYngiLCJleHRyYXMiLCJfYWxsb3dTdGF0ZUNoYW5nZXMiLCJfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCIsIl9hbGxvd1N0YXRlUmVhZHNFbmQiLCJfYWxsb3dTdGF0ZVJlYWRzU3RhcnQiLCJfYXV0b0FjdGlvbiIsIl9nZXRBZG1pbmlzdHJhdGlvbiIsIl9nZXRHbG9iYWxTdGF0ZSIsIl9pbnRlcmNlcHRSZWFkcyIsIl9pc0NvbXB1dGluZ0Rlcml2YXRpb24iLCJfcmVzZXRHbG9iYWxTdGF0ZSIsImlzQm94ZWRPYnNlcnZhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx/dist/mobx.esm.js\n");

/***/ })

};
;